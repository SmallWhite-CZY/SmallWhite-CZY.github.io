<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白——电脑白痴的成长过程</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-01T06:07:32.347Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CZY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c结构指针</title>
    <link href="http://yoursite.com/2018/06/01/fifth/"/>
    <id>http://yoursite.com/2018/06/01/fifth/</id>
    <published>2018-06-01T06:01:28.201Z</published>
    <updated>2018-06-01T06:07:32.347Z</updated>
    
    <content type="html"><![CDATA[<p>  这篇文章内容介绍非常清楚，可以弄下来仅供参考。<br>指针结构与指针的关系亦有两重：其一是在定义结构时，将指针作为结构中的一个成员；其二是指向结构的指针（称为结构指针）。前者同一般的结构成员一样可直接进行访问，后者是本节讨论的重点。<br><a id="more"></a></p><blockquote><p>结构指针说明的一般形式是：<br>struct 结构类型名称 <em> 结构指针变量名；<br>例如：struct date </em> pdate, today;<br>说明了两个变量，一个是指向结构date的结构指针pdate，today是一个date结构变量。语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pdate = &amp;today;</span><br><span class="line">pdate today (struct date)</span><br><span class="line">　　year</span><br><span class="line">　　month</span><br><span class="line">　　day</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>  通过结构变量today访问其成员的操作，也可以用等价的指针形式表示：<br>today.year = 2001;　　等价于　　(<em>pdate).year = 2001;<br>由于运算符”</em>“的优先级比运算符”.”的优先级低，所以必须有”( )”将<em>pdate括起来。若省去括号，则含义就变成了”</em>(pdate.year)”。<br>在Ｃ语言中，通过结构指针访问成员可以采用运算符”-&gt;”进行操作，对于指向结构的指针，为了访问其成员可以采用下列语句形式：<br>结构指针-&gt;成员名;<br>这样，上面通过结构指针pdate访问成员year的操作就可以写成：<br>pdate-&gt;year = 2001;<br>如果结构指针p指向一个结构数组，那么对指针p的操作就等价于对数组下标的操作。<br>　　结构指针是指向一种结构类型的指针变量，它是结构在内存中的首地址，结构指针具有一般指针的特性，如在一定条件下两个指针可以进行比较，也可以与整数进行加减。但在指针操作时应注意：进行地址运算时的放大因子由所指向的结构的实际大小决定。</p></blockquote><h2 id="例11-7"><a href="#例11-7" class="headerlink" title="例11-7"></a>例11-7</h2><p>用结构指针改写加密程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">struct table</span><br><span class="line">&#123; char input, output;</span><br><span class="line">&#125; ;</span><br><span class="line">struct table translate[ ]=</span><br><span class="line">&#123; &apos;a&apos;, &apos;d&apos;, &apos;b&apos;, &apos;w&apos;, &apos;c&apos;, &apos;k&apos;, &apos;d&apos;, &apos;;&apos; , &apos;e&apos;, &apos;i&apos;,</span><br><span class="line">&apos;i&apos;, &apos;a&apos;, &apos;k&apos;, &apos;b&apos;, &apos;;&apos;, &apos;c&apos;, &apos;w&apos;, &apos;e&apos;</span><br><span class="line">&#125;; 　　　　　　/* 建立加密对照表 */</span><br><span class="line">main( )</span><br><span class="line">&#123; char ch;</span><br><span class="line">struct table *p, *pend; /* p和pend为指向结构table的指针 */</span><br><span class="line">pend = &amp; translate[ sizeof(translate)/sizeof(struct table)-1 ];</span><br><span class="line">/* pend指向结构数组translate的最后一个元素 */</span><br><span class="line">while ( (ch=getchar( )) != &apos;/n&apos;)</span><br><span class="line">&#123; for ( p=translate ; p-&gt;input!=ch &amp;&amp; p!=pend; p++ ) ;</span><br><span class="line">if ( p-&gt;input==ch ) </span><br><span class="line">putchar( p-&gt;output);</span><br><span class="line">else</span><br><span class="line">putchar (ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读者可以将两个程序对照阅读，体会结构指针特点。程序中用pend指向数组的最后一个元素。<br>由于结构指针和在结构中将指针作为成员，使得对于结构变量的运算和对成员的操作变得较为复杂。由于取内容的”*”与”.”和”-&gt;”运算符的优先级与结合性不同，使得对成员的访问和操作又增加了一层难度，再因为”++”和”–”运算所具有的”先操作”与”后操作”的特性，以及”++”和”–”运算的结合性，使得”++”和–”运算与结构操作混合在一起时，实际操作会更为复杂。</p><h2 id="例11-8"><a href="#例11-8" class="headerlink" title="例11-8"></a>例11-8</h2><blockquote><p>请分析程序的运算结果。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">struct s</span><br><span class="line">&#123; int x, *y; /* y: 结构中的成员是指向整型的指针 */</span><br><span class="line">&#125; *p; /* p: 指向结构的指针 */</span><br><span class="line">int data[5]=&#123;10, 20, 30, 40, 50,&#125;; /* data: 整型数组 */</span><br><span class="line">struct s array[5]=</span><br><span class="line">&#123; 100, &amp;data[0], 200, &amp;data[1], 300, &amp;data[2],</span><br><span class="line">400, &amp;data[3], 500, &amp;data[4]</span><br><span class="line">&#125;; /* array: 结构数组 */</span><br><span class="line">main ( )</span><br><span class="line">&#123; p=array; /* 指针p指向结构数组的首地址 */</span><br><span class="line">printf (&quot;For printer:/n&quot;);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x);</span><br><span class="line">printf (&quot;%d/n&quot;, (*p).x); </span><br><span class="line">printf (&quot;%d/n&quot;, *p-&gt;y);</span><br><span class="line">printf (&quot;%d/n&quot;, *(*p).y);</span><br><span class="line">printf (&quot;%d/n&quot;, ++p-&gt;x);</span><br><span class="line">printf (&quot;%d/n&quot;, (++p)-&gt;x);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x++);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x); </span><br><span class="line">printf (&quot;%d/n&quot;, ++ (*p-&gt;y));</span><br><span class="line">printf (&quot;%d/n&quot;, ++ * p-&gt;y); </span><br><span class="line">printf (&quot;%d/n&quot;, * ++ p-&gt;y);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x); </span><br><span class="line">printf (&quot;%d/n&quot;, * (++p)-&gt;y);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x); </span><br><span class="line">printf (&quot;%d/n&quot;, * p-&gt;y ++);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x); </span><br><span class="line">printf (&quot;%d/n&quot;, * (p-&gt;y) ++);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x); </span><br><span class="line">printf (&quot;%d/n&quot;, * p ++ -&gt;y);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结构数组array的初始化后的状态如图11.4所示。程序中指针操作的含义如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;x /* 取结构指针p指向的结构的成员x的值，输出 100 */</span><br><span class="line">(*p).x /* 取结构指针p的内容的成员x的值，功能同上，输出 100 */</span><br><span class="line">*p-&gt;y /* 取结构指针p的指针成员y的内容，输出 10 */</span><br><span class="line">*(*p).y /* 取结构指针p的内容的指针成员y的内容，功能同上，输出10 */</span><br><span class="line">++p-&gt;x /* p所指的x加1，x先加1后再输出 101 ，p不加1 */</span><br><span class="line">(++p)-&gt;x /* p先加1后再取x的值，x不加1，输出 200 */</span><br><span class="line">p-&gt;x++ /* 先取x的值后x再加1，输出 200 */</span><br><span class="line">p-&gt;x /* 输出 201 */</span><br><span class="line">++(*p-&gt;y) /* p所指的y的内容先加1，输出 21 ，p不加1，y也不加1 */</span><br><span class="line">++ *p-&gt;y /* 同上，由运算的结合性隐含了括号，输出 22 */</span><br><span class="line">* ++p-&gt;y /* y先加1后再取y的内容，输出30，p不加1，y的内容不加1 */</span><br><span class="line">p-&gt;x /* 输出 201 */</span><br><span class="line">*(++p)-&gt;y /* p先加1后取所指y的内容，输出 30 */</span><br><span class="line">p-&gt;x /* 输出 300 */</span><br><span class="line">*p-&gt;y ++ /* 取p所指的y的内容，输出 30，然后p所指的y加1 */</span><br><span class="line">p-&gt;x /* 输出 300 */</span><br><span class="line">*(p-&gt;y)++ /* 取p所指的y的内容，输出 40，然后p所指的y加1 */</span><br><span class="line">p-&gt;x /* 输出 300 */</span><br><span class="line">*p++-&gt;y /* 取p所指的y的内容，输出 50，然后p加1 */</span><br><span class="line">p-&gt;x /* 输出 400 */</span><br></pre></td></tr></table></figure><h2 id="例11-9"><a href="#例11-9" class="headerlink" title="例11-9"></a>例11-9</h2><p>可用一个结构表示学生的学号和成绩，编写程序，对班中30名学生按成绩进行排序，并输出排序后的学号、成绩和全班平均分。</p><figure class="highlight plain"><figcaption><span><stdio.h></stdio.h></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#define STNUM 30 /* 全班同学人数 */</span><br><span class="line">struct stuinf</span><br><span class="line">&#123; int stid; /* 学生学号 */</span><br><span class="line">int score; /* 学生成绩 */</span><br><span class="line">&#125; stu[STNUM]; /* stu: 结构数组 */</span><br><span class="line">main ( )</span><br><span class="line">&#123; struct stuinf *ptemp, /* ptemp:指向结构的指针, 临时变量 */</span><br><span class="line">*p[STNUM]; /* p:指向结构的指针构成的指针数组 */</span><br><span class="line">int i, j, k, sum=0; /* i,j,k:临时变量；sum:分数累计 */</span><br><span class="line">for (i=0; i&lt;=STNUM-1; i++) /* 输入学生的学号和成绩 */</span><br><span class="line">&#123; scanf (&quot;%d%d&quot;, &amp;stu[i].stid, &amp;stu[i].score); /* 输入学生的学号和成绩 */</span><br><span class="line">p[i] = &amp;stu[i];</span><br><span class="line">/* 指针数组p[i]的第i个指针(元素)指向结构数组的第i个元素 */</span><br><span class="line">sum += stu[i].score;　　 　 　/* 累计学生的分数 */</span><br><span class="line">&#125;</span><br><span class="line">for ( i=0; i&lt;=STNUM-2; i++ ) /* 排序操作 */</span><br><span class="line">&#123; k = i; /* k：在第i次循环中，指向当前最高分的指针在指针数组p中的下标 */</span><br><span class="line">for (j=i; j&lt;=STNUM-1; j++)</span><br><span class="line">if (p[k]-&gt;score &lt; p[j]-&gt;score) k=j;</span><br><span class="line">/* 查找当前最大值, k中存放最大值对应的指针在指针数组p中的下标 */</span><br><span class="line">if ( k!=i ) /* 当k不等于i时，交换两个指向结构的指针 */</span><br><span class="line">&#123; ptemp = p[i];</span><br><span class="line">p[i] = p[k];</span><br><span class="line">p[k] = ptemp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (i=0; i&lt;=STNUM-1; i++) /* 按排序顺序输出学号和成绩 */</span><br><span class="line">printf(&quot;%d,%d/n&quot;, (*p[i]).stid, p[i]-&gt;score);</span><br><span class="line">printf (&quot;average score = %d/n&quot;, sum/STNUM); /* 输出平均分 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　程序中使用了较为复杂的数据结构，包括：结构数组stu，指向结构的指针ptemp，由指向结构的指针构成的指针数组p。<br>程序在结构数组stu和指针数组p之间建立了对应的指针关系，从而为简化后续处理打下了良好的基础。在排序过程中，程序使用选择排序的思想，先查找确定当前的最大值，再进行一次有实效的数据交换。进行数据交换时，也没有交换结构数据本身，而是交换了指向结构数据的指针。在输出时，按照排序后指针的顺序，输出排序后的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  这篇文章内容介绍非常清楚，可以弄下来仅供参考。&lt;br&gt;指针结构与指针的关系亦有两重：其一是在定义结构时，将指针作为结构中的一个成员；其二是指向结构的指针（称为结构指针）。前者同一般的结构成员一样可直接进行访问，后者是本节讨论的重点。&lt;br&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://yoursite.com/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>有关java中@的代指--注解</title>
    <link href="http://yoursite.com/2018/06/01/java@/"/>
    <id>http://yoursite.com/2018/06/01/java@/</id>
    <published>2018-06-01T05:35:20.013Z</published>
    <updated>2018-06-01T05:50:57.584Z</updated>
    
    <content type="html"><![CDATA[<p>java中的注解，java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标准(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。<br><a id="more"></a></p><h2 id="什么是java注解"><a href="#什么是java注解" class="headerlink" title="什么是java注解"></a>什么是java注解</h2><blockquote><p> 注解，顾名思义，注解,就是对某一事物进行添加注释说明，会存放一些信息，这些信息可能对以后某个时段来说是很有用处的。<br> Java注解又叫java标注，java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标准(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。</p></blockquote><h2 id="自定义Java标注"><a href="#自定义Java标注" class="headerlink" title="自定义Java标注"></a>自定义Java标注</h2><h3 id="为什么要自定义注解"><a href="#为什么要自定义注解" class="headerlink" title="为什么要自定义注解"></a>为什么要自定义注解</h3><blockquote><p>  Java从1.5版本以后默认内置三个标注：<br>Ø @Override:只能用在方法之上的，用来告诉别人这一个方法是改写父类的。<br>Ø @Deprecated:建议别人不要使用旧的API的时候用的,编译的时候会用产生警告信息,可以设定在程序里的所有的元素上.<br>Ø @SuppressWarnings:这一个类型可以来暂时把一些警告信息消息关闭.<br>但是，仅仅这三个标注是不能满足我们开发时一些需求的。所以java允许我们自定义注解来使用。</p></blockquote><h3 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h3><blockquote><p>自定义步骤大致分为两步：<br>  1通过@interface关键字(注意，不是interface，是@interace)声明注解名称，以及注解的成员属性或者叫做注解的参数。<br>  2使用java内置的四个元注解对这个自定义标注的功能和范围进行一些限制<br>问题来了，什么是元注解？</p></blockquote><h3 id="什么是元注解"><a href="#什么是元注解" class="headerlink" title="什么是元注解"></a>什么是元注解</h3><blockquote><p>元注解，就是定义注解的注解，也就是说这些元注解是的作用就是专门用来约束其它注解的注解。请区别上面那三个注解，他们也是通过元注解定义而来的。<br>元注解有哪些呢，主要有四个@Target,@Retention,@Documented,@Inherited？<br>元注解有：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Target,@Retention,@Documented,@Inherited </span><br><span class="line">@Target 表示该注解用于什么地方，可能的 ElemenetType 参数包括： </span><br><span class="line">ElemenetType.CONSTRUCTOR 构造器声明 </span><br><span class="line">ElemenetType.FIELD 域声明（包括 enum 实例） </span><br><span class="line">ElemenetType.LOCAL_VARIABLE 局部变量声明 </span><br><span class="line">ElemenetType.METHOD 方法声明 </span><br><span class="line">ElemenetType.PACKAGE 包声明 </span><br><span class="line">ElemenetType.PARAMETER 参数声明 </span><br><span class="line">ElemenetType.TYPE 类，接口（包括注解类型）或enum声明  </span><br><span class="line">@Retention 表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括： </span><br><span class="line">RetentionPolicy.SOURCE 注解将被编译器丢弃 </span><br><span class="line">RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 </span><br><span class="line">RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。   </span><br><span class="line">@Documented 将此注解包含在 javadoc 中 </span><br><span class="line">@Inherited 允许子类继承父类中的注解</span><br></pre></td></tr></table></figure><h3 id="自定义及使用注解示例"><a href="#自定义及使用注解示例" class="headerlink" title="自定义及使用注解示例"></a>自定义及使用注解示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//自定义一个类级别的标注Description </span><br><span class="line">package lighter.javaeye.com;</span><br><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">@Target(ElementType.TYPE)//这个标注应用于类</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)//标注会一直保留到运行时</span><br><span class="line">@Documented//将此注解包含在javadoc中</span><br><span class="line">public @interface Description &#123;</span><br><span class="line">String value();</span><br><span class="line">&#125; </span><br><span class="line">再定义个方法级别的注解Name</span><br><span class="line">package lighter.javaeye.com;</span><br><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target; </span><br><span class="line">//注意这里的@Target与@Description里的不同,参数成员也不同</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Name &#123;</span><br><span class="line">String originate();</span><br><span class="line">String community();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   然后使用以上两个注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package lighter.javaeye.com; </span><br><span class="line">  @Description(value=&quot;javaeye,做最棒的软件开发交流社区&quot;)</span><br><span class="line">  public class JavaEyer &#123;</span><br><span class="line">  @Name(originate=&quot;创始人:robbin&quot;,community=&quot;javaEye&quot;)</span><br><span class="line">  public String getName()</span><br><span class="line">  &#123;</span><br><span class="line">     return null;</span><br><span class="line">  &#125;        </span><br><span class="line">  @Name(originate=&quot;创始人:江南白衣&quot;,community=&quot;springside&quot;)</span><br><span class="line">  public String getName2()</span><br><span class="line">  &#123;</span><br><span class="line">     return &quot;借用两位的id一用,写这一个例子,请见谅!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>说明：其中标注“@Description(value=”javaeye,做最棒的软件开发交流社区”)”，可以写成“@Description(“javaeye,做最棒的软件开发交流社区”) ”，结果也是一样的。因为Description标注定义的时候其参数(或者说属性)为value。而value比较特殊，它在被指定参数的时候可以不用显示的写出来。当然如果定义的时候参数名不是value而是其它的比如des，那么使用注解的时候，必须显示写出参数名，然后再赋值：@Description(Des=”xxx”)</strong><br>提取出注解的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> package lighter.javaeye.com; </span><br><span class="line"> import java.lang.reflect.Method;</span><br><span class="line"> import java.util.HashSet;</span><br><span class="line"> import java.util.Set;</span><br><span class="line"> public class TestAnnotation &#123;</span><br><span class="line">   /*** author lighter* 说明:具体关天Annotation的API的用法请参见javaDoc文档*/</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">   String CLASS_NAME = &quot;lighter.javaeye.com.JavaEyer&quot;;</span><br><span class="line">   Class test = Class.forName(CLASS_NAME);</span><br><span class="line">   Method[] method = test.getMethods();</span><br><span class="line">   boolean flag = test.isAnnotationPresent(Description.class);</span><br><span class="line">  if(flag)</span><br><span class="line">  &#123;</span><br><span class="line">   Description des = (Description)test.getAnnotation(Description.class);</span><br><span class="line">   System.out.println(&quot;描述:&quot;+des.value());</span><br><span class="line">   System.out.println(&quot;-----------------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   //把JavaEyer这一类有利用到@Name的全部方法保存到Set中去</span><br><span class="line">   Set&lt;Method&gt; set = new HashSet&lt;Method&gt;();</span><br><span class="line">   for(int i=0;i&lt;method.length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   boolean otherFlag = method[i].isAnnotationPresent(Name.class);</span><br><span class="line">   if(otherFlag) set.add(method[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   for(Method m: set)</span><br><span class="line">   &#123;</span><br><span class="line">   Name name = m.getAnnotation(Name.class);</span><br><span class="line">   System.out.println(name.originate());</span><br><span class="line">   System.out.println(&quot;创建的社区:&quot;+name.community());</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p>所有的Annotation会自动继承java.lang.annotation这一个接口,所以不能再去继承别的类或是接口.<br>   最重要的一点,Annotation类型里面的参数该怎么设定:<br>   第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型.<br>   第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中的注解，java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标准(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA SE" scheme="http://yoursite.com/categories/JAVA-SE/"/>
    
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://yoursite.com/2018/06/01/forth/"/>
    <id>http://yoursite.com/2018/06/01/forth/</id>
    <published>2018-06-01T05:24:28.434Z</published>
    <updated>2018-06-01T05:25:52.821Z</updated>
    
    <content type="html"><![CDATA[<p>我们总是探讨求解最优的问题，却总是忽略了求解的过程，如何达到最优化的问题，才是我们应该研究的目的，综上贪心算法便给我们提供了一点思路。<br><a id="more"></a></p><h2 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h2><blockquote><p> 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。<br> 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。<br>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p></blockquote><h2 id="二、贪心算法的基本思路："><a href="#二、贪心算法的基本思路：" class="headerlink" title="二、贪心算法的基本思路："></a>二、贪心算法的基本思路：</h2><blockquote><p>1.建立数学模型来描述问题。<br>2.把求解的问题分成若干个子问题。<br>3.对每一子问题求解，得到子问题的局部最优解。<br>4.把子问题的解局部最优解合成原来解问题的一个解。</p></blockquote><h2 id="三、贪心算法适用的问题"><a href="#三、贪心算法适用的问题" class="headerlink" title="三、贪心算法适用的问题"></a>三、贪心算法适用的问题</h2><blockquote><p>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。<br>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p></blockquote><h2 id="四、贪心算法的实现框架"><a href="#四、贪心算法的实现框架" class="headerlink" title="四、贪心算法的实现框架"></a>四、贪心算法的实现框架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从问题的某一初始解出发；</span><br><span class="line">while （能朝给定总目标前进一步）</span><br><span class="line">&#123; </span><br><span class="line">  利用可行的决策，求出可行解的一个解元素；</span><br><span class="line">&#125;</span><br><span class="line">由所有解元素组合成问题的一个可行解；</span><br></pre></td></tr></table></figure><h2 id="五、贪心策略的选择"><a href="#五、贪心策略的选择" class="headerlink" title="五、贪心策略的选择"></a>五、贪心策略的选择</h2><blockquote><p> 因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p></blockquote><h2 id="六、例题分析"><a href="#六、例题分析" class="headerlink" title="六、例题分析"></a>六、例题分析</h2><blockquote><p>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。</p></blockquote><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><blockquote><p>有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。<br>要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<br>物品 A B C D E F G<br>重量 35 30 60 50 40 10 25<br>价值 10 40 30 50 35 40 30<br>分析：<br>目标函数： ∑pi最大<br>约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)<br>（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？<br>（2）每次挑选所占重量最小的物品装入是否能得到最优解？<br>（3）每次选取单位重量价值最大的物品，成为解本题的策略。<br>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。<br>贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。<br>可惜的是，它需要证明后才能真正运用到题目的算法中。<br>一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。<br>对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：<br>（1）贪心策略：选取价值最大者。反例：<br>W=30<br>物品：A B C<br>重量：28 12 12<br>价值：30 20 20<br>根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。<br>（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。<br>（3）贪心策略：选取单位重量价值最大的物品。反例：<br>W=30<br>物品：A B C<br>重量：28 20 10<br>价值：28 20 10<br>根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。<br>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。比如，求最小生成树的Prim算法和Kruskal算法都是漂亮的贪心算法。</p></blockquote><h3 id="均分纸牌"><a href="#均分纸牌" class="headerlink" title="均分纸牌"></a>均分纸牌</h3><blockquote><p>有N堆纸牌，编号分别为1，2，…，n。每堆上有若干张,但纸牌总数必为n的倍数.可以在任一堆上取若干张纸牌,然后移动。移牌的规则为：在编号为1上取的纸牌，只能移到编号为2的堆上；在编号为n的堆上取的纸牌，只能移到编号为n-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。例如：n=4，4堆纸牌分别为：① 9 ② 8 ③ 17 ④ 6 移动三次可以达到目的：从③取4张牌放到④ 再从③区3张放到②然后从②去1张放到①。<br>输入输出样例：4<br>9 8 17 6<br>屏幕显示：3<br>算法分析：设a[i]为第I堆纸牌的张数（0&lt;=I&lt;=n），v为均分后每堆纸牌的张数，s为最小移动次数。<br>我们用贪心算法，按照从左到右的顺序移动纸牌。如第I堆的纸牌数不等于平均值，则移动一次（即s加1），分两种情况移动：<br>1．若a[i]&gt;v，则将a[i]-v张从第I堆移动到第I+1堆；<br>2．若a[i]&lt;v，则将v-a[i]张从第I+1堆移动到第I堆。<br>为了设计的方便，我们把这两种情况统一看作是将a[i]-v从第I堆移动到第I+1堆，移动后有a[i]=v; a[I+1]=a[I+1]+a[i]-v.<br>在从第I+1堆取出纸牌补充第I堆的过程中可能回出现第I+1堆的纸牌小于零的情况。<br>如n=3，三堆指派数为1 2 27 ，这时v=10，为了使第一堆为10，要从第二堆移9张到第一堆，而第二堆只有2张可以移，这是不是意味着刚才使用贪心法是错误的呢？<br>我们继续按规则分析移牌过程，从第二堆移出9张到第一堆后，第一堆有10张，第二堆剩下-7张，在从第三堆移动17张到第二堆，刚好三堆纸牌都是10，最后结果是对的，我们在移动过程中，只是改变了移动的顺序，而移动次数不便，因此此题使用贪心法可行的。<br>Java源程序：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Greedy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  int n = 0, avg =0, s = 0;</span><br><span class="line">  Scanner scanner = new Scanner(System.in);</span><br><span class="line">  ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line">  System.out.println(&quot;Please input the number of heaps:&quot;);</span><br><span class="line">  n = scanner.nextInt();</span><br><span class="line">  System.out.println(&quot;Please input heap number:&quot;);</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">   array.add(scanner.nextInt());</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0; i &lt; array.size(); i ++)&#123;</span><br><span class="line">   avg += array.get(i);</span><br><span class="line">  &#125;</span><br><span class="line">  avg = avg/array.size();</span><br><span class="line">  System.out.println(array.size());</span><br><span class="line">  System.out.println(avg);</span><br><span class="line">  for(int i = 0; i &lt; array.size()-1; i ++)&#123;</span><br><span class="line">   s++;</span><br><span class="line">   array.set(i+1, array.get(i+1)+array.get(i)-avg);   </span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(&quot;s:&quot; + s);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用贪心算法解题，需要解决两个问题：<br>一是问题是否适合用贪心法求解。我们看一个找币的例子，如果一个货币系统有三种币值，面值分别为一角、五分和一分，求最小找币数时，可以用贪心法求解；如果将这三种币值改为一角一分、五分和一分，就不能使用贪心法求解。用贪心法解题很方便，但它的适用范围很小，判断一个问题是否适合用贪心法求解，目前还没有一个通用的方法，在信息学竞赛中，需要凭个人的经验来判断。<br>二是确定了可以用贪心算法之后，如何选择一个贪心标准，才能保证得到问题的最优解。在选择贪心标准时，我们要对所选的贪心标准进行验证才能使用，不要被表面上看似正确的贪心标准所迷惑，如下面的例子。</p></blockquote><h3 id="最大整数"><a href="#最大整数" class="headerlink" title="最大整数"></a>最大整数</h3><blockquote><p>设有n个正整数，将它们连接成一排，组成一个最大的多位整数。<br>例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。<br>又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。<br>输入：n<br>N个数<br>输出：连成的多位数<br>算法分析：此题很容易想到使用贪心法，在考试时有很多同学把整数按从大到小的顺序连接起来，测试题目的例子也都符合，但最后测试的结果却不全对。按这种标准，我们很容易找到反例：12，121应该组成12121而非12112，那么是不是相互包含的时候就从小到大呢？也不一定，如12，123就是12312而非12123，这种情况就有很多种了。是不是此题不能用贪心法呢？<br>其实此题可以用贪心法来求解，只是刚才的标准不对，正确的标准是：先把整数转换成字符串，然后在比较a+b和b+a，如果a+b&gt;=b+a，就把a排在b的前面，反之则把a排在b的后面。</p></blockquote><p>java源程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  String str = &quot;&quot;;</span><br><span class="line">  ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();</span><br><span class="line">  Scanner in = new Scanner(System.in);</span><br><span class="line">  System.out.println(&quot;Please input the number of data:&quot;);</span><br><span class="line">  int n = in.nextInt();</span><br><span class="line">  System.out.println(&quot;Please input the data:&quot;);</span><br><span class="line">  while (n-- &gt; 0) &#123;</span><br><span class="line">   array.add(in.next());   </span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0; i &lt; array.size(); i ++)</span><br><span class="line">   for(int j = i + 1; j &lt; array.size(); j ++)&#123;</span><br><span class="line">   if((array.get(i) + array.get(j)).compareTo(array.get(j) + array.get(i)) &lt; 0)&#123;</span><br><span class="line">   String temp = array.get(i);</span><br><span class="line">   array.set(i, array.get(j));</span><br><span class="line">   array.set(j, temp);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">  for(int i = 0; i &lt; array.size(); i ++)&#123;</span><br><span class="line">   str += array.get(i);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(&quot;str=:&quot;+str);  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>贪心算法所作的选择可以依赖于以往所作过的选择，但决不依赖于将来的选择，也不依赖于子问题的解，因此贪心算法与其他算法相比具有一定的速度优势。如果一个问题可以同时用几种方法解决，贪心算法应该是最好的选择之一。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们总是探讨求解最优的问题，却总是忽略了求解的过程，如何达到最优化的问题，才是我们应该研究的目的，综上贪心算法便给我们提供了一点思路。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>指针-C</title>
    <link href="http://yoursite.com/2018/06/01/third/"/>
    <id>http://yoursite.com/2018/06/01/third/</id>
    <published>2018-06-01T04:09:35.403Z</published>
    <updated>2018-06-01T04:29:16.884Z</updated>
    
    <content type="html"><![CDATA[<p>指针是Ｃ语言中广泛使用的一种数据类型。 运用指针编程是Ｃ语言最主要的风格之一。利用指针变量可以表示各种数据结构； 能很方便地使用数组和字符串； 并能象汇编语言一样处理内存地址，从而编出精练而高效的程序。指针极大地丰富了Ｃ语言的功能。 学习指针是学习Ｃ语言中最重要的一环， 能否正确理解和使用指针是我们是否掌握Ｃ语言的一个标志。同时， 指针也是Ｃ语言中最为困难的一部分，在学习中除了要正确理解基本概念，还必须要多编程，上机调试。只要作到这些，指针也是不难掌握的。<br><a id="more"></a></p><blockquote><p>　　指针的基本概念 在计算机中，所有的数据都是存放在存储器中的。 一般把存储器中的一个字节称为一个内存单元， 不同的数据类型所占用的内存单元数不等，如整型量占2个单元，字符量占1个单元等， 在第二章中已有详细的介绍。为了正确地访问这些内存单元， 必须为每个内存单元编上号。 根据一个内存单元的编号即可准确地找到该内存单元。内存单元的编号也叫做地址。 既然根据内存单元的编号或地址就可以找到所需的内存单元，所以通常也把这个地址称为指针。 内存单元的指针和内存单元的内容是两个不同的概念。 可以用一个通俗的例子来说明它们之间的关系。我们到银行去存取款时， 银行工作人员将根据我们的帐号去找我们的存款单， 找到之后在存单上写入存款、取款的金额。在这里，帐号就是存单的指针， 存款数是存单的内容。对于一个内存单元来说，单元的地址即为指针， 其中存放的数据才是该单元的内容。在Ｃ语言中， 允许用一个变量来存放指针，这种变量称为指针变量。因此， 一个指针变量的值就是某个内存单元的地址或称为某内存单元的指针。图中，设有字符变量C，其内容为“K”(ASCII码为十进制数 75)，C占用了011A号单元(地址用十六进数表示)。设有指针变量P，内容为011A， 这种情况我们称为P指向变量C，或说P是指向变量C的指针。 严格地说，一个指针是一个地址， 是一个常量。而一个指针变量却可以被赋予不同的指针值，是变。 但在常把指针变量简称为指针。为了避免混淆，我们中约定：“指针”是指地址， 是常量，“指针变量”是指取值为地址的变量。 定义指针的目的是为了通过指针去访问内存单元。<br>　<br>　　 既然指针变量的值是一个地址， 那么这个地址不仅可以是变量的地址， 也可以是其它数据结构的地址。在一个指针变量中存放一<br>个数组或一个函数的首地址有何意义呢？ 因为数组或函数都是连续存放的。通过访问指针变量取得了数组或函数的首地址， 也就找到了该数组或函数。这样一来， 凡是出现数组，函数的地方都可以用一个指针变量来表示， 只要该指针变量中赋予数组或函数的首地址即可。这样做， 将会使程序的概念十分清楚，程序本身也精练，高效。在Ｃ语言中， 一种数据类型或数据结构往往都占有一组连续的内存单元。 用“地址”这个概念并不能很好地描述一种数据类型或数据结构， 而“指针”虽然实际上也是一个地址，但它却是一个数据结构的首地址， 它是“指向”一个数据结构的，因而概念更为清楚，表示更为明确。 这也是引入“指针”概念的一个重要原因。</p></blockquote><h2 id="指针变量的类型说明"><a href="#指针变量的类型说明" class="headerlink" title="指针变量的类型说明"></a>指针变量的类型说明</h2><p>对指针变量的类型说明包括三个内容：<br>(1)指针类型说明，即定义变量为一个指针变量；<br>(2)指针变量名；<br>(3)变量值(指针)所指向的变量的数据类型。<br>其一般形式为： 类型说明符 ※变量名；<br>其中，※表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示本指针变量所指向的变量的数据类型。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int ※p1;/※表示p1是一个指针变量，它的值是某个整型变量的地址。 </span><br><span class="line">或者说p1指向一个整型变量。至于p1究竟指向哪一个整型变量， 应由向p1赋予的地址来决定。※/</span><br><span class="line">staic int ※p2; /※p2是指向静态整型变量的指针变量※/</span><br><span class="line">float ※p3; /※p3是指向浮点变量的指针变量※/</span><br><span class="line">char ※p4; /※p4是指向字符变量的指针变量※/</span><br></pre></td></tr></table></figure></p><p>应该注意的是，一个指针变量只能指向同类型的变量，如P3 只能指向浮点变量，不能时而指向一个浮点变量， 时而又指向一个字符变量。</p><h2 id="指针变量的赋值"><a href="#指针变量的赋值" class="headerlink" title="指针变量的赋值"></a>指针变量的赋值</h2><p>　　指针变量同普通变量一样，使用之前不仅要定义说明， 而且必须赋予具体的值。未经赋值的指针变量不能使用， 否则将造成系统混乱，甚至死机。指针变量的赋值只能赋予地址， 决不能赋予任何其它数据，否则将引起错误。在Ｃ语言中， 变量的地址是由编译系统分配的，对用户完全透明，用户不知道变量的具体地址。 Ｃ语言中提供了地址运算符&amp;来表示变量的地址。其一般形式为： &amp; 变量名； 如&amp;a变示变量a的地址，&amp;b表示变量b的地址。 变量本身必须预先说明。设有指向整型变量的指针变量p，如要把整型变量a 的地址赋予p可以有以下两种方式：</p><blockquote><p>(1)指针变量初始化的方法 int a;<br>int ※p=&a;<br>(2)赋值语句的方法 int a;<br>int ※p;<br>p=&a;<br>不允许把一个数赋予指针变量，故下面的赋值是错误的： int ※p;p=1000; 被赋值的指针变量前不能再加“※”说明符，如写为※p=&amp;a 也是错误的</p><p>指针变量的运算</p><p>指针变量可以进行某些运算，但其运算的种类是有限的。 它只能进行赋值运算和部分算术运算及关系运算。</p></blockquote><h4 id="1-指针运算符"><a href="#1-指针运算符" class="headerlink" title="1.指针运算符"></a>1.指针运算符</h4><blockquote><p>(1)取地址运算符&amp;<br>　　 取地址运算符&amp;是单目运算符，其结合性为自右至左，其功能是取变量的地址。在scanf函数及前面介绍指针变量赋值中，我们已经了解并使用了&amp;运算符。</p><p>(2)取内容运算符※<br>　　 取内容运算符※是单目运算符，其结合性为自右至左，用来表示指针变量所指的变量。在※运算符之后跟的变量必须是指针变量。需要注意的是指针运算符※和指针变量说明中的指针说明符※ 不是一回事。在指针变量说明中，“※”是类型说明符，表示其后的变量是指针类型。而表达式中出现的“※”则是一个运算符用以表示指针变量所指的变量。<br>表示指针变量p取得了整型变量a的地址。本语句表示输出变量a的值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a=5,※p=&amp;a;</span><br><span class="line">printf (&quot;%d&quot;,※p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-指针变量的运算"><a href="#2-指针变量的运算" class="headerlink" title="2.指针变量的运算"></a>2.指针变量的运算</h3><p>(1)赋值运算</p><blockquote><p>指针变量的赋值运算有以下几种形式：<br>①指针变量初始化赋值，前面已作介绍。</p><p>②把一个变量的地址赋予指向相同数据类型的指针变量。例如：<br>int a,※pa;<br>pa=&a; /※把整型变量a的地址赋予整型指针变量pa※/</p><p>③把一个指针变量的值赋予指向相同类型变量的另一个指针变量。如：<br>int a,※pa=&amp;a,※pb;<br>pb=pa; /※把a的地址赋予指针变量pb※/<br>由于pa,pb均为指向整型变量的指针变量，因此可以相互赋值。 ④把数组的首地址赋予指向数组的指针变量。<br>例如： int a[5],※pa;<br>pa=a; (数组名表示数组的首地址，故可赋予指向数组的指针变量pa)<br>也可写为：<br>pa=&amp;a[0]; /※数组第一个元素的地址也是整个数组的首地址，<br>也可赋予pa※/<br>当然也可采取初始化赋值的方法：<br>int a[5],※pa=a;</p><p>⑤把字符串的首地址赋予指向字符类型的指针变量。例如： char ※pc;pc=”c language”;或用初始化赋值的方法写为： char ※pc=”C Language”; 这里应说明的是并不是把整个字符串装入指针变量， 而是把存放该字符串的字符数组的首地址装入指针变量。 在后面还将详细介绍。</p><p>⑥把函数的入口地址赋予指向函数的指针变量。例如： int (※pf)();pf=f; /※f为函数名※/</p></blockquote><p>(2)加减算术运算　　</p><blockquote><p>对于指向数组的指针变量，可以加上或减去一个整数n。设pa是指向数组a的指针变量，则pa+n,pa-n,pa++,++pa,pa–,–pa 运算都是合法的。指针变量加或减一个整数n的意义是把指针指向的当前位置(指向某数组元素)向前或向后移动n个位置。应该注意，数组指针变量向前或向后移动一个位置和地址加1或减1 在概念上是不同的。因为数组可以有不同的类型， 各种类型的数组元素所占的字节长度是不同的。如指针变量加1，即向后移动1 个位置表示指针变量指向下一个数据元素的首地址。而不是在原地址基础上加1。<br>例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[5],※pa;</span><br><span class="line">pa=a; /※pa指向数组a，也是指向a[0]※/</span><br><span class="line">pa=pa+2; /※pa指向a[2]，即pa的值为&amp;pa[2]※/</span><br></pre></td></tr></table></figure><blockquote><p>指针变量的加减运算只能对数组指针变量进行， 对指向其它类型变量的指针变量作加减运算是毫无意义的。两个指针变量之间的运算只有指向同一数组的两个指针变量之间才能进行运算， 否则运算毫无意义。</p><p>①两指针变量相减<br>两指针变量相减所得之差是两个指针所指数组元素之间相差的元素个数。实际上是两个指针值(地址) 相减之差再除以该数组元素的长度(字节数)。例如pf1和pf2 是指向同一浮点数组的两个指针变量，设pf1的值为2010H，pf2的值为2000H，而浮点数组每个元素占4个字节，所以pf1-pf2的结果为(2000H-2010H)/4=4，表示pf1和 pf2之间相差4个元素。两个指针变量不能进行加法运算。 例如， pf1+pf2是什么意思呢?毫无实际意义。</p></blockquote><blockquote><p>②两指针变量进行关系运算<br>指向同一数组的两指针变量进行关系运算可表示它们所指数组元素之间的关系。例如：<br>pf1==pf2表示pf1和pf2指向同一数组元素<br>pf1&gt;pf2表示pf1处于高地址位置<br>pf1&lt;pf2表示pf2处于低地址位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a=10,b=20,s,t,※pa,※pb;</span><br><span class="line">pa=&amp;a;</span><br><span class="line">pb=&amp;b;</span><br><span class="line">s=※pa+※pb;</span><br><span class="line">t=※pa※※pb;</span><br><span class="line">printf(&quot;a=%d/nb=%d/na+b=%d/na※b=%d/n&quot;,a,b,a+b,a※b);</span><br><span class="line">printf(&quot;s=%d/nt=%d/n&quot;,s,t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>……<br>说明pa,pb为整型指针变量<br>给指针变量pa赋值，pa指向变量a。<br>给指针变量pb赋值，pb指向变量b。<br>本行的意义是求a+b之和，(※pa就是a，※pb就是b)。<br>本行是求a※b之积。<br>输出结果。<br>输出结果。<br>……</p><blockquote><p>指针变量还可以与0比较。设p为指针变量，则p==0表明p是空指针，它不指向任何变量；p!=0表示p不是空指针。空指针是由对指针变量赋予0值而得到的。例如： #define NULL 0　int ※p=NULL; 对指针变量赋0值和不赋值是不同的。指针变量未赋值时，可以是任意值，是不能使用的。否则将造成意外错误。而指针变量赋0值后，则可以使用，只是它不指向具体的变量而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a,b,c,※pmax,※pmin;</span><br><span class="line">printf(&quot;input three numbers:/n&quot;);</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">if(a&gt;b)&#123;</span><br><span class="line">pmax=&amp;a;</span><br><span class="line">pmin=&amp;b;&#125;</span><br><span class="line">else&#123;</span><br><span class="line">pmax=&amp;b;</span><br><span class="line">pmin=&amp;a;&#125;</span><br><span class="line">if(c&gt;※pmax) pmax=&amp;c;</span><br><span class="line">if(c&lt;※pmin) pmin=&amp;c;</span><br><span class="line">printf(&quot;max=%d/nmin=%d/n&quot;,※pmax,※pmin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>……<br>pmax,pmin为整型指针变量。<br>输入提示。<br>输入三个数字。<br>如果第一个数字大于第二个数字．．．<br>指针变量赋值<br>指针变量赋值</p><p>指针变量赋值<br>指针变量赋值<br>判断并赋值<br>判断并赋值<br>输出结果<br>……</p><h5 id="数组指针变量的说明和使用"><a href="#数组指针变量的说明和使用" class="headerlink" title="数组指针变量的说明和使用"></a>数组指针变量的说明和使用</h5><blockquote><p>　　指向数组的指针变量称为数组指针变量。 在讨论数组指针变量的说明和使用之前，我们先明确几个关系。<br>一个数组是由连续的一块内存单元组成的。 数组名就是这块连续内存单元的首地址。一个数组也是由各个数组元素(下标变量) 组成的。每个数组元素按其类型不同占有几个连续的内存单元。 一个数组元素的首地址也是指它所占有的几个内存单元的首地址。 一个指针变量既可以指向一个数组，也可以指向一个数组元素， 可把数组名或第一个元素的地址赋予它。如要使指针变量指向第i号元素可以把i元素的首地址赋予它或把数组名加i赋予它。</p><p>　　设有实数组a，指向a的指针变量为pa，从图6.3中我们可以看出有以下关系：<br>pa,a,&amp;a[0]均指向同一单元，它们是数组a的首地址，也是0 号元素a[0]的首地址。pa+1,a+1,&amp;a[1]均指向1号元素a[1]。类推可知a+i,a+i,&amp;a[i]<br>指向i号元素a[i]。应该说明的是pa是变量，而a,&amp;a[i]都是常量。在编程时应予以注意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a[5],i;</span><br><span class="line">for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">a[i]=i;</span><br><span class="line">printf(&quot;a[%d]=%d/n&quot;,i,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;/n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>…….<br>主函数<br>定义一个整型数组和一个整型变量<br>循环语句<br>给数组赋值<br>打印每一个数组的值<br>……<br>输出换行<br>……<br>※※数组指针变量说明的一般形式为：<br>类型说明符 ※ 指针变量名<br>　　 其中类型说明符表示所指数组的类型。 从一般形式可以看出指向数组的指针变量和指向普通变量的指针变量的说明是相同的。<br>引入指针变量后，就可以用两种方法来访问数组元素了。<br>　　 第一种方法为下标法，即用a[i]形式访问数组元素。 在第四章中介绍数组时都是采用这种方法。<br>　　 第二种方法为指针法，即采用※(pa+i)形式，用间接访问的方法来访问数组元素。※※<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a[5],i,※pa;</span><br><span class="line">pa=a;</span><br><span class="line">for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">※pa=i;</span><br><span class="line">pa++;</span><br><span class="line">&#125;</span><br><span class="line">pa=a;</span><br><span class="line">for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">printf(&quot;a[%d]=%d/n&quot;,i,※pa);</span><br><span class="line">pa++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>……<br>主函数<br>定义整型数组和指针<br>将指针pa指向数组a<br>循环<br>将变量i的值赋给由指针pa指向的a[]的数组单元<br>将指针pa指向a[]的下一个单元<br>……<br>指针pa重新取得数组a的首地址<br>循环<br>用数组方式输出数组a中的所有元素<br>将指针pa指向a[]的下一个单元<br>……<br>……<br>下面，另举一例，该例与上例本意相同，但是实现方式不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a[5],i,※pa=a;</span><br><span class="line">for(i=0;i&lt;5;)&#123;</span><br><span class="line">※pa=i;</span><br><span class="line">printf(&quot;a[%d]=%d/n&quot;,i++,※pa++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主函数<br>定义整型数组和指针，并使指针指向数组a<br>循环<br>将变量i的值赋给由指针pa指向的a[]的数组单元<br>用指针输出数组a中的所有元素，同时指针pa指向a[]的下一个单元<br>……<br>……</p><h5 id="数组名和数组指针变量作函数参数"><a href="#数组名和数组指针变量作函数参数" class="headerlink" title="数组名和数组指针变量作函数参数"></a>数组名和数组指针变量作函数参数</h5><blockquote><p>在第五章中曾经介绍过用数组名作函数的实参和形参的问题。在学习指针变量之后就更容易理解这个问题了。 数组名就是数组的首地址，实参向形参传送数组名实际上就是传送数组的地址， 形参得到该地址后也指向同一数组。 这就好象同一件物品有两个彼此不同的名称一样。同样，指针变量的值也是地址， 数组指针变量的值即为数组的首地址，当然也可作为函数的参数使用。※※</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">float aver(float ※pa);</span><br><span class="line">main()&#123;</span><br><span class="line">float sco[5],av,※sp;</span><br><span class="line">int i;</span><br><span class="line">sp=sco;</span><br><span class="line">printf(&quot;/ninput 5 scores:/n&quot;);</span><br><span class="line">for(i=0;i&lt;5;i++) scanf(&quot;%f&quot;,&amp;sco[i]);</span><br><span class="line">av=aver(sp);</span><br><span class="line">printf(&quot;average score is %5.2f&quot;,av);</span><br><span class="line">&#125;</span><br><span class="line">float aver(float ※pa)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">float av,s=0;</span><br><span class="line">for(i=0;i&lt;5;i++) s=s+※pa++;</span><br><span class="line">av=s/5;</span><br><span class="line">return av;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指向多维数组的指针变量"><a href="#指向多维数组的指针变量" class="headerlink" title="指向多维数组的指针变量"></a>指向多维数组的指针变量</h1><p>本小节以二维数组为例介绍多维数组的指针变量。</p><h2 id="一、多维数组地址的表示方法"><a href="#一、多维数组地址的表示方法" class="headerlink" title="一、多维数组地址的表示方法"></a>一、多维数组地址的表示方法</h2><p>设有整型二维数组a[3][4]如下：<br>0 1 2 3<br>4 5 6 7<br>8 9 10 11</p><blockquote><p>   设数组a的首地址为1000，各下标变量的首地址及其值如图所示。在第四章中介绍过， Ｃ语言允许把一个二维数组分解为多个一维数组来处理。因此数组a可分解为三个一维数组，即a[0]，a[1]，a[2]。每一个一维数组又含有四个元素。例如a[0]数组，含有a[0][0]，a[0][1]，a[0][2]，a[0][3]四个元素。 数组及数组元素的地址表示如下：a是二维数组名，也是二维数组0行的首地址，等于1000。a[0]是第一个一维数组的数组名和首地址，因此也为1000。※(a+0)或※a是与a[0]等效的， 它表示一维数组a[0]0 号元素的首地址。 也为1000。&amp;a[0][0]是二维数组a的0行0列元素首地址，同样是1000。因此，a，a[0]，※(a+0)，※a?amp;a[0][0]是相等的。同理，a+1是二维数组1行的首地址，等于1008。a[1]是第二个一维数组的数组名和首地址，因此也为1008。 &amp;a[1][0]是二维数组a的1行0列元素地址，也是1008。因此a+1,a[1],※(a+1),&amp;a[1][0]是等同的。 由此可得出：a+i，a[i]，※(a+i)，&amp;a[i][0]是等同的。 此外，&amp;a[i]和a[i]也是等同的。因为在二维数组中不能把&amp;a[i]理解为元素a[i]的地址，不存在元素a[i]。</p><p>   Ｃ语言规定，它是一种地址计算方法，表示数组a第i行首地址。由此，我们得出：a[i]，&amp;a[i]，※(a+i)和a+i也都是等同的。另外，a[0]也<br>可以看成是a[0]+0是一维数组a[0]的0号元素的首地址， 而a[0]+1则是a[0]的1号元素首地址，由此可得出a[i]+j则是一维数组a[i]的j号元素首地址，它等于&amp;a[i][j]。由a[i]=※(a+i)得a[i]+j=※(a+i)+j，由于※(a+i)+j是二维数组a的i行j列元素的首地址。该元素的值等于※(※(a+i)+j)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Explain]</span><br><span class="line"> #define PF &quot;%d,%d,%d,%d,%d,/n&quot;</span><br><span class="line"> main()&#123;</span><br><span class="line"> static int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;</span><br><span class="line"> printf(PF,a,※a,a[0],&amp;a[0],&amp;a[0][0]);</span><br><span class="line"> printf(PF,a+1,※(a+1),a[1],&amp;a[1],&amp;a[1][0]);</span><br><span class="line"> printf(PF,a+2,※(a+2),a[2],&amp;a[2],&amp;a[2][0]);</span><br><span class="line"> printf(&quot;%d,%d/n&quot;,a[1]+1,※(a+1)+1);</span><br><span class="line"> printf(&quot;%d,%d/n&quot;,※(a[1]+1),※(※(a+1)+1));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="二、多维数组的指针变量"><a href="#二、多维数组的指针变量" class="headerlink" title="二、多维数组的指针变量"></a>二、多维数组的指针变量</h2><blockquote><p>　　把二维数组a 分解为一维数组a[0],a[1],a[2]之后，设p为指向二维数组的指针变量。可定义为： int (※p)[4] 它表示p是一个指针变量，它指向二维数组a 或指向第一个一维数组a[0]，其值等于a,a[0]，或&amp;a[0][0]等。而p+i则指向一维数组a[i]。从前面的分析可得出※(p+i)+j是二维数组i行j 列的元素的地址，而※(※(p+i)+j)则是i行j列元素的值。</p><p>　　二维数组指针变量说明的一般形式为： 类型说明符 (※指针变量名)[长度] 其中“类型说明符”为所指数组的数据类型。“※”表示其后的变量是指针类型。 “长度”表示二维数组分解为多个一维数组时， 一维数组的长度，也就是二维数组的列数。应注意“(※指针变量名)”两边的括号不可少，如缺少括号则表示是指针数组(本章后面介绍)，意义就完全不同了。<br>[Explain]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">static int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;</span><br><span class="line">int(※p)[4];</span><br><span class="line">int i,j;</span><br><span class="line">p=a;</span><br><span class="line">for(i=0;i&lt;3;i++)</span><br><span class="line">for(j=0;j&lt;4;j++) printf(&quot;%2d &quot;,※(※(p+i)+j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>‘Expain字符串指针变量的说明和使用字符串指针变量的定义说明与指向字符变量的指针变量说明是相同的。只能按对指针变量的赋值不同来区别。 对指向字符变量的指针变量应赋予该字符变量的地址。如： char c,※p=&c;表示p是一个指向字符变量c的指针变量。而： char ※s=”C Language”;则表示s是一个指向字符串的指针变量。把字符串的首地址赋予s。<br>请看下面一例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">char ※ps;</span><br><span class="line">ps=&quot;C Language&quot;;</span><br><span class="line">printf(&quot;%s&quot;,ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果为：<br>C Language</p><p>  上例中，首先定义ps是一个字符指针变量， 然后把字符串的首地址赋予ps(应写出整个字符串，以便编译系统把该串装入连续的一块内存单元)，并把首地址送入ps。程序中的： char ※ps;ps=”C Language”;等效于： char ※ps=”C Language”;输出字符串中n个字符后的所有字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">char ※ps=&quot;this is a book&quot;;</span><br><span class="line">int n=10;</span><br><span class="line">ps=ps+n;</span><br><span class="line">printf(&quot;%s/n&quot;,ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br>book 在程序中对ps初始化时，即把字符串首地址赋予ps，当ps= ps+10之后，ps指向字符“b”，因此输出为”book”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">char st[20],※ps;</span><br><span class="line">int i;</span><br><span class="line">printf(&quot;input a string:/n&quot;);</span><br><span class="line">ps=st;</span><br><span class="line">scanf(&quot;%s&quot;,ps);</span><br><span class="line">for(i=0;ps[i]!=&apos;/0&apos;;i++)</span><br><span class="line">if(ps[i]==&apos;k&apos;)&#123;</span><br><span class="line">printf(&quot;there is a &apos;k&apos; in the string/n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(ps[i]==&apos;/0&apos;) printf(&quot;There is no &apos;k&apos; in the string/n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本例是在输入的字符串中查找有无‘k’字符。 下面这个例子是将指针变量指向一个格式字符串，用在printf函数中，用于输出二维数组的各种地址表示的值。但在printf语句中用指针变量PF代替了格式串。 这也是程序中常用的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">static int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;</span><br><span class="line">char ※PF;</span><br><span class="line">PF=&quot;%d,%d,%d,%d,%d/n&quot;;</span><br><span class="line">printf(PF,a,※a,a[0],&amp;a[0],&amp;a[0][0]);</span><br><span class="line">printf(PF,a+1,※(a+1),a[1],&amp;a[1],&amp;a[1][0]);</span><br><span class="line">printf(PF,a+2,※(a+2),a[2],&amp;a[2],&amp;a[2][0]);</span><br><span class="line">printf(&quot;%d,%d/n&quot;,a[1]+1,※(a+1)+1);</span><br><span class="line">printf(&quot;%d,%d/n&quot;,※(a[1]+1),※(※(a+1)+1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　 在下例是讲解，把字符串指针作为函数参数的使用。要求把一个字符串的内容复制到另一个字符串中，并且不能使用strcpy函数。函数cprstr的形参为两个字符指针变量。pss指向源字符串，pds指向目标字符串。表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(※pds=※pss)!=`/0&apos;</span><br><span class="line">cpystr(char ※pss,char ※pds)&#123;</span><br><span class="line">while((※pds=※pss)!=&apos;/0&apos;)&#123;</span><br><span class="line">pds++;</span><br><span class="line">pss++; &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">char ※pa=&quot;CHINA&quot;,b[10],※pb;</span><br><span class="line">pb=b;</span><br><span class="line">cpystr(pa,pb);</span><br><span class="line">printf(&quot;string a=%s/nstring b=%s/n&quot;,pa,pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　 </p><blockquote><p>在上例中，程序完成了两项工作：一是把pss指向的源字符复制到pds所指向的目标字符中，二是判断所复制的字符是否为`/0’，若是则表明源字符串结束，不再循环。否则，pds和pss都加1，指向下一字符。在主函数中，以指针变量pa,pb为实参，分别取得确定值后调用cprstr函数。由于采用的指针变量pa和pss,pb和pds均指向同一字符串，因此在主函数和cprstr函数中均可使用这些字符串。也可以把cprstr函数简化为以下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cprstr(char ※pss,char※pds)</span><br><span class="line">&#123;while ((※pds++=※pss++)!=`/0&apos;);&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>　　 </p><blockquote><p>即把指针的移动和赋值合并在一个语句中。 进一步分析还可发现<code>/0&#39;的ASCⅡ码为0，对于while语句只看表达式的值为非0就循环，为0则结束循环，因此也可省去“!=</code>/0’”这一判断部分，而写为以下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cprstr (char ※pss,char ※pds)</span><br><span class="line">&#123;while (※pdss++=※pss++);&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>表达式的意义可解释为，源字符向目标字符赋值， 移动指针，若所赋值为非0则循环，否则结束循环。这样使程序更加简洁。简化后的程序如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cpystr(char ※pss,char ※pds)&#123;</span><br><span class="line">while(※pds++=※pss++);</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">char ※pa=&quot;CHINA&quot;,b[10],※pb;</span><br><span class="line">pb=b;</span><br><span class="line">cpystr(pa,pb);</span><br><span class="line">printf(&quot;string a=%s/nstring b=%s/n&quot;,pa,pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用字符串指针变量与字符数组的区别"><a href="#使用字符串指针变量与字符数组的区别" class="headerlink" title="使用字符串指针变量与字符数组的区别"></a>使用字符串指针变量与字符数组的区别</h2><p>用字符数组和字符指针变量都可实现字符串的存储和运算。 但是两者是有区别的。在使用时应注意以下几个问题：</p><blockquote><ol><li><p>字符串指针变量本身是一个变量，用于存放字符串的首地址。而字符串本身是存放在以该首地址为首的一块连续的内存空间中并以‘/0’作为串的结束。字符数组是由于若干个数组元素组成的，它可用来存放整个字符串。</p></li><li><p>对字符数组作初始化赋值，必须采用外部类型或静态类型，如： static char st[]={“C Language”};而对字符串指针变量则无此限制，如： char ※ps=”C Language”;</p></li><li><p>对字符串指针方式 char ※ps=”C Language”;可以写为： char ※ps;　ps=”C Language”;而对数组方式：<br>static char st[]={“C Language”};<br>不能写为：<br>char st[20];st={“C Language”};<br>而只能对字符数组的各元素逐个赋值。</p></li></ol></blockquote><p>　　从以上几点可以看出字符串指针变量与字符数组在使用时的区别，同时也可看出使用指针变量更加方便。前面说过，当一个指针变量在未取得确定地址前使用是危险的，容易引起错误。但是对指针变量直接赋值是可以的。因为C系统对指针变量赋值时要给以确定的地址。因此，<br>char ※ps=”C Langage”;<br>或者 char ※ps;<br>ps=”C Language”;都是合法的。</p><h2 id="函数指针变量"><a href="#函数指针变量" class="headerlink" title="函数指针变量"></a>函数指针变量</h2><blockquote><p>　　在Ｃ语言中规定，一个函数总是占用一段连续的内存区， 而函数名就是该函数所占内存区的首地址。 我们可以把函数的这个首地址(或称入口地址)赋予一个指针变量， 使该指针变量指向该函数。然后通过指针变量就可以找到并调用这个函数。 我们把这种指向函数的指针变量称为“函数指针变量”。<br>函数指针变量定义的一般形式为：<br>类型说明符 (※指针变量名)();<br>其中“类型说明符”表示被指函数的返回值的类型。“(※ 指针变量名)”表示“※”后面的变量是定义的指针变量。 最后的空括号表示指针变量所指的是一个函数。<br>例如： int (※pf)();<br>表示pf是一个指向函数入口的指针变量，该函数的返回值(函数值)是整型。<br>下面通过例子来说明用指针形式实现对函数调用的方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int max(int a,int b)&#123;</span><br><span class="line">if(a&gt;b)return a;</span><br><span class="line">else return b;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">int max(int a,int b);</span><br><span class="line">int(※pmax)();</span><br><span class="line">int x,y,z;</span><br><span class="line">pmax=max;</span><br><span class="line">printf(&quot;input two numbers:/n&quot;);</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">z=(※pmax)(x,y);</span><br><span class="line">printf(&quot;maxmum=%d&quot;,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述程序可以看出用，函数指针变量形式调用函数的步骤如下：</p><blockquote><ol><li><p>先定义函数指针变量，如后一程序中第9行 int (※pmax)();定义pmax为函数指针变量。</p></li><li><p>把被调函数的入口地址(函数名)赋予该函数指针变量，如程序中第11行 pmax=max;</p></li><li><p>用函数指针变量形式调用函数，如程序第14行 z=(※pmax)(x,y);　调用函数的一般形式为： (※指针变量名) (实参表)使用函数指针变量还应注意以下两点：</p><p> a. 函数指针变量不能进行算术运算，这是与数组指针变量不同的。数组指针变量加减一个整数可使指针移动指向后面或前面的数组元素，而函数指针的移动是毫无意义的。</p><p> b. 函数调用中”(※指针变量名)”的两边的括号不可少，其中的※不应该理解为求值运算，在此处它只是一种表示符号。</p></li></ol></blockquote><h2 id="指针型函数"><a href="#指针型函数" class="headerlink" title="指针型函数"></a>指针型函数</h2><p>前面我们介绍过，所谓函数类型是指函数返回值的类型。 在Ｃ语言中允许一个函数的返回值是一个指针(即地址)， 这种返回指针值的函数称为指针型函数。<br>定义指针型函数的一般形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 ※函数名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">…… /※函数体※/</span><br><span class="line">&#125;</span><br><span class="line">其中函数名之前加了“※”号表明这是一个指针型函数，即返回值是一个指针。类型说明符表示了返回的指针值所指向的数据类型。</span><br><span class="line">如：</span><br><span class="line">int ※ap(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">...... /※函数体※/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>　　 表示ap是一个返回指针值的指针型函数， 它返回的指针指向一个整型变量。下例中定义了一个指针型函数 day_name，它的返回值指向一个字符串。该函数中定义了一个静态指针数组name。name 数组初始化赋值为八个字符串，分别表示各个星期名及出错提示。形参n表示与星期名所对应的整数。在主函数中， 把输入的整数i作为实参， 在printf语句中调用day_name函数并把i值传送给形参 n。day_name函数中的return语句包含一个条件表达式， n 值若大于7或小于1则把name[0] 指针返回主函数输出出错提示字符串“Illegal day”。否则返回主函数输出对应的星期名。主函数中的第7行是个条件语句，其语义是，如输入为负数(i&lt;0)则中止程序运行退出程序。exit是一个库函数，exit(1)表示发生错误后退出程序， exit(0)表示正常退出。</p><p>　　应该特别注意的是函数指针变量和指针型函数这两者在写法和意义上的区别。如int(※p)()和int ※p()是两个完全不同的量。int(※p)()是一个变量说明，说明p 是一个指向函数入口的指针变量，该函数的返回值是整型量，(※p)的两边的括号不能少。int ※p() 则不是变量说明而是函数说明，说明p是一个指针型函数，其返回值是一个指向整型量的指针，※p两边没有括号。作为函数说明， 在括号内最好写入形式参数，这样便于与变量说明区别。 对于指针型函数定义，int ※p()只是函数头部分，一般还应该有函数体部分。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int i;</span><br><span class="line">char ※day_name(int n);</span><br><span class="line">printf(&quot;input Day No:/n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;i);</span><br><span class="line">if(i&lt;0) exit(1);</span><br><span class="line">printf(&quot;Day No:%2d--&gt;%s/n&quot;,i,day_name(i));</span><br><span class="line">&#125;</span><br><span class="line">char ※day_name(int n)&#123;</span><br><span class="line">static char ※name[]=&#123; &quot;Illegal day&quot;,</span><br><span class="line">&quot;Monday&quot;,</span><br><span class="line">&quot;Tuesday&quot;,</span><br><span class="line">&quot;Wednesday&quot;,</span><br><span class="line">&quot;Thursday&quot;,</span><br><span class="line">&quot;Friday&quot;,</span><br><span class="line">&quot;Saturday&quot;,</span><br><span class="line">&quot;Sunday&quot;&#125;;</span><br><span class="line">return((n&lt;1||n&gt;7) ? name[0] : name[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 本程序是通过指针函数，输入一个1～7之间的整数， 输出对应的星期名。指针数组的说明与使用一个数组的元素值为指针则是指针数组。 指针数组是一组有序的指针的集合。 指针数组的所有元素都必须是具有相同存储类型和指向相同数据类型的指针变量。<br>　　 指针数组说明的一般形式为： 类型说明符※数组名[数组长度]<br>　　 其中类型说明符为指针值所指向的变量的类型。例如： int ※pa[3] 表示pa是一个指针数组，它有三个数组元素， 每个元素值都是一个指针，指向整型变量。通常可用一个指针数组来指向一个二维数组。 指针数组中的每个元素被赋予二维数组每一行的首地址， 因此也可理解为指向一个一维数组。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int a[3][3]=&#123;1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">int ※pa[3]=&#123;a[0],a[1],a[2]&#125;;</span><br><span class="line">int ※p=a[0];</span><br><span class="line">main()&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;3;i++)</span><br><span class="line">printf(&quot;%d,%d,%d/n&quot;,a[i][2-i],※a[i],※(※(a+i)+i));</span><br><span class="line">for(i=0;i&lt;3;i++)</span><br><span class="line">printf(&quot;%d,%d,%d/n&quot;,※pa[i],p[i],※(p+i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>　　 本例程序中，pa是一个指针数组，三个元素分别指向二维数组a的各行。然后用循环语句输出指定的数组元素。其中※a[i]表示i行0列元素值；※(※(a+i)+i)表示i行i列的元素值；※pa[i]表示i行0列元素值；由于p与a[0]相同，故p[i]表示0行i列的值；※(p+i)表示0行i列的值。读者可仔细领会元素值的各种不同的表示方法。 应该注意指针数组和二维数组指针变量的区别。 这两者虽然都可用来表示二维数组，但是其表示方法和意义是不同的。</p><p>　　二维数组指针变量是单个的变量，其一般形式中”(※指针变量名)”两边的括号不可少。而指针数组类型表示的是多个指针( 一组有序指针)在一般形式中”※指针数组名”两边不能有括号。例如： int (※p)[3];表示一个指向二维数组的指针变量。该二维数组的列数为3或分解为一维数组的长度为3。 int ※p[3] 表示p是一个指针数组，有三个下标变量p[0]，p[1]，p[2]均为指针变量。</p><p>　　指针数组也常用来表示一组字符串， 这时指针数组的每个元素被赋予一个字符串的首地址。 指向字符串的指针数组的初始化更为简单。例如在例6.20中即采用指针数组来表示一组字符串。 其初始化赋值为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char ※name[]=&#123;&quot;Illagal day&quot;,</span><br><span class="line">&quot;Monday&quot;,</span><br><span class="line">&quot;Tuesday&quot;,</span><br><span class="line">&quot;Wednesday&quot;,</span><br><span class="line">&quot;Thursday&quot;,</span><br><span class="line">&quot;Friday&quot;,</span><br><span class="line">&quot;Saturday&quot;,</span><br><span class="line">&quot;Sunday&quot;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>　　 完成这个初始化赋值之后，name[0]即指向字符串”Illegal day”，name[1]指?quot;Monday”……。</p><p>　　指针数组也可以用作函数参数。在本例主函数中，定义了一个指针数组name，并对name 作了初始化赋值。其每个元素都指向一个字符串。然后又以name 作为实参调用指针型函数day name，在调用时把数组名 name 赋予形参变量name，输入的整数i作为第二个实参赋予形参n。在day name函数中定义了两个指针变量pp1和pp2，pp1被赋予name[0]的值(即※name)，pp2被赋予name[n]的值即※(name+ n)。由条件表达式决定返回pp1或pp2指针给主函数中的指针变量ps。最后输出i和ps的值。</p></blockquote><h2 id="指针数组作指针型函数的参数"><a href="#指针数组作指针型函数的参数" class="headerlink" title="指针数组作指针型函数的参数"></a>指针数组作指针型函数的参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">static char ※name[]=&#123; &quot;Illegal day&quot;,</span><br><span class="line">&quot;Monday&quot;,</span><br><span class="line">&quot;Tuesday&quot;,</span><br><span class="line">&quot;Wednesday&quot;,</span><br><span class="line">&quot;Thursday&quot;,</span><br><span class="line">&quot;Friday&quot;,</span><br><span class="line">&quot;Saturday&quot;,</span><br><span class="line">&quot;Sunday&quot;&#125;;</span><br><span class="line">char ※ps;</span><br><span class="line">int i;</span><br><span class="line">char ※day name(char ※name[],int n);</span><br><span class="line">printf(&quot;input Day No:/n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;i);</span><br><span class="line">if(i&lt;0) exit(1);</span><br><span class="line">ps=day name(name,i);</span><br><span class="line">printf(&quot;Day No:%2d--&gt;%s/n&quot;,i,ps);</span><br><span class="line">&#125;</span><br><span class="line">char ※day name(char ※name[],int n)</span><br><span class="line">&#123;</span><br><span class="line">char ※pp1,※pp2;</span><br><span class="line">pp1=※name;</span><br><span class="line">pp2=※(name+n);</span><br><span class="line">return((n&lt;1||n&gt;7)? pp1:pp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下例要求输入5个国名并按字母顺序排列后输出。在以前的例子中采用了普通的排序方法， 逐个比较之后交换字符串的位置。交换字符串的物理位置是通过字符串复制函数完成的。 反复的交换将使程序执行的速度很慢，同时由于各字符串(国名) 的长度不同，又增加了存储管理的负担。 用指针数组能很好地解决这些问题。把所有的字符串存放在一个数组中， 把这些字符数组的首地址放在一个指针数组中，当需要交换两个字符串时， 只须交换指针数组相应两元素的内容(地址)即可，而不必交换字符串本身。程序中定义了两个函数，一个名为sort完成排序， 其形参为指<br>针数组name，即为待排序的各字符串数组的指针。形参n为字符串的个数。另一个函数名为print，用于排序后字符串的输出，其形参与sort的形参相同。主函数main中，定义了指针数组name 并作了初始化赋值。然后分别调用sort函数和print函数完成排序和输出。值得说明的是在sort函数中，对两个字符串比较，采用了strcmp 函数，strcmp函数允许参与比较的串以指针方式出现。name[k]和name[ j]均为指针，因此是合法的。字符串比较后需要交换时， 只交换指针数组元素的值，而不交换具体的字符串， 这样将大大减少时间的开销，提高了运行效率。</p><p>现编程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">void sort(char ※name[],int n);</span><br><span class="line">void print(char ※name[],int n);</span><br><span class="line">static char ※name[]=&#123; &quot;CHINA&quot;,&quot;AMERICA&quot;,&quot;AUSTRALIA&quot;,</span><br><span class="line">&quot;FRANCE&quot;,&quot;GERMAN&quot;&#125;;</span><br><span class="line">int n=5;</span><br><span class="line">sort(name,n);</span><br><span class="line">print(name,n);</span><br><span class="line">&#125;</span><br><span class="line">void sort(char ※name[],int n)&#123;</span><br><span class="line">char ※pt;</span><br><span class="line">int i,j,k;</span><br><span class="line">for(i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">k=i;</span><br><span class="line">for(j=i+1;j&lt;n;j++)</span><br><span class="line">if(strcmp(name[k],name[j])&gt;0) k=j;</span><br><span class="line">if(k!=i)&#123;</span><br><span class="line">pt=name[i];</span><br><span class="line">name[i]=name[k];</span><br><span class="line">name[k]=pt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void print(char ※name[],int n)&#123;</span><br><span class="line">int i;</span><br><span class="line">for (i=0;i&lt;n;i++) printf(&quot;%s/n&quot;,name[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main函数的参数"><a href="#main函数的参数" class="headerlink" title="ｍａｉｎ函数的参数"></a>ｍａｉｎ函数的参数</h2><blockquote><p>　　前面介绍的main函数都是不带参数的。因此main 后的括号都是空括号。实际上，main函数可以带参数，这个参数可以认为是 main函数的形式参数。Ｃ语言规定main函数的参数只能有两个， 习惯上这两个参数写为argc和argv。因此，main函数的函数头可写为： main (argc,argv)Ｃ语言还规定argc(第一个形参)必须是整型变量,argv( 第二个形参)必须是指向字符串的指针数组。</p></blockquote><p>加上形参说明后，main函数的函数头应写为：<br><figure class="highlight plain"><figcaption><span>(argc,argv)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int argv;</span><br><span class="line">char ※argv[];或写成：</span><br><span class="line">main (int argc,char ※argv[])</span><br></pre></td></tr></table></figure></p><blockquote><p> 由于main函数不能被其它函数调用， 因此不可能在程序内部取得实际值。那么，在何处把实参值赋予main函数的形参呢? 实际上,main函数的参数值是从操作系统命令行上获得的。当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数即可把这些实参传送到main的形参中去。</p><p>　　DOS提示符下命令行的一般形式为： C:/&gt;可执行文件名 参数 参数……; 但是应该特别注意的是，main 的两个形参和命令行中的参数在<br>位置上不是一一对应的。因为,main的形参只有二个，而命令行中的参数个数原则上未加限制。argc参数表示了命令行中参数的个数(注意：文件名本身也算一个参数)，argc的值是在输入命令行时由系统按实际参数的个数自动赋予的。例如有命令行为： C:/&gt;E6 24 BASIC dbase FORTRAN由于文件名E6 24本身也算一个参数，所以共有4个参数，因此argc取得的值为4。argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处理)的首地址。 指针数组的长度即为参数个数。数组元素初值由系统自动赋予。其表示如图6.8所示：<br><figure class="highlight plain"><figcaption><span>argc,char ※argv)&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(argc--&gt;1)</span><br><span class="line">printf(&quot;%s/n&quot;,※++argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>本例是显示命令行中输入的参数如果上例的可执行文件名为e24.exe，存放在A驱动器的盘内。<br>因此输入的命令行为： C:/&gt;a:e24 BASIC dBASE FORTRAN</p></blockquote><p>则运行结果为：<br>BASIC<br>dBASE<br>FORTRAN</p><blockquote><p>　　 该行共有4个参数，执行main时，argc的初值即为4。argv的4个元素分为4个字符串的首地址。执行while语句，每循环一次 argv值减1，当argv等于1时停止循环，共循环三次， 因此共可输出三个参数。在printf函数中，由于打印项※++argv是先加1再打印， 故第一次打印的是argv[1]所指的字符串BASIC。第二、 三次循环分别打印后二个字符串。而参数e24是文件名，不必输出。</p><p>　　下例的命令行中有两个参数，第二个参数20即为输入的n值。在程序中※++argv的值为字符串“20”，然后用函数”atoi”把它换为整型作为while语句中的循环控制变量，输出20个偶数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main(int argc,char※argv[])&#123;</span><br><span class="line">int a=0,n;</span><br><span class="line">n=atoi(※++argv);</span><br><span class="line">while(n--) printf(&quot;%d &quot;,a++※2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>本程序是从0开始输出n个偶数。指向指针的指针变量如果一个指针变量存放的又是另一个指针变量的地址， 则称这个指针变量为指向指针的指针变量。</p><p>在前面已经介绍过，通过指针访问变量称为间接访问， 简称间访。由于指针变量直接指向变量，所以称为单级间访。 而如果通过指向指针的指针变量来访问变量则构成了二级或多级间访。在Ｃ语言程序中，对间访的级数并未明确限制， 但是间访级数太多时不容易理解解，也容易出错，因此，一般很少超过二级间访。 指向指针的指针变量说明的一般形式为：</p></blockquote><p>类型说明符※※ 指针变量名；<br>例如： int ※※ pp; 表示pp是一个指针变量，它指向另一个指针变量， 而这个指针变量指向一个整型量。下面举一个例子来说明这种关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x,※p,※※pp;</span><br><span class="line">x=10;</span><br><span class="line">p=&amp;x;</span><br><span class="line">pp=&amp;p;</span><br><span class="line">printf(&quot;x=%d/n&quot;,※※pp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>　　 上例程序中p 是一个指针变量，指向整型量x；pp也是一个指针变量， 它指向指针变量p。通过pp变量访问x的写法是※※pp。程序最后输出x的值为10。通过上例，读者可以学习指向指针的指针变量的说明和使用方法。</p><p>　　下述程序中首先定义说明了指针数组ps并作了初始化赋值。 又说明了pps是一个指向指针的指针变量。在5次循环中， pps 分别取得了ps[0]，ps[1]，ps[2]，ps[3]，ps[4]的地址值(如图6.10所示)。再通过这些地址即可找到该字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static char ※ps[]=&#123; &quot;BASIC&quot;,&quot;DBASE&quot;,&quot;C&quot;,&quot;FORTRAN&quot;,</span><br><span class="line">&quot;PASCAL&quot;&#125;;</span><br><span class="line">char ※※pps;</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">pps=ps+i;</span><br><span class="line">printf(&quot;%s/n&quot;,※pps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>本程序是用指向指针的指针变量编程，输出多个字符串。</p><h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><blockquote><ol><li><p>指针是Ｃ语言中一个重要的组成部分，使用指针编程有以下优点：<br>(1)提高程序的编译效率和执行速度。<br>(2)通过指针可使用主调函数和被调函数之间共享变量或数据结构，便于实现双向数据通讯。<br>(3)可以实现动态的存储分配。<br>(4)便于表示各种数据结构，编写高质量的程序。</p></li><li><p>指针的运算<br>(1)取地址运算符&amp;：求变量的地址<br>(2)取内容运算符※：表示指针所指的变量<br>(3)赋值运算<br>·把变量地址赋予指针变量<br>·同类型指针变量相互赋值<br>·把数组，字符串的首地址赋予指针变量<br>·把函数入口地址赋予指针变量<br>(4)加减运算<br>对指向数组，字符串的指针变量可以进行加减运算，如p+n,p-n,p++,p–等。对指向同一数组的两个指针变量可以相减。对指向其它类型的指针变量作加减运算是无意义的。<br>(5)关系运算<br>指向同一数组的两个指针变量之间可以进行大于、小于、 等于比较运算。指针可与0比较，p==0表示p为空指针。</p></li><li><p>与指针有关的各种说明和意义见下表。</p></li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ※p; 　　　 p为指向整型量的指针变量</span><br><span class="line">int ※p[n]; 　　p为指针数组，由n个指向整型量的指针元素组成。</span><br><span class="line">int (※p)[n]; 　p为指向整型二维数组的指针变量，二维数组的列数为n</span><br><span class="line">int ※p() 　　　p为返回指针值的函数，该指针指向整型量</span><br><span class="line">int (※p)() 　　p为指向函数的指针，该函数返回整型量</span><br><span class="line">int ※※p 　　　 p为一个指向另一指针的指针变量，该指针指向一个整型量。</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li><p>有关指针的说明很多是由指针，数组，函数说明组合而成的。<br>但并不是可以任意组合，例如数组不能由函数组成，即数组元素不能是一个函数；函数也不能返回一个数组或返回另一个函数。例如<br>int a<a href="">5</a>；就是错误的。</p></li><li><p>关于括号<br>在解释组合说明符时， 标识符右边的方括号和圆括号优先于标识符左边的“※”号，而方括号和圆括号以相同的优先级从左到右结合。但可以用圆括号改变约定的结合顺序。</p></li><li><p>阅读组合说明符的规则是“从里向外”。<br>从标识符开始，先看它右边有无方括号或园括号，如有则先作出解释，再看左边有无※号。 如果在任何时候遇到了闭括号，则在继续之前必须用相同的规则处理括号内的内容。例如：<br>int※(※(※a)())[10]<br>↑ ↑↑↑↑↑↑<br>7 6 4 2 1 3 5<br>上面给出了由内向外的阅读顺序，下面来解释它：<br>(1)标识符a被说明为；<br>(2)一个指针变量，它指向；<br>(3)一个函数，它返回；<br>(4)一个指针，该指针指向；<br>(5)一个有10个元素的数组，其类型为；<br>(6)指针型，它指向；<br>(7)int型数据。<br>因此a是一个函数指针变量，该函数返回的一个指针值又指向一个指针数组，该指针数组的元素指向整型量。</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指针是Ｃ语言中广泛使用的一种数据类型。 运用指针编程是Ｃ语言最主要的风格之一。利用指针变量可以表示各种数据结构； 能很方便地使用数组和字符串； 并能象汇编语言一样处理内存地址，从而编出精练而高效的程序。指针极大地丰富了Ｃ语言的功能。 学习指针是学习Ｃ语言中最重要的一环， 能否正确理解和使用指针是我们是否掌握Ｃ语言的一个标志。同时， 指针也是Ｃ语言中最为困难的一部分，在学习中除了要正确理解基本概念，还必须要多编程，上机调试。只要作到这些，指针也是不难掌握的。&lt;br&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://yoursite.com/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>动态规划详解</title>
    <link href="http://yoursite.com/2018/06/01/second/"/>
    <id>http://yoursite.com/2018/06/01/second/</id>
    <published>2018-05-31T23:48:20.772Z</published>
    <updated>2018-06-01T03:39:32.872Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。<br><a id="more"></a><br>首先，我们看一下这道题（此题目来源于北大POJ）：</p><p>数字三角形(POJ1163)</p><p>在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99<br>输入格式：<br>5  //表示三角形的行数接下来输入三角形行数<br>7<br>3   8<br>8   1   0<br>2   7   4   4<br>4   5   2   6   5<br>要求输出最大和<br>接下来，我们来分析一下解题思路：<br>首先，肯定得用二维数组来存放数字三角形<br>然后我们用D( r, j) 来表示第r行第 j 个数字(r,j从1开始算)<br>我们用MaxSum(r, j)表示从D(r,j)到底边的各条路径中，最佳路径的数字之和。<br>因此，此题的最终问题就变成了求 MaxSum(1,1)<br>当我们看到这个题目的时候，首先想到的就是可以用简单的递归来解题：<br>D(r, j)出发，下一步只能走D(r+1,j)或者D(r+1, j+1)。故对于N行的三角形，我们可以写出如下的递归式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( r == N)</span><br><span class="line"> MaxSum(r,j) = D(r,j)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> MaxSum( r, j) = Max&#123; MaxSum(r＋1,j), MaxSum(r+1,j+1) &#125; + D(r,j)</span><br></pre></td></tr></table></figure></p><p> 根据上面这个简单的递归式，我们就可以很轻松地写出完整的递归代码：</p><figure class="highlight plain"><figcaption><span><iostream></iostream></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;   </span><br><span class="line">#define MAX 101</span><br><span class="line">using namespace std;   </span><br><span class="line">int D[MAX][MAX];</span><br><span class="line">int n;</span><br><span class="line">int MaxSum(int i, int j)&#123;  </span><br><span class="line">if(i==n)</span><br><span class="line"> return D[i][j];  </span><br><span class="line">int x = MaxSum(i+1,j);  </span><br><span class="line">int y = MaxSum(i+1,j+1);  </span><br><span class="line"> return max(x,y)+D[i][j];</span><br><span class="line">&#125;  </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line"> for(j=1;j&lt;=i;j++)  </span><br><span class="line">  cin &gt;&gt; D[i][j];  </span><br><span class="line">cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于如上这段递归的代码，当我提交到POJ时，会显示代码运行超时了，为什么会超时呢？</p><p>答案很简单，因为我们重复计算了.<br><a href="https://img-blog.csdn.net/20150811140840233?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" target="_blank" rel="noopener">picture</a><br>就拿第三行数字1来说，当我们计算从第2行的数字3开始的MaxSum时会计算出从1开始的MaxSum，当我们计算从第二行的数字8开始的MaxSum的时候又会计算一次从1开始的MaxSum，也就是说有重复计算。这样就浪费了大量的时间。也就是说如果采用递规的方法，深度遍历每条路径，存在大量重复计算。则时间复杂度为 2的n次方,对于 n = 100 行，肯定超时。<br>接下来，我们就要考虑如何进行改进，我们自然而然就可以想到如果每算出一个MaxSum(r,j)就保存起来，下次用到其值的时候直接取用，则可免去重复计算。那么可以用n方的时间复杂度完成计算。因为三角形的数字总数是 n(n+1)/2<br>根据这个思路，我们就可以将上面的代码进行改进，使之成为记忆递归型的动态规划程序：</p><figure class="highlight plain"><figcaption><span><iostream></iostream></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;   </span><br><span class="line">using namespace std;  </span><br><span class="line">#define MAX 101  </span><br><span class="line">int D[MAX][MAX];  </span><br><span class="line">int n;</span><br><span class="line">int maxSum[MAX][MAX];  </span><br><span class="line">int MaxSum(int i, int j)&#123;</span><br><span class="line">if( maxSum[i][j] != -1 )   </span><br><span class="line">return maxSum[i][j];</span><br><span class="line">if(i==n) </span><br><span class="line">maxSum[i][j] = D[i][j];   </span><br><span class="line">else&#123;  </span><br><span class="line">int x = MaxSum(i+1,j); </span><br><span class="line">int y = MaxSum(i+1,j+1); </span><br><span class="line">maxSum[i][j] = max(x,y)+ D[i][j];   </span><br><span class="line">&#125;   </span><br><span class="line">return maxSum[i][j];   </span><br><span class="line">&#125;   </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line">for(j=1;j&lt;=i;j++) &#123; </span><br><span class="line">cin &gt;&gt; D[i][j]; </span><br><span class="line">maxSum[i][j] = -1; </span><br><span class="line">&#125;  </span><br><span class="line">cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在短时间内就AC了。但是，我们并不能满足于这样的代码，因为递归总是需要使用大量堆栈上的空间，很容易造成栈溢出，我们现在就要考虑如何把递归转换为递推，让我们一步一步来完成这个过程。<br>我们首先需要计算的是最后一行，因此可以把最后一行直接写出，</p><blockquote><p>7<br>3 8<br>8 1 0<br>2 7 4 4<br>表格最下一行为（5X5）：<br>4  5  2  6  5</p></blockquote><p>现在开始分析倒数第二行的每一个数，现分析数字2，2可以和最后一行4相加，也可以和最后一行的5相加，但是很显然和5相加要更大一点，结果为7，我们此时就可以将7保存起来，然后分析数字7，7可以和最后一行的5相加，也可以和最后一行的2相加，很显然和5相加更大，结果为12，因此我们将12保存起来。以此类推。</p><blockquote><p>7<br>3 8<br>8 1 0<br>2 7 4 4<br>表格（5X5）后两行为：<br>7 12 10 10<br>4 5  2  6  5<br>然后按同样的道理分析倒数第三行和倒数第四行，最后分析第一行，我们可以依次得到如下结果：<br>20 13 10<br>7  12 10 10<br>4  5  2  6  5<br>之后变成：<br>30<br>23 21<br>20 13 10<br>7  12 10 10<br>4  5  2  6  5<br>上面的推导过程相信大家不难理解，理解之后我们就可以写出如下的递推型动态规划程序： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;   </span><br><span class="line">using namespace std;   </span><br><span class="line">#define MAX 101      </span><br><span class="line">int D[MAX][MAX]; </span><br><span class="line">int n;</span><br><span class="line">int maxSum[MAX][MAX];   </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line">for(j=1;j&lt;=i;j++)  </span><br><span class="line">cin &gt;&gt; D[i][j]; </span><br><span class="line">for( int i = 1;i &lt;= n; ++ i )   </span><br><span class="line">maxSum[n][i] = D[n][i]; </span><br><span class="line">for( int i = n-1; i&gt;= 1;  --i )   </span><br><span class="line">for( int j = 1; j &lt;= i; ++j )   </span><br><span class="line">maxSum[i][j] = max(maxSum[i+1][j],maxSum[i+1][j+1]) + D[i][j];  </span><br><span class="line">cout &lt;&lt; maxSum[1][1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们的代码仅仅是这样就够了吗？当然不是，我们仍然可以继续优化，而这个优化当然是对于空间进行优化，其实完全没必要用二维maxSum数组存储每一个MaxSum(r,j),只要从底层一行行向上递推，那么只要一维数组maxSum[100]即可,即只要存储一行的MaxSum值就可以。</p><p>接下里的步骤就按上图的过程一步一步推导就可以了。进一步考虑，我们甚至可以连maxSum数组都可以不要，直接用D的第n行直接替代maxSum即可。但是这里需要强调的是：虽然节省空间，但是时间复杂度还是不变的。</p><p>依照上面的方式，我们可以写出如下代码：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;   </span><br><span class="line">#include &lt;algorithm&gt;  </span><br><span class="line">using namespace std;   </span><br><span class="line">#define MAX 101     </span><br><span class="line">int D[MAX][MAX];</span><br><span class="line">int n;   </span><br><span class="line">int * maxSum;       </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line">for(j=1;j&lt;=i;j++)  </span><br><span class="line">cin &gt;D[i][j]; </span><br><span class="line">maxSum = D[n]; //maxSum指向第n行  </span><br><span class="line">for( int i = n-1; i&gt;= 1;  --i )   </span><br><span class="line">for( int j = 1; j &lt;= i; ++j ) </span><br><span class="line">maxSum[j] = max(maxSum[j],maxSum[j+1]) + D[i][j];  </span><br><span class="line">cout &lt;&lt; maxSum[1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 接下来，我们就进行一下总结：</p><p>递归到动规的一般转化方法</p><p>递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。</p></blockquote><h1 id="动规解题的一般思路"><a href="#动规解题的一般思路" class="headerlink" title="动规解题的一般思路"></a>动规解题的一般思路</h1><h2 id="1-将原问题分解为子问题"><a href="#1-将原问题分解为子问题" class="headerlink" title="1. 将原问题分解为子问题"></a>1. 将原问题分解为子问题</h2><blockquote><p>把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。<br>子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。</p></blockquote><h2 id="2-确定状态"><a href="#2-确定状态" class="headerlink" title="2.确定状态"></a>2.确定状态</h2><blockquote><p> 在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。<br>所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。<br>整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。</p></blockquote><h2 id="3-确定一些初始状态（边界状态）的值"><a href="#3-确定一些初始状态（边界状态）的值" class="headerlink" title="3.确定一些初始状态（边界状态）的值"></a>3.确定一些初始状态（边界状态）的值</h2><blockquote><p>  以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。`</p></blockquote><h2 id="4-确定状态转移方程"><a href="#4-确定状态转移方程" class="headerlink" title="4. 确定状态转移方程"></a>4. 确定状态转移方程</h2><blockquote><p>  定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。<br>  数字三角形的状态转移方程：可<a href="https://img-blog.csdn.net/20150811160833998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" target="_blank" rel="noopener">查看</a></p></blockquote><h2 id="能用动规解决的问题的特点"><a href="#能用动规解决的问题的特点" class="headerlink" title="能用动规解决的问题的特点"></a>能用动规解决的问题的特点</h2><blockquote><p>1) 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。</p><p>2) 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://yoursite.com/2018/05/30/hello-world/"/>
    <id>http://yoursite.com/2018/05/30/hello-world/</id>
    <published>2018-05-30T06:13:52.736Z</published>
    <updated>2018-06-01T02:17:28.423Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog.You can talk or help my ideas to more places where can help other people.<br>my email is in about tag,you can talk with me by it.</p><h2 id="My-knowledge-are-here"><a href="#My-knowledge-are-here" class="headerlink" title="My knowledge are here"></a>My knowledge are here</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my present knowledge</span><br><span class="line">&lt;c/c++&gt; &lt;algorithm&gt;</span><br><span class="line">&lt;java se&gt; &lt;java ee&gt; </span><br><span class="line">&lt;Java Server Pages&gt;</span><br><span class="line">&lt;html/js/css&gt; &lt;3ds max&gt;</span><br><span class="line">&lt;database&gt;</span><br><span class="line">&lt;app build&gt;</span><br></pre></td></tr></table></figure><p>I will spend more time to make my knowledge adequate.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to my blog.You can talk or help my ideas to more places where can help other people.&lt;br&gt;my email is in about tag,you can talk wit
      
    
    </summary>
    
      <category term="日常" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
  </entry>
  
</feed>
