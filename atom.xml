<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白——电脑白痴的成长过程</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-01T03:17:58.476Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CZY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划详解</title>
    <link href="http://yoursite.com/2018/06/01/second/"/>
    <id>http://yoursite.com/2018/06/01/second/</id>
    <published>2018-05-31T23:48:20.772Z</published>
    <updated>2018-06-01T03:17:58.476Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。<br><a id="more"></a><br>首先，我们看一下这道题（此题目来源于北大POJ）：</p><p>数字三角形(POJ1163)</p><p>在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99<br>输入格式：<br>5  //表示三角形的行数接下来输入三角形行数<br>7<br>3   8<br>8   1   0<br>2   7   4   4<br>4   5   2   6   5<br>要求输出最大和<br>接下来，我们来分析一下解题思路：<br>首先，肯定得用二维数组来存放数字三角形<br>然后我们用D( r, j) 来表示第r行第 j 个数字(r,j从1开始算)<br>我们用MaxSum(r, j)表示从D(r,j)到底边的各条路径中，最佳路径的数字之和。<br>因此，此题的最终问题就变成了求 MaxSum(1,1)<br>当我们看到这个题目的时候，首先想到的就是可以用简单的递归来解题：<br>D(r, j)出发，下一步只能走D(r+1,j)或者D(r+1, j+1)。故对于N行的三角形，我们可以写出如下的递归式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( r == N)</span><br><span class="line"> MaxSum(r,j) = D(r,j)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> MaxSum( r, j) = Max&#123; MaxSum(r＋1,j), MaxSum(r+1,j+1) &#125; + D(r,j)</span><br></pre></td></tr></table></figure></p><p> 根据上面这个简单的递归式，我们就可以很轻松地写出完整的递归代码：</p><figure class="highlight plain"><figcaption><span><iostream></iostream></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;   </span><br><span class="line">#define MAX 101</span><br><span class="line">using namespace std;   </span><br><span class="line">int D[MAX][MAX];</span><br><span class="line">int n;</span><br><span class="line">int MaxSum(int i, int j)&#123;  </span><br><span class="line">if(i==n)</span><br><span class="line"> return D[i][j];  </span><br><span class="line">int x = MaxSum(i+1,j);  </span><br><span class="line">int y = MaxSum(i+1,j+1);  </span><br><span class="line"> return max(x,y)+D[i][j];</span><br><span class="line">&#125;  </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line"> for(j=1;j&lt;=i;j++)  </span><br><span class="line">  cin &gt;&gt; D[i][j];  </span><br><span class="line">cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于如上这段递归的代码，当我提交到POJ时，会显示代码运行超时了，为什么会超时呢？<br><img src="https://img-blog.csdn.net/20150811140540144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Image text"><br>答案很简单，因为我们重复计算了.<br><img src="https://img-blog.csdn.net/20150811140840233?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>就拿第三行数字1来说，当我们计算从第2行的数字3开始的MaxSum时会计算出从1开始的MaxSum，当我们计算从第二行的数字8开始的MaxSum的时候又会计算一次从1开始的MaxSum，也就是说有重复计算。这样就浪费了大量的时间。也就是说如果采用递规的方法，深度遍历每条路径，存在大量重复计算。则时间复杂度为 2的n次方,对于 n = 100 行，肯定超时。<br>接下来，我们就要考虑如何进行改进，我们自然而然就可以想到如果每算出一个MaxSum(r,j)就保存起来，下次用到其值的时候直接取用，则可免去重复计算。那么可以用n方的时间复杂度完成计算。因为三角形的数字总数是 n(n+1)/2<br>根据这个思路，我们就可以将上面的代码进行改进，使之成为记忆递归型的动态规划程序：</p><figure class="highlight plain"><figcaption><span><iostream></iostream></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;   </span><br><span class="line">using namespace std;  </span><br><span class="line">#define MAX 101  </span><br><span class="line">int D[MAX][MAX];  </span><br><span class="line">int n;</span><br><span class="line">int maxSum[MAX][MAX];  </span><br><span class="line">int MaxSum(int i, int j)&#123;</span><br><span class="line">if( maxSum[i][j] != -1 )   </span><br><span class="line">return maxSum[i][j];</span><br><span class="line">if(i==n) </span><br><span class="line">maxSum[i][j] = D[i][j];   </span><br><span class="line">else&#123;  </span><br><span class="line">int x = MaxSum(i+1,j); </span><br><span class="line">int y = MaxSum(i+1,j+1); </span><br><span class="line">maxSum[i][j] = max(x,y)+ D[i][j];   </span><br><span class="line">&#125;   </span><br><span class="line">return maxSum[i][j];   </span><br><span class="line">&#125;   </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line">for(j=1;j&lt;=i;j++) &#123; </span><br><span class="line">cin &gt;&gt; D[i][j]; </span><br><span class="line">maxSum[i][j] = -1; </span><br><span class="line">&#125;  </span><br><span class="line">cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在短时间内就AC了。但是，我们并不能满足于这样的代码，因为递归总是需要使用大量堆栈上的空间，很容易造成栈溢出，我们现在就要考虑如何把递归转换为递推，让我们一步一步来完成这个过程。<br>我们首先需要计算的是最后一行，因此可以把最后一行直接写出，如下图：</p><blockquote><p><img src="https://img-blog.csdn.net/20150811152746815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p></blockquote><p>现在开始分析倒数第二行的每一个数，现分析数字2，2可以和最后一行4相加，也可以和最后一行的5相加，但是很显然和5相加要更大一点，结果为7，我们此时就可以将7保存起来，然后分析数字7，7可以和最后一行的5相加，也可以和最后一行的2相加，很显然和5相加更大，结果为12，因此我们将12保存起来。以此类推。。</p><blockquote><p><img src="https://img-blog.csdn.net/20150811153237686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>然后按同样的道理分析倒数第三行和倒数第四行，最后分析第一行，我们可以依次得到如下结果：<br><img src="https://img-blog.csdn.net/20150811153534629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p></blockquote><blockquote><p><img src="https://img-blog.csdn.net/20150811153553012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p></blockquote><p>上面的推导过程相信大家不难理解，理解之后我们就可以写出如下的递推型动态规划程序： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;   </span><br><span class="line">using namespace std;   </span><br><span class="line">#define MAX 101      </span><br><span class="line">int D[MAX][MAX]; </span><br><span class="line">int n;</span><br><span class="line">int maxSum[MAX][MAX];   </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line">for(j=1;j&lt;=i;j++)  </span><br><span class="line">cin &gt;&gt; D[i][j]; </span><br><span class="line">for( int i = 1;i &lt;= n; ++ i )   </span><br><span class="line">maxSum[n][i] = D[n][i]; </span><br><span class="line">for( int i = n-1; i&gt;= 1;  --i )   </span><br><span class="line">for( int j = 1; j &lt;= i; ++j )   </span><br><span class="line">maxSum[i][j] = max(maxSum[i+1][j],maxSum[i+1][j+1]) + D[i][j];  </span><br><span class="line">cout &lt;&lt; maxSum[1][1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们的代码仅仅是这样就够了吗？当然不是，我们仍然可以继续优化，而这个优化当然是对于空间进行优化，其实完全没必要用二维maxSum数组存储每一个MaxSum(r,j),只要从底层一行行向上递推，那么只要一维数组maxSum[100]即可,即只要存储一行的MaxSum值就可以。</p><p>接下里的步骤就按上图的过程一步一步推导就可以了。进一步考虑，我们甚至可以连maxSum数组都可以不要，直接用D的第n行直接替代maxSum即可。但是这里需要强调的是：虽然节省空间，但是时间复杂度还是不变的。</p><p>依照上面的方式，我们可以写出如下代码：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;   </span><br><span class="line">#include &lt;algorithm&gt;  </span><br><span class="line">using namespace std;   </span><br><span class="line">#define MAX 101     </span><br><span class="line">int D[MAX][MAX];</span><br><span class="line">int n;   </span><br><span class="line">int * maxSum;       </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line">for(j=1;j&lt;=i;j++)  </span><br><span class="line">cin &gt;D[i][j]; </span><br><span class="line">maxSum = D[n]; //maxSum指向第n行  </span><br><span class="line">for( int i = n-1; i&gt;= 1;  --i )   </span><br><span class="line">for( int j = 1; j &lt;= i; ++j ) </span><br><span class="line">maxSum[j] = max(maxSum[j],maxSum[j+1]) + D[i][j];  </span><br><span class="line">cout &lt;&lt; maxSum[1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 接下来，我们就进行一下总结：</p><p>递归到动规的一般转化方法</p><p>递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。</p></blockquote><h1 id="动规解题的一般思路"><a href="#动规解题的一般思路" class="headerlink" title="动规解题的一般思路"></a>动规解题的一般思路</h1><h2 id="1-将原问题分解为子问题"><a href="#1-将原问题分解为子问题" class="headerlink" title="1. 将原问题分解为子问题"></a>1. 将原问题分解为子问题</h2><blockquote><p>把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。<br>子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。</p></blockquote><h2 id="2-确定状态"><a href="#2-确定状态" class="headerlink" title="2.确定状态"></a>2.确定状态</h2><blockquote><p> 在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。<br>所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。<br>整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。</p></blockquote><h2 id="3-确定一些初始状态（边界状态）的值"><a href="#3-确定一些初始状态（边界状态）的值" class="headerlink" title="3.确定一些初始状态（边界状态）的值"></a>3.确定一些初始状态（边界状态）的值</h2><blockquote><p>  以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。`</p></blockquote><h2 id="4-确定状态转移方程"><a href="#4-确定状态转移方程" class="headerlink" title="4. 确定状态转移方程"></a>4. 确定状态转移方程</h2><blockquote><p>  定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。<br>  数字三角形的状态转移方程：<br><img src="https://img-blog.csdn.net/20150811160833998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p></blockquote><h2 id="能用动规解决的问题的特点"><a href="#能用动规解决的问题的特点" class="headerlink" title="能用动规解决的问题的特点"></a>能用动规解决的问题的特点</h2><blockquote><p>1) 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。</p><p>2) 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://yoursite.com/2018/05/30/hello-world/"/>
    <id>http://yoursite.com/2018/05/30/hello-world/</id>
    <published>2018-05-30T06:13:52.736Z</published>
    <updated>2018-06-01T02:17:28.423Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog.You can talk or help my ideas to more places where can help other people.<br>my email is in about tag,you can talk with me by it.</p><h2 id="My-knowledge-are-here"><a href="#My-knowledge-are-here" class="headerlink" title="My knowledge are here"></a>My knowledge are here</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my present knowledge</span><br><span class="line">&lt;c/c++&gt; &lt;algorithm&gt;</span><br><span class="line">&lt;java se&gt; &lt;java ee&gt; </span><br><span class="line">&lt;Java Server Pages&gt;</span><br><span class="line">&lt;html/js/css&gt; &lt;3ds max&gt;</span><br><span class="line">&lt;database&gt;</span><br><span class="line">&lt;app build&gt;</span><br></pre></td></tr></table></figure><p>I will spend more time to make my knowledge adequate.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to my blog.You can talk or help my ideas to more places where can help other people.&lt;br&gt;my email is in about tag,you can talk wit
      
    
    </summary>
    
      <category term="日常" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
  </entry>
  
</feed>
