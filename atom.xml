<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SmallWhite</title>
  
  <subtitle>电脑白痴的成长过程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-02T13:43:29.824Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CZY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图论基础知识(四)</title>
    <link href="http://yoursite.com/2018/06/02/8/"/>
    <id>http://yoursite.com/2018/06/02/8/</id>
    <published>2018-06-02T13:37:21.415Z</published>
    <updated>2018-06-02T13:43:29.824Z</updated>
    
    <content type="html"><![CDATA[<p>本节内容主要涉及图论中主要思想的解答<br>都已经写了三份博文介绍图论了，那么目前来说主要的内容都基本涉及到了，本文就稍微对第一和第二节文章中的内容稍微概况总结一下，有可能会有相同的地方，主要需要具有<code>离散数学知识</code>的可以参考一下<br><a id="more"></a></p><h1 id="图主要涉及的问题"><a href="#图主要涉及的问题" class="headerlink" title="图主要涉及的问题"></a>图主要涉及的问题</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><blockquote><p>在图G所有生成树中，代价最小的生成树称为最小生成树。<br>应用举例： 在n个城市之间建造通信网络，至少要架设n-1条通信线路，而每两个城市之间架设通信线路的造价是不一样的，那么如何设计才能使得总造价最小？</p></blockquote><h3 id="两种主要求生成树的算法"><a href="#两种主要求生成树的算法" class="headerlink" title="两种主要求生成树的算法"></a>两种主要求生成树的算法</h3><h4 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法　　　"></a>普里姆（Prim）算法　　　</h4><blockquote><p>基本思想：设G=(V, E)是一个无向连通网，T=(U, TE)是G的最小生成树， T的初始状态为U={u0}（u0∈V），TE={ }，重复执行下述操作：在所有u∈U，v∈V-U的边中找一条代价最小的边(u, v)并入集合TE，同时v并入U，直至U=V。</p></blockquote><h4 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法　"></a>克鲁斯卡尔（Kruskal）算法　</h4><blockquote><p>基本思想：设无向连通网为G＝(V, E)，令G的最小生成树为T＝(U, TE)，其初态为U＝V，TE＝{ }，然后，按照边的权值由小到大的顺序，考察G的边集E中的各条边。<br><strong>prim一般求稠密图，kruscal算法求稀疏图。</strong></p></blockquote><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><blockquote><p>最短路径是指两顶点之间经历的边上权值之和最短的路径。（最小生成树的延伸）</p></blockquote><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法　"></a>Dijkstra算法　</h3><blockquote><p>基本思想 设集合S 存放已找到最短路径的顶点，S的初态只包含源点v，对vi∈V-S，假设从源点v到vi的有向边为最短路径。以后每求得一条最短路径v, …, vk，就将vk 加入集合S中，并将路径v, …, vk , vi与原来的假设相比较，取路径长度较小者为最短路径。 重复上述过程，直到集合V中全部顶点加入到集合S中。</p></blockquote><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><blockquote><p>基本思想： 对于从vi到vj的弧，进行n次试探：首先考虑路径vi,v0,vj是否存在，如果存在，则比较vi,vj和vi,v0,vj的路径长度，取较短者为从vi到vj的中间顶点的序号不大于0的最短路径。在路径上再增加一个顶点v1，依此类推，在经过n次比较后，最后求得的必是从顶点vi到顶点vj的最短路径。</p><p><strong>上面的两种算法都是用于从某一点开始，到其他点的最短路径，其算法复杂度均为O(n^3)。</strong></p><p>关键思想通过不断的调整路径，实现最短。</p></blockquote><h3 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="SPFA 算法　　　　　　"></a>SPFA 算法　　　　　　</h3><blockquote><p>算法思想：我们用数组d记录每个结点的最短路径估计值，用邻接表来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止</p></blockquote><h2 id="AOV网与拓扑排序"><a href="#AOV网与拓扑排序" class="headerlink" title="AOV网与拓扑排序"></a>AOV网与拓扑排序</h2><h3 id="AOE网与关键路径"><a href="#AOE网与关键路径" class="headerlink" title="AOE网与关键路径"></a>AOE网与关键路径</h3><p>主要是拓扑排序</p><blockquote><p>拓扑序列：设G=(V，E)是一个具有n个顶点的有向图，V中的顶点序列v1, v2, …, vn称为一个拓扑序列，当且仅当满足下列条件：若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前。 拓扑排序：对一个有向图构造拓扑序列的过程称为拓扑排序 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节内容主要涉及图论中主要思想的解答&lt;br&gt;都已经写了三份博文介绍图论了，那么目前来说主要的内容都基本涉及到了，本文就稍微对第一和第二节文章中的内容稍微概况总结一下，有可能会有相同的地方，主要需要具有&lt;code&gt;离散数学知识&lt;/code&gt;的可以参考一下&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="Graph Theory" scheme="http://yoursite.com/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>图论基础知识(三)</title>
    <link href="http://yoursite.com/2018/06/02/7/"/>
    <id>http://yoursite.com/2018/06/02/7/</id>
    <published>2018-06-02T13:25:25.761Z</published>
    <updated>2018-06-02T13:27:05.964Z</updated>
    
    <content type="html"><![CDATA[<p>此内容包括图论最短路径的五道题目(比较经典，这里只举出其中一例)。<br>不得不说，csdn里面总是有很多大神善于总结，从他们那边了解到了具体准备ACM应该从哪些层面准备，以及相应的准备方法。图论中最长见到的就是最短路径的题目了，因此主要的题目我也在这里阐明.<br><a id="more"></a></p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><p>题目主要取自于poj上的题目，详情可以参考这位大佬的博客链接<br><a href="https://blog.csdn.net/u013752495/article/details/49009947" target="_blank" rel="noopener">https://blog.csdn.net/u013752495/article/details/49009947</a><br>对应poj题目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">poj1125 Stockbroker Grapevine</span><br><span class="line">poj3615 Cow Hurdles</span><br><span class="line">poj1847 Tram</span><br><span class="line">poj1502 MPI Maelstrom</span><br><span class="line">poj1860 Currency Exchange</span><br></pre></td></tr></table></figure></p><p>我以第二个为例子说明一下<br>题目如下:</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Farmer John 想让她的奶牛准备郡级跳跃比赛，贝茜和她的伙伴们正在练习跨栏。她们很累，所以她们想消耗最少的能量来跨栏。 显然，对于一头奶牛跳过几个矮栏是很容易的，但是高栏却很难。于是，奶牛们总是关心路径上最高的栏的高度。 奶牛的训练场中有 N (1 ≤ N ≤ 300) 个站台，分别标记为1..N。所有站台之间有M (1 ≤ M ≤ 25,000)条单向路径，第i条路经是从站台Si开始，到站台Ei，其中最高的栏的高度为Hi (1 ≤ Hi ≤ 1,000,000)。无论如何跑，奶牛们都要跨栏。 奶牛们有 T (1 ≤ T ≤ 40,000) 个训练任务要完成。第 i 个任务包含两个数字 Ai 和 Bi (1 ≤ Ai ≤ N; 1 ≤ Bi ≤ N)，表示奶牛必须从站台Ai跑到站台Bi，可以路过别的站台。奶牛们想找一条路径从站台Ai到站台Bi，使路径上最高的栏的高度最小。 你的任务就是写一个程序，计算出路径上最高的栏的高度的最小值。</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>行 1: 两个整数 N, M, T<br>行2..M+1: 行 i+1 包含三个整数 Si , Ei , Hi 行 M+2..M+T+1: 行 i+M+1 包含两个整数，表示任务i的起始站台和目标站台: Ai , Bi</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>行 1..T: 行 i 为一个整数，表示任务i路径上最高的栏的高度的最小值。如果无法到达，输出 -1。 </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>5 6 3<br>1 2 12<br>3 2 8<br>1 3 5<br>2 5 3<br>3 4 4<br>2 4 8<br>3 4<br>1 2<br>5 1</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>4<br>8<br>-1</p><p>首先附上代码，仅供参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,t;</span><br><span class="line">int a[305][305]; </span><br><span class="line">int main()&#123;</span><br><span class="line">   #ifdef LOCAL</span><br><span class="line">   /*freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">   freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);*/</span><br><span class="line">   #endif</span><br><span class="line">   scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t);</span><br><span class="line">   memset(a,0x3f,sizeof a);</span><br><span class="line">   for(int i=0,x,y,z;i&lt;m;i++)&#123;</span><br><span class="line">       scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">       a[x][y]=min(a[x][y],z);</span><br><span class="line">   &#125;</span><br><span class="line">   for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">       for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">           for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">               a[i][j]=min(a[i][j],max(a[i][k],a[k][j]));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=0,x,y;i&lt;t;i++)&#123;</span><br><span class="line">       scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">       printf(&quot;%d\n&quot;,a[x][y]==0x3f3f3f3f?-1:a[x][y]);</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>其实本体就是folyd算法的变形，从数学来说，就是例题的变式一样，主要就是 给你一个有向图,然后对于特定的点A与B,要你求出A到B之间所有可行路径的单段路距离最大值的最小值.<br>剥除floyd的外壳，本题d[i][j]表示的是从i到j的所有路径中单段路距离最大值的最小值。所以其实本题还是依据动态规划的思想来做的，这里<br><code>d[i][j]=min(d[i][j],max(d[i][k],d[k][j]));</code><br>当不同类d[i][k]和d[k][j]合并的时候，取得是max(最大值，因为我们要求i到j这段路内的最大值)。然后当同类路径值(即两个d[i][j]可行值)选优时，取得是最小值(因为我们要求所有i到j路径目的值中的最小值)。</p></blockquote><p>从上题中我们看到了，凡是最大中最小值的，亦或是最小值中的最大值，都可以使用DP的思想解决，DP也是这段时间必须攻克的地方。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此内容包括图论最短路径的五道题目(比较经典，这里只举出其中一例)。&lt;br&gt;不得不说，csdn里面总是有很多大神善于总结，从他们那边了解到了具体准备ACM应该从哪些层面准备，以及相应的准备方法。图论中最长见到的就是最短路径的题目了，因此主要的题目我也在这里阐明.&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="Graph Theory" scheme="http://yoursite.com/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>图论基础知识(二)</title>
    <link href="http://yoursite.com/2018/06/02/sixth/"/>
    <id>http://yoursite.com/2018/06/02/sixth/</id>
    <published>2018-06-02T13:00:15.748Z</published>
    <updated>2018-06-02T13:04:15.281Z</updated>
    
    <content type="html"><![CDATA[<p>主要包括图论涉及到的常用算法模版。<br>可以说，图论基础知识（一）中，主要探讨了主要的图论知识点，因为ACM比赛的缘故，很多知识体系可以理解成为了比赛而收集得来的，主要的知识结构还是建议学习一下离散数学这门课，之后再涉及相关的数据结构，可能会事半功倍，本节主要将大部分图论的算法收集整合一下，基本都是比赛常用的，欢迎各位收藏。<br><a id="more"></a><br>主要涉及的有最小生成树，最短路径，二分图，连通分量等，首先我得先感谢我的学长将大部分算法收集完成了，我只是在此基础上进行相关的修改完善。</p><blockquote><p><strong>注意：以上内容仅仅只是算法，并不是问题的完整题解，详细经典题解我会在之后补充，可以收集作为模版使用</strong></p></blockquote><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树（详细定义参考离散数学以及数据结构），主要涉及的算法有kruskal算法，prim算法在此基础上修正kruskal+ufs，算法如下：</p><h3 id="kruskal-ufs"><a href="#kruskal-ufs" class="headerlink" title="kruskal+ufs"></a>kruskal+ufs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ufs(int x) &#123;</span><br><span class="line">return f[x] == x ? x : f[x] = ufs(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">int Kruskal(int n,int m) &#123;</span><br><span class="line">int w = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">f[i] = i;</span><br><span class="line">sort(e,e + m);</span><br><span class="line">for(int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">int x = ufs(e[i].u),y = ufs(e[i].v);</span><br><span class="line">if(x != y) &#123;</span><br><span class="line">f[x] = y;</span><br><span class="line">w += e[i].w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int Prim() &#123;</span><br><span class="line">int w = 0;</span><br><span class="line">priority_queue&lt;pair&lt;int, int&gt; &gt; q;</span><br><span class="line">bool l[N] = &#123;0&#125;;</span><br><span class="line">l[1] = 1;</span><br><span class="line">q.push(make_pair(0, 1));</span><br><span class="line">for(int k=1; k&lt;n; k++) &#123;</span><br><span class="line">int u = q.top().second;</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=0; i&lt;G[u].size(); i++)</span><br><span class="line">if(!l[G[u][i]])</span><br><span class="line">q.push(make_pair(-c[u][i], G[u][i]));</span><br><span class="line">while(!q.empty() &amp;&amp; l[q.top().second])</span><br><span class="line">q.pop();</span><br><span class="line">l[q.top().second] = 1;</span><br><span class="line">w += -q.top().first;</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line">return w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>有谈到最短路径了，这也是之前我开始准备图论知识的起源吧，话不多说主要算法如下：</p><h3 id="Dijkstra-priority-queue"><a href="#Dijkstra-priority-queue" class="headerlink" title="Dijkstra+priority_queue"></a>Dijkstra+priority_queue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra(int s) &#123;</span><br><span class="line">priority_queue&lt;pair&lt;int, int&gt; &gt; q;</span><br><span class="line">bool l[N] = &#123;0&#125;;</span><br><span class="line">l[s] = 1;</span><br><span class="line">fill_n(f, n, INF);</span><br><span class="line">f[s] = 0;</span><br><span class="line">q.push(make_pair(-f[s], s));</span><br><span class="line">while(!q.empty()) &#123;</span><br><span class="line">int u = q.front().second;</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=0; i&lt;G[u].size(); i++) &#123;</span><br><span class="line">int v = G[u][i];</span><br><span class="line">if(f[v] &gt; f[u] + c[u][i]) &#123;</span><br><span class="line">f[v] = f[u] + c[u][i];</span><br><span class="line">if(!l[v]) &#123;</span><br><span class="line">l[v] = 1;</span><br><span class="line">q.push(make_pair(-f[v], v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford-SPFA"><a href="#Bellman-Ford-SPFA" class="headerlink" title="Bellman-Ford(SPFA)"></a>Bellman-Ford(SPFA)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void BellmanFord(int s) &#123; // SPFA</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">bool l[N] = &#123;0&#125;;</span><br><span class="line">l[s] = 1;</span><br><span class="line">fill_n(f, n, INF);</span><br><span class="line">f[s] = 0;</span><br><span class="line">q.push(s);</span><br><span class="line">while(!q.empty()) &#123;</span><br><span class="line">int u = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">l[u] = 0;</span><br><span class="line">for(int i=0; i&lt;G[u].size(); i++) &#123;</span><br><span class="line">int v = G[u][i];</span><br><span class="line">if(f[v] &gt; f[u] + c[u][i]) &#123;</span><br><span class="line">f[v] = f[u] + c[u][i];</span><br><span class="line">if(!l[v]) &#123;</span><br><span class="line">l[v] = 1;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FLoyd"><a href="#FLoyd" class="headerlink" title="FLoyd"></a>FLoyd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Floyd() &#123;</span><br><span class="line">for(int k=0; k&lt;n; k++)</span><br><span class="line">for(int i=0; i&lt;n; i++)</span><br><span class="line">for(int j=0; j&lt;n; j++)</span><br><span class="line">f[i][j] = min(f[i][j], f[i][k] + f[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="ufs-验证-Hungary"><a href="#ufs-验证-Hungary" class="headerlink" title="ufs 验证 Hungary"></a>ufs 验证 Hungary</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool DFS(int u) &#123;</span><br><span class="line">for(int i=0; i&lt;G[u].size(); i++) &#123;</span><br><span class="line">int v = G[u][i];</span><br><span class="line">if(!l[v]) &#123;</span><br><span class="line">l[v] = 1;</span><br><span class="line">if(!f[v] || DFS(f[v])) &#123;</span><br><span class="line">f[v] = u;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">int Hungary() &#123;</span><br><span class="line">int w = 0;</span><br><span class="line">for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">fill_n(l, l+n, 0);</span><br><span class="line">if(DFS(i))</span><br><span class="line">w++;</span><br><span class="line">&#125;</span><br><span class="line">return w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h2><h3 id="Tarjan-stack"><a href="#Tarjan-stack" class="headerlink" title="Tarjan stack"></a>Tarjan stack</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; s;</span><br><span class="line">void Tarjan(int u) &#123;</span><br><span class="line">dfn[u] = low[u] = ++time;</span><br><span class="line">l[u] = 1;</span><br><span class="line">s.push(u);</span><br><span class="line">for(int i=0; i&lt;G[u].size(); i++) &#123;</span><br><span class="line">int v = G[u][i];</span><br><span class="line">if(!dfn[v]) &#123;</span><br><span class="line">Tarjan(v);</span><br><span class="line">low[u] = min(low[u], low[v]);</span><br><span class="line">&#125; else if(l[v])</span><br><span class="line">low[u] = min(low[u], dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line">if(dfn[u] == low[u]) &#123;</span><br><span class="line">w++;</span><br><span class="line">do &#123;</span><br><span class="line">int v;</span><br><span class="line">l[v = s.top()] = 0;</span><br><span class="line">f[v] = w;</span><br><span class="line">s.pop();</span><br><span class="line">&#125; while(u != v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void SCC() &#123;</span><br><span class="line">fill_n(dfn, n, 0);</span><br><span class="line">for(int i=0; i&lt;n; i++)</span><br><span class="line">if(!dfn(i))</span><br><span class="line">Tarjan(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><p>网流量的相关问题，主要阐述一下即可，费用流的问题，可以利用<code>Bellman-Ford</code>找增广路，或者<code>贪心算法</code>即可，最大流问题即用<code>Edmonds-KarpS</code>主要介绍一下最大流问题的算法：<br>通过BFS的方式来进行增广路径的查找，即每次找步数最少的路径进行残留网络的修改，此方法的复杂度为O(VE^2).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">int graph::Edmonds_Karp(int start, int end, int remain_g[][1000], int current_g[][1000])//按BFS找增广路径(即每次找边数最短的)实现Ford_Fulkerson方法</span><br><span class="line">&#123;</span><br><span class="line">   for (int i = 0; i &lt; Pnum; i++)</span><br><span class="line">       for (int j = 0; j &lt; Pnum; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           if (edge[i][j] == INF)</span><br><span class="line">               remain_g[i][j] = 0;</span><br><span class="line">           else</span><br><span class="line">               remain_g[i][j] = edge[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">   int max_flow = 0;</span><br><span class="line">   while (1)</span><br><span class="line">   &#123;</span><br><span class="line">       int visit[1000];</span><br><span class="line">       int pre[1000];//记录节点的前驱，好找路径,其实这里的visit可以不要,就用pre</span><br><span class="line">       memset(visit, 0, sizeof(visit));</span><br><span class="line">       memset(pre, 0, sizeof(pre));</span><br><span class="line">       //bfs在残留网络中找增广路径</span><br><span class="line">       queue&lt;int&gt; q;</span><br><span class="line">       q.push(start);</span><br><span class="line">       while (!q.empty())</span><br><span class="line">       &#123;</span><br><span class="line">           int temp_point = q.front();</span><br><span class="line">           q.pop();</span><br><span class="line">           if (temp_point == end)</span><br><span class="line">               break;</span><br><span class="line">           for (int i = 0; i &lt; Pnum; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               if (remain_g[temp_point][i] &gt; 0 &amp;&amp; !visit[i])</span><br><span class="line">               &#123;</span><br><span class="line">                   q.push(i);</span><br><span class="line">                   pre[i] = temp_point;</span><br><span class="line">                   visit[i] = 1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //更新残留网络</span><br><span class="line">       if (pre[end] == 0)//end的前驱没有更新，证明没有增广路径了</span><br><span class="line">           break;</span><br><span class="line">       int min = INF;</span><br><span class="line">       for (int temp_point = end; temp_point != start; temp_point = pre[temp_point])</span><br><span class="line">           min = zzMin(remain_g[pre[temp_point]][temp_point], min);</span><br><span class="line">       for (int temp_point = end; temp_point != start; temp_point = pre[temp_point])</span><br><span class="line">       &#123;</span><br><span class="line">           remain_g[pre[temp_point]][temp_point] -= min;</span><br><span class="line">           remain_g[temp_point][pre[temp_point]] = min;//此为负向边</span><br><span class="line">       &#125;</span><br><span class="line">       max_flow += min;</span><br><span class="line">   &#125;</span><br><span class="line">   return max_flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应的最小割问题，在求得最大流后得到残留网络，从s开始进行bfs，并将所有经过的点标记，然后在残留网络中找到连接标记的点和非标记的点的边，经过这些边的直线即为一个最小割.(这些边事实上就已经是满流量了,即流量=容量).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//remain_g为找到最大流后得到的残留网络</span><br><span class="line">bool graph::Find_Min_Cut(int start,int remain_g[][1000], vector&lt;int&gt; &amp;s_set, vector&lt;int&gt; &amp;t_set)</span><br><span class="line">&#123;</span><br><span class="line">   int visit[1000];</span><br><span class="line">   memset(visit, 0, sizeof(visit));</span><br><span class="line">   queue&lt;int&gt; s;</span><br><span class="line">   s.push(start);</span><br><span class="line">   while (!s.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       int temp_point = s.front();</span><br><span class="line">       s.pop();</span><br><span class="line">       for (int i = 0; i &lt; Pnum; i++)</span><br><span class="line">           if (remain_g[temp_point][i] &gt; 0 &amp;&amp; !visit[i])</span><br><span class="line">           &#123;</span><br><span class="line">               s.push(i);</span><br><span class="line">               visit[i] = 1;</span><br><span class="line">               s_set.push_back(i);</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for (int i = 0; i &lt; Pnum; i++)</span><br><span class="line">       if (!visit[i])</span><br><span class="line">           t_set.push_back(i);</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要包括图论涉及到的常用算法模版。&lt;br&gt;可以说，图论基础知识（一）中，主要探讨了主要的图论知识点，因为ACM比赛的缘故，很多知识体系可以理解成为了比赛而收集得来的，主要的知识结构还是建议学习一下离散数学这门课，之后再涉及相关的数据结构，可能会事半功倍，本节主要将大部分图论的算法收集整合一下，基本都是比赛常用的，欢迎各位收藏。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="Graph Theory" scheme="http://yoursite.com/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>图论基础知识(一)</title>
    <link href="http://yoursite.com/2018/06/01/graph/"/>
    <id>http://yoursite.com/2018/06/01/graph/</id>
    <published>2018-06-01T10:41:41.224Z</published>
    <updated>2018-06-02T04:31:03.577Z</updated>
    
    <content type="html"><![CDATA[<p>准备ACM比赛的时候，懵逼的发现自己竟然不知道怎么求解图论的最短路径问题，至此开始，收集一系列有关图论的知识体系以及大部分题目，力争这段时间完成，在说图论之前，我们首先要知道图论的定义包含哪些。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">图由定点(vertex)的集V和边(edge)的集E组成。</span><br><span class="line">每一条边就是一幅点对(v,w)。</span><br><span class="line">如果点对是有序的，则图是有向的，又称为有向图。</span><br><span class="line">图中的一条路径是一个顶点序列：w1,w2,w3…wN是的(wi,wi+1)属于E。</span><br><span class="line">如果有一个顶点v到它自身的的边(v,v)，那么(v,v)也被称为环。</span><br><span class="line">如果一个无向图中从每个顶点到其他每个顶点都存在一条路径，</span><br><span class="line">则称无向图是连通(也称强连通)。</span><br><span class="line">如果一个有向图不是强连通的，但是它的基础图图是联通的，那么有向图称为弱连通的。</span><br><span class="line">完全图是其每一对顶点建都存在一条边的图。</span><br></pre></td></tr></table></figure><p>紧接着就是图论有关算法涉及到的大多数定理了。稍微从各大网站还有大佬们的博客上爬虫下来的相关信息，了解到了主要有关图论的acm知识点，我以接下来的55点介绍，不一定能完全覆盖，但是大多数常考理论也都在里面涉及，相关算法方面，我也会在随后的一段时间里扩充。</p><blockquote><ol><li>什么是图, 一种高级数据结构, 三元组组成 &lt;V,E,ψ&gt;,V,点的集合, E ,边的集合, ψ是从边集合E到结点无序偶(有序偶)集合上的函数</li><li>也可简记为G = &lt;V,E其中V是非空点集合,E是连接结点的边集,</li><li>无向图,  每一条边都是无向边的图.</li><li>有向图 , 每一条边都是有向边的图. 还有混合图, 就是既有有向边又有无向边的图</li><li>邻接点 在一个图中, 若两个结点由一条或者多条边相连</li><li>在一个图中不与其它边相连的点叫做孤立结点,仅由孤立节点组成的图称为零图, 仅由一个孤立节点组成的图称为平凡图</li><li>关联与同一结点的边称为邻接边, 关联与同一结点的一条边称为自回路或环,环的方向没有意义    </li><li>与一个点相连的边数称为度数,每一个环在其对应结点上的度数增加2</li><li>度数为奇数的的结点必为偶数个</li><li>有向图, 出度与入度 定理, 在任何有向图中出度与入度之和必相等</li><li>含有平行边的任何一个图称为多重图</li><li>把不含有环和平行边的图称为简单图,若任何一对结点之间都有边相连, 则称为完全图, 有n个结点的无向完全图记为Kn</li><li>生成子图 : 包含G中所有结点,且该字图为G的生成子图</li><li>路和通路 给定图 G = &lt;V,E&gt;,设v0,v1,…vn€V,e1,e2,…en, €E,其中ei是关联于vi-1,vi的边,交替序列v0e1v1e2v2 e3 e3v3..envn称为联结v0到vn的路</li><li>v0到vn分别称作路的起点和终点,边的数目n称作路的长度,v0 = vn时,这条路称为回路</li><li>若一条路中e1,e2,e3,…en都不相同,称作迹.</li><li>若一条路中所有的结点v0,v1,v2…vn均不相同,称为通路</li><li>闭的通路即除v0 = vn外,其余结点均不相同的路称为圈</li><li>欧拉图 - 给定无孤立节点图G,若存在一条路,经过图中每边一次且仅一次,该条路称为欧拉路,若存在一条回路, 经过图中每边一次且仅一次,成回路为欧拉回路,具有欧拉回路的图称为欧拉图</li><li>定理 无向图具有一条欧拉路, 当且仅当G是连通的,且有零个或奇数度结点</li><li>推论 无向图G具有一条欧拉回路, 当且仅当G是连通的,并且所有结点度数全为偶数</li><li>定义给定有向图G,通过图中每边一次且仅一次的一条单向路(回路),称作单向欧拉路(回路)</li><li>定理 有向图G具有一条单向欧拉回路,当且仅当是连通的, 且每个结点的出度等于入度.一个有向图G具有一条单向欧拉路,当且仅当它是连通的,而且除了两个节点为出度等于入度,但这两个结点中,一个的入度比出度大1,另一个出度比入度大1</li><li>汉密尔顿路,周游世界问题</li><li>定义 给定图G,若存在一条路经过图中每一个结点恰好一次,这条路称作汉密尔顿路. 若存在一条回路,经过图中每一个结点恰好一次, 称为汉密尔顿回路</li><li>定理 若图G = &lt;V,E具有汉密尔顿回路,则对于结点集V的每个非空子集S均有W(G-S) &lt;= |S|成立,.其中W(G-S)是G-S中的连通分支数目,常用来证明某些图是非汉密尔顿图</li><li>充分条件 设G具有n个结点的简单图,如果G中每一对结点度数之和大于等于n-1,则在G中存在一条汉密尔顿路</li><li>例 考虑在七天之内安排气门课程的考试,使得同一位教师所任的两门课考试不排在接连的两天中,证明如果没有教不同的老师担任,则在这两个结点之间有一条边,因为每一个老师所任课程不超过4,则每个节点的度数至少是3,任意两个结点度数之和至少是6,故G总是存在一条汉密尔顿路,它对应于一个七门考试科目的一个适当的安排</li><li>定理 设G是具有n个结点的简单图,如果G中每一对结点度数之和大于等于n,则在G中存在一条汉密尔顿回路</li><li>平面图, 设 G = &lt;V,E是一个无向图,如果能够把G的所有结点和边画在平面上,且使得任何两条边除了断点之外没有其它的交点,则成G是一个平面图    </li><li>一个有限平面图,面的次数之和是边数的两倍,</li><li>欧拉定理 凸多面体, v个顶点,e条边,r块面,则v-e+r = 2,</li><li>同样对于一个联通的平面图G,共有v个结点,e条边,r个面,则欧拉公式 v-e+r = 2成立</li><li>定理 设G是一个由V个结点,e条边的连通简单平面图,若v&gt;=3,则e&lt;=3v-6 用该定理可判断某些图是否为非平面图  </li><li>对偶图    </li><li>树和生成树</li><li>定义 : 一个连通且无回路的的无向图称为树.书中度数为一的结点成为树叶,度数大于一的点称为分枝点或者内点. 一个无回路的无向图称为森林,他的每个连通分录称为森林</li><li>定理 任何一棵树中至少有两片树叶</li><li>若图G的生成子图是一个树,则成该树是G的一个生成树</li><li>设图G中有一棵生成树T,则T中的边叫做树枝,图G中不在树T中的称为弦, 弦的集合称为T的补</li><li>定理 连通图至少有一棵生成树</li><li>一条回路和任何一棵生成树的补至少有一条公共边</li><li>一个割边集和任何一棵生成树至少有一条公共边    </li><li>在图G的所有生成树中,树权最小的那颗生成树称为最小生成树</li><li>最小生成树算法Kruskal  </li><li>如果一个有向图在不考虑边的方向的情况下是一棵树, 那么,称这个有向图为有向树</li><li>根树及其应用</li><li>一棵有向树, 如果恰有一个结点的入度为0,其余所有结点的入度都为一,入度为0的结点称为根,出度为0的结点称为叶,出度不为零的结点称为分支点或者内点</li><li>层次,任意结点的层次就是从根到结点的单向通路长度</li><li>定义 在根树中, 若每一个结点的出度正好小于或等于m,称这棵树为m叉树. 如果每一个结点的出度恰好等于m或零, 则称这棵树为完全m叉树, 若所有树叶层次相同,则称为正则m叉树</li><li>设有完全m叉树, 其树叶数为t,分枝点数为i,(m-1)i = t-1</li><li>应用 : 假设有一台计算机, 它有一条加法指令,可计算三个数的和,如果要计算9个数的和,至少要执行几次加法指令 (3-1) i = 9-1</li><li>定义: 在根树中, 一个结点的通路长度,就是从树根到此节点的通路中的边数. 我们把分枝点的通路长度称为内部通路长度, 树叶的通路长度称为外部通路长度</li><li>定理 : 若完全二叉树有n个分枝点,且内部通路长度的总和为I, 外部通路长度的总和为E,则 E = I+2n</li><li>最优二叉树问题, 霍夫曼树, 前缀码问题。</li></ol></blockquote><p>附赠：来自csdn某位大佬贡献的各大OJ上有关的图论500题，已经按类按OJ型号题目位置划分完毕，可以供大家学习使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br></pre></td><td class="code"><pre><span class="line">=============================以下是最小生成树+并查集======================================</span><br><span class="line">【HDU】</span><br><span class="line">1213 How Many Tables基础并查集★</span><br><span class="line">1272 小希的迷宫基础并查集★</span><br><span class="line">1325&amp;&amp;poj1308 Is It A Tree?基础并查集★</span><br><span class="line">1856 More is better基础并查集★</span><br><span class="line">1102 Constructing Roads基础最小生成树★</span><br><span class="line">1232 畅通工程基础并查集★</span><br><span class="line">1233 还是畅通工程基础最小生成树★</span><br><span class="line">1863 畅通工程基础最小生成树★</span><br><span class="line">1875 畅通工程再续基础最小生成树★</span><br><span class="line">1879 继续畅通工程基础最小生成树★</span><br><span class="line">3371Connect the Cities  简单最小生成树★</span><br><span class="line">1301 Jungle Roads基础最小生成树★</span><br><span class="line">1162 Eddy&apos;s picture基础最小生成树★</span><br><span class="line">1198 Farm Irrigation基础最小生成树★</span><br><span class="line">1598 find the most comfortable road枚举+最小生成树★★</span><br><span class="line">1811 Rank of Tetris并查集+拓扑排序★★</span><br><span class="line">3926 Hand in Hand同构图★</span><br><span class="line">3938 Portal  离线+并查集★★</span><br><span class="line">2489Minimal Ratio Tree dfs枚举组合情况+最小生成树★</span><br><span class="line">4081Qin Shi Huang&apos;s National Road System 最小生成树+DFS★★</span><br><span class="line">4126Genghis Khan the Conqueror 枚举+最小生成树+DFS(难)★★★★</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">1829&amp;&amp;poj2492 A Bug&apos;s Life基础种类并查集★</span><br><span class="line">1558 Segment set计算几何+并查集★</span><br><span class="line">3461 Code Lock并查集(有点难想到)★★</span><br><span class="line">3367 Pseudoforest最大生成树★</span><br><span class="line">2473 Junk-Mail Filter并查集+设立虚父节点(马甲)★★</span><br><span class="line">3172 Virtual Friends带权并查集★</span><br><span class="line">3635 Dragon Balls带权并查集★</span><br><span class="line">3047 Zjnu Stadium带权并查集★</span><br><span class="line">3038 How Many Answers Are Wrong种类并查集★★</span><br><span class="line">2818 Building Block带权并查集★</span><br><span class="line">3234 Exclusive-OR异或并查集(难)★★★</span><br><span class="line">2121Ice_cream’s world II  最小树形图(要输出根有点恶心)★★</span><br><span class="line">4009Transfer water 最小树形图(模板题)★</span><br><span class="line">3311  Dig The Wells  斯坦纳树(状压DP)(模板题)★★</span><br><span class="line">4085Peach Blossom Spring斯坦纳树(状压DP)(有可能是森林...)★★★</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">2586 How far away ？LCA★</span><br><span class="line">2874 Connections between citiesLCA★</span><br><span class="line">3486 IntervieweRMQ★</span><br><span class="line">2888 Check Corners二维RMQ★</span><br><span class="line">3183A Magic LampRMQ(有点难想到,有点难联系到RMQ)★★</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">【POJ】</span><br><span class="line">1258 最经典的MST★</span><br><span class="line">1789 Truck History 最小生成树★</span><br><span class="line">1287 Networking 简单★</span><br><span class="line">2349 Arctic Network简单★</span><br><span class="line">1611 The Suspects 并查集★</span><br><span class="line">2377 kruskal★</span><br><span class="line">2524 Ubiquitous Religions 并查集★</span><br><span class="line">2236 Wireless Network 并查集+计算几何★</span><br><span class="line">2560 Kruskal 并查集★</span><br><span class="line">1861 Kruskal ★</span><br><span class="line">3625 prim★</span><br><span class="line">1679 - The Unique MST(基础)  判断MST是否唯一★</span><br><span class="line">3522 - Slim Span(基础)  求一颗生成树，让最大边最小边差值最小★</span><br><span class="line">2485 Highways MST中的最长边★</span><br><span class="line">2395 最小生成树的最长边★</span><br><span class="line">1751 Highways 求出方案★</span><br><span class="line">POJ-1182 食物链 种类并查集★★</span><br><span class="line">POJ 1456 Supermarket贪心+区间合并★</span><br><span class="line">POJ-1703 种类并查集★</span><br><span class="line">POJ-1988 种类并查集★</span><br><span class="line">POJ-1733 Parity game 种类并查集，先要离散化一下，不影响结果★</span><br><span class="line">POJ-1417 True Liars(难) 并查集+DP 种类并查集★★</span><br><span class="line">POJ-2912 Rochambeau(难) baidu的题,很不错...是食物链的加强版.判断裁判比较难想.★★★</span><br><span class="line">POJ 2728 Desert King(中等)  最优比率生成树★★</span><br><span class="line">POJ 1639 Picnic Planning(较难) 顶点度数有限制的最小生成树★★</span><br><span class="line">POJ 3164 Command Network(难) 最小树形图★★</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">poj3723好题!!! ★★</span><br><span class="line">poj3228好好题!!! ★★</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【ZOJ】</span><br><span class="line">ZOJ-3261 逆向并查集 ★★</span><br><span class="line">===============================以下是最短路系列====================================</span><br><span class="line">【HDU】</span><br><span class="line">1548A strange lift基础最短路(或bfs)★</span><br><span class="line">2544最短路 基础最短路★</span><br><span class="line">3790   最短路径问题基础最短路★</span><br><span class="line">2066    一个人的旅行基础最短路(多源多汇,可以建立超级源点和终点)★</span><br><span class="line">2112HDU Today基础最短路★</span><br><span class="line">1874畅通工程续基础最短路★</span><br><span class="line">1217Arbitrage   货币交换 Floyd (或者 Bellman-Ford 判环)★</span><br><span class="line">1245Saving James Bond计算几何+最短路★</span><br><span class="line">1317XYZZY  Bellman-Ford判环,有负权★</span><br><span class="line">1535Invitation Cards   有向图的来回最短路,(反向建图)★</span><br><span class="line">1546Idiomatic Phrases Game  最短路★</span><br><span class="line">2680Choose the best route   最短路★</span><br><span class="line">2923Einbahnstrasse最短路★</span><br><span class="line">3339In Action  最短路+背包★</span><br><span class="line">2224The shortest path双调旅行商问题★★</span><br><span class="line">2807The Shortest Path矩阵运算+最短路(floyd)★★</span><br><span class="line">1595find the longest of the shortest枚举+最短路(删掉任意一条边的最长最短路)★★</span><br><span class="line">3986Harry Potter and the Final Battle 枚举+最短路(删掉任意一条边的最长最短路)★★</span><br><span class="line">1599find the mincost routefloyd求最小环★</span><br><span class="line">1839Delay Constrained...二分下限+最短路(带限制最短路)★★</span><br><span class="line">3631 Shortest Path   Floyd插点法★★</span><br><span class="line">4114Disney&apos;s FastPass最短路+二维状压DP(难)★★★</span><br><span class="line">3832Earth Hour三点连通(斯坦纳树)★</span><br><span class="line">3873Invade the MarsDij变体(好题!,带限制最短路)★★★</span><br><span class="line">4063 Aircraft几何构图+最短路★★★★</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">hdu4179Difficult Routesdis[][]开二维状态的最短路(带限制最短路)★★</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">1869 六度分离 Floyd最短路★</span><br><span class="line">1385Minimum Transport Cost最短路+输出路径(输出字典序最小路径,有点恶心)★★</span><br><span class="line">1224free DIY Tour 最短路+输出路径★</span><br><span class="line">1142A Walk Through the Forest  最短路+记忆搜索★★</span><br><span class="line">1596find the safest road   乘积最小的最短路★</span><br><span class="line">1598find the most comfortable road二分速度差+最短路(带限制最短路)★★</span><br><span class="line">2722Here We Go(relians) Again最短路★</span><br><span class="line">2962Trucking  二分+最短路(带限制最短路)★★</span><br><span class="line">1690Bus System 最短路★</span><br><span class="line">2433Travel删边+最短路之和(预处理桥边)★★★</span><br><span class="line">2363Cycling二分+最短路(带限制最短路)★★</span><br><span class="line">2377Bus Pass最短路(寻找一个点的最长最短路最小)★★</span><br><span class="line">2833WuKong最短路+记忆化搜索(求两条最短路的最多公共点)★★</span><br><span class="line">1688Sightseeing最短次短路条数★★</span><br><span class="line">3191How Many Paths Are There次短路条数★★</span><br><span class="line">2482Transit search最短路★★★</span><br><span class="line">3768 Shopping最短路+dfs(或最短路+状压DP)★★</span><br><span class="line">3035War平面图最小割(建图麻烦)★★</span><br><span class="line">3870Catch the Theves 平面图最小割(建图麻烦)★★</span><br><span class="line">3860Circuit Board平面图最小割(建图麻烦)★★</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【POJ】</span><br><span class="line">1062 昂贵的聘礼竟然可以和最短路联系起来★★</span><br><span class="line">1094 Sorting It All OutFloyd判环+拓扑排序★</span><br><span class="line">1125Stockbroker GrapevineFloyd★</span><br><span class="line">1135 Domino Effect最短路,比较有意思★★</span><br><span class="line">1161 Walls最短路(图太恶心了)★★</span><br><span class="line">1502 MPI MaelstromFloyd★</span><br><span class="line">1511Invitation Cards来回最短路★</span><br><span class="line">1556The Doors  计算几何+最短路★★</span><br><span class="line">1724 ROADS带限制的最短路,dis[][]开二维来记录信息(或广搜)★★</span><br><span class="line">1734 Sightseeing tripfloyd最小环路径★</span><br><span class="line">1797 Heavy Transportation二分枚举+最短路★</span><br><span class="line">1847 Tram简单最短路★</span><br><span class="line">1860Currency Exchange货币兑换★</span><br><span class="line">1949 Chores反向建边,求最长路★★</span><br><span class="line">2139 Six Degrees of Cowvin BaconFloyd★</span><br><span class="line">2240Arbitrage货币兑换★</span><br><span class="line">2253Frogger二分+最短路★</span><br><span class="line">2312 坦克大战spfa最短路本质变形--&gt;广搜★</span><br><span class="line">2387 Til the Cows Come Home基础最短路★</span><br><span class="line">2394Checking an Alibi最短路★</span><br><span class="line">2449Remmarguts&apos; DateA*求第K短路★★</span><br><span class="line">2457 Part Acquisition最短路 (输出路径)★★</span><br><span class="line">2472 106 miles to Chicago乘积最短路(log一下,乘变加)★★</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">2502Subway</span><br><span class="line">2570 Fiber Network floyd</span><br><span class="line">3013 圣诞树</span><br><span class="line">3037Skiing</span><br><span class="line">3072 Robot</span><br><span class="line">3114 Countries in War 强联通+最短路</span><br><span class="line">3160 Father Christmas flymouse 强联通+最长路</span><br><span class="line">3255 Roadblock</span><br><span class="line">3259 Wormholes（寻找负权回路）</span><br><span class="line">3268 Silver Cow Part</span><br><span class="line">3311 Hie with the Pie floyd+状压</span><br><span class="line">3328 Cliff Climbing</span><br><span class="line">3439 Server Relocation</span><br><span class="line">3463 Sightseeing 次短路条数</span><br><span class="line">3159</span><br><span class="line">3521Geometric Map计算几何+最短路</span><br><span class="line">3549GSM phone 计算几何+最短路</span><br><span class="line">3594 Escort of Dr. Who How</span><br><span class="line">3613 Cow Relays  经过N条边的最短路 // floyd + 二分矩阵</span><br><span class="line">3615 Cow Hurdles</span><br><span class="line">3621 最优比率环</span><br><span class="line">3635 full tank?</span><br><span class="line">3660 传递闭包</span><br><span class="line">3662 Telephone Lines</span><br><span class="line">============================以下是差分约束系列============================</span><br><span class="line">【HDU】</span><br><span class="line">1384 Intervals</span><br><span class="line">1529 Cashier Employment</span><br><span class="line">1531 King</span><br><span class="line">1534 Schedule Problem</span><br><span class="line">3440 House Man</span><br><span class="line">3592 World Exhibition</span><br><span class="line">3666 THE MATRIX PROBLEM</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【POJ】</span><br><span class="line">1201</span><br><span class="line">1275</span><br><span class="line">1364</span><br><span class="line">1716</span><br><span class="line">2949</span><br><span class="line">2983</span><br><span class="line">3159</span><br><span class="line">3169</span><br><span class="line">3687</span><br><span class="line">============================以下是二分匹配系列============================</span><br><span class="line">普通匹配,多重匹配</span><br><span class="line">【HDU】</span><br><span class="line">1068Girls and Boys</span><br><span class="line">1150Machine Schedule</span><br><span class="line">1151Air Raid</span><br><span class="line">1179Ollivanders: Makers of Fine Wands since 382 BC.</span><br><span class="line">1281棋盘游戏</span><br><span class="line">149850 years, 50 colors</span><br><span class="line">1507Uncle Tom&apos;s Inherited Land*</span><br><span class="line">1528Card Game Cheater</span><br><span class="line">1845Jimmy’s Assignment</span><br><span class="line">2063过山车</span><br><span class="line">2119Matrix</span><br><span class="line">2444The Accomodation of Students</span><br><span class="line">2768Cat vs. Dog</span><br><span class="line">3081Marriage Match II</span><br><span class="line">3360National Treasures</span><br><span class="line">1045也可搜索</span><br><span class="line">1350最小路径覆盖</span><br><span class="line">3118类似二分匹配</span><br><span class="line">3729</span><br><span class="line">2389</span><br><span class="line">1054</span><br><span class="line">2819完全匹配</span><br><span class="line">1668 二分+多重匹配</span><br><span class="line">3605多重匹配</span><br><span class="line">3861强连通+二分匹配</span><br><span class="line">2236无题II</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">hdu3468</span><br><span class="line">hdu4185奇偶匹配</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【POJ】</span><br><span class="line">1087A Plug for UNIX</span><br><span class="line">1274 The Perfect Stall</span><br><span class="line">1469COURSES</span><br><span class="line">1486 Sorting Slides 二分图的必须边</span><br><span class="line">1548Robots</span><br><span class="line">1698Alice&apos;s Chance</span><br><span class="line">1719Shooting Contest</span><br><span class="line">1904 King&apos;s Quest 求二分图所有可能的匹配边</span><br><span class="line">2060 Taxi Cab Scheme 最小路径覆盖</span><br><span class="line">2112 Optimal Milking 二分+多重匹配</span><br><span class="line">2226 Muddy Fields 行列的覆盖</span><br><span class="line">2239 Selecting Courses</span><br><span class="line">2289 Jamie&apos;s Contact Groups 二分+多重匹配</span><br><span class="line">2446 Chessboard</span><br><span class="line">2536 Gopher II</span><br><span class="line">2584T-Shirt Gumbo</span><br><span class="line">2594 Treasure Exploration 可相交最小路径覆盖</span><br><span class="line">2672Hotkeys</span><br><span class="line">2724 Purifying Machine</span><br><span class="line">3020 Antenna Placement</span><br><span class="line">3041 Asteroids 简单行列匹配 </span><br><span class="line">3189Steady Cow Assignment 二分+多重匹配</span><br><span class="line">3207 Ikki&apos;s Story IV - Panda&apos;s Trick</span><br><span class="line">3216 Repairing Company</span><br><span class="line">3343 Against Mammoths</span><br><span class="line">3692 Kindergarten</span><br><span class="line">2771最大独立集</span><br><span class="line">============================以下是KM算法系列============================</span><br><span class="line">【HDU】</span><br><span class="line">2255奔小康赚大钱</span><br><span class="line">1533Going Home</span><br><span class="line">1853Cyclic Tour</span><br><span class="line">3488Tour</span><br><span class="line">3435A new Graph Game</span><br><span class="line">2426Interesting Housing Problem</span><br><span class="line">2853Assignment</span><br><span class="line">3718Similarity</span><br><span class="line">3722Card Game</span><br><span class="line">3395Special Fish</span><br><span class="line">2282Chocolate</span><br><span class="line">2813One fihgt one</span><br><span class="line">2448Mining Station on the Sea</span><br><span class="line">3315My Brute</span><br><span class="line">3523Image copy detection</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【POJ】</span><br><span class="line">2195 Going Home 最小权值匹配</span><br><span class="line">2400 Supervisor, Supervisee 输出所有最小权匹配</span><br><span class="line">2516 Minimum Cost 最小权值匹配或最小费用流</span><br><span class="line">3565Ants</span><br><span class="line">3686 The Windy&apos;s 最小权值匹配</span><br><span class="line">============================以下是最大团&amp;稳定婚姻系列============================</span><br><span class="line">【HDU】</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">1530Maximum Clique</span><br><span class="line">1435Stable Match</span><br><span class="line">3585maximum shortest distance 二分+最大团</span><br><span class="line">1522Marriage is Stable</span><br><span class="line">1914The Stable Marriage Problem</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【POJ】</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">1129四色定理 着色问题</span><br><span class="line">1419最大独立集</span><br><span class="line">2989极大团</span><br><span class="line">3487 The Stable Marriage Problem 稳定婚姻</span><br><span class="line">============================以下是强双联通系列============================</span><br><span class="line">【HDU】</span><br><span class="line">强连通:</span><br><span class="line">1269  迷宫城堡  判断是否是一个强连通</span><br><span class="line">2767Proving Equivalences  至少加几条边让整个图变成强连通</span><br><span class="line">3836 Equivalent Sets  至少加几条边让整个图变成强连通</span><br><span class="line">1827   Summer Holiday  传递的最小费用</span><br><span class="line">3072Intelligence System  传递的最小费用</span><br><span class="line">3861The King’s Problem 强连通+二分匹配</span><br><span class="line">3639Hawk-and-Chicken  强连通缩点 + 树形dp（累加子节点的总权值）</span><br><span class="line">3594 Cactus 仙人掌图</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">双连通:</span><br><span class="line">2242考研路茫茫——空调教室  双联通缩点+树形DP</span><br><span class="line">2460Network 边双连通</span><br><span class="line">3849By Recognizing These Guys, We Find Social Networks Useful  双连通求桥</span><br><span class="line">3896Greatest TC  双连通</span><br><span class="line">4005 The war  边双连通</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">LCA:</span><br><span class="line">2586How far away ？</span><br><span class="line">2874Connections between cities</span><br><span class="line">3078Network  LCA+排序</span><br><span class="line">3830Checkers  二分+LCA</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【POJ】</span><br><span class="line">强连通:</span><br><span class="line">1236Network of Schools</span><br><span class="line">2553 The Bottom of a Graph  好题！ 找出度为0的集合</span><br><span class="line">2186Popular Cows  好题！ 找出度为0的，其他分量都指向它的集合</span><br><span class="line">2375Cow Ski Area 强连通</span><br><span class="line">2762Going from u to v or from v to u?  缩点+拓扑排序</span><br><span class="line">3160   Father Christmas flymouse  强连通+最短路</span><br><span class="line">3180 The Cow Prom  判断有几个环， 分量中元素大于1的个数</span><br><span class="line">3114Countries in War  强连通+最短路</span><br><span class="line">3592Instantaneous Transference  强连通分量+最长路</span><br><span class="line">1904King&apos;s Quest  强连通+并查集 </span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">双连通：</span><br><span class="line">3694 Network  边双连通 (同hdu2460)</span><br><span class="line">3177 Redundant Paths   构造边双连通</span><br><span class="line">3352 Road Construction   构造边双连通</span><br><span class="line">2942 Knights of the Round Table (点双连通经典题)</span><br><span class="line">1515 Street Directions (无向图改有向图)</span><br><span class="line">1438 One-way Traffic  (混合图改有向图)</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">LCA:</span><br><span class="line">1330Nearest Common Ancestors</span><br><span class="line">1470Closest Common Ancestors</span><br><span class="line">1986Distance Queries</span><br><span class="line">3417Network</span><br><span class="line">3728The merchant  LCA+并查集,更新询问</span><br><span class="line">2763Housewife Wind LCA+树状数组</span><br><span class="line">============================以下是2-SAT系列============================</span><br><span class="line">【HDU】</span><br><span class="line">3062 Party</span><br><span class="line">1824 Let&apos;s go home</span><br><span class="line">3622 Bomb Game</span><br><span class="line">3715 Go Deeper</span><br><span class="line">1815 Building roads</span><br><span class="line">2723 Get Luffy Out</span><br><span class="line">1816 Get Luffy Out *</span><br><span class="line">1814 Peaceful Commission</span><br><span class="line">4115 Eliminate the Conflict</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【POJ】</span><br><span class="line">2296 Map Labeler</span><br><span class="line">2723 Get Luffy Out</span><br><span class="line">2749  Building roads</span><br><span class="line">3207  Ikki&apos;s Story IV - Panda&apos;s Trick</span><br><span class="line">3648 Wedding</span><br><span class="line">3678 Katu Puzzle</span><br><span class="line">3683  Priest John&apos;s Busiest Day</span><br><span class="line">3905 Perfect Election</span><br><span class="line">============================以下是欧拉回路系列============================</span><br><span class="line">【HDU】</span><br><span class="line">1878欧拉回路  判断</span><br><span class="line">3018Ant Trip 一笔画问题</span><br><span class="line">1116</span><br><span class="line">2894兹鼓欧拉回路</span><br><span class="line">1956</span><br><span class="line">3472混合欧拉</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【POJ】</span><br><span class="line">2513  欧拉路</span><br><span class="line">1041  John&apos;s trip  欧拉回路</span><br><span class="line">1386 Play on Words  单词接龙</span><br><span class="line">2230Watchcow  欧拉回路</span><br><span class="line">2513 Colored Sticks  无向图欧拉路</span><br><span class="line">2337 Catenyms  欧拉路径</span><br><span class="line">1392 Ouroboros Snake  兹鼓欧拉回路</span><br><span class="line">1780  code</span><br><span class="line">1637  混合欧拉</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【zoj】</span><br><span class="line">1992</span><br><span class="line">============================以下是拓扑排序系列============================</span><br><span class="line">【HDU】</span><br><span class="line">1285确定比赛名次</span><br><span class="line">2094产生冠军</span><br><span class="line">2647Reward</span><br><span class="line">3342Legal or Not</span><br><span class="line">1811Rank of Tetris  拓扑+并查集</span><br><span class="line">3231 三维拓扑</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">【POJ】</span><br><span class="line">1094 Sorting It All Out  Floyd+拓扑</span><br><span class="line">2367 Genealogical tree</span><br><span class="line">3660 Cow Contest</span><br><span class="line">3687 Labeling Balls 神奇的拓扑</span><br><span class="line">1128Frame Stacking  DFS版拓扑</span><br><span class="line">1270Following Orders  拓扑+回溯</span><br><span class="line">1420Spreadsheet  模拟拓扑</span><br><span class="line">2762Going from u to v or from v to u?  强连通+拓扑</span><br><span class="line">3553Task schedule</span><br><span class="line">============================以下是竞赛图系列============================</span><br><span class="line">竞赛图下的哈密顿问题</span><br><span class="line">Strange Country IIZOJ-3332</span><br><span class="line">Task SequencesPOJ-1776</span><br><span class="line">The bookSGU-122</span><br><span class="line">Tour RoutePOJ-3780</span><br><span class="line">Tour RouteHDOJ-3414</span><br><span class="line">============================以下是网络流系列============================</span><br><span class="line">【HDU】</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">1532Drainage Ditches(基础)[最大流]</span><br><span class="line">3549Flow Problem(基础)[最大流]</span><br><span class="line">3572Task Schedule[最大流]任务分配,判断满流</span><br><span class="line">2732Leapin&apos; Lizards(难)[最大流]</span><br><span class="line">3338Kakuro Extension[最大流][数和]神奇最大流行进列出</span><br><span class="line">2883kebab[最大流]判断满流</span><br><span class="line">3605Escape[最大流](多重匹配</span><br><span class="line">3081Marriage Match II[二分最大流]+并查集</span><br><span class="line">3277Marriage Match III[二分最大流]同上,多了拆点</span><br><span class="line">3416Marriage Match IV[最大流]最短路+最大流</span><br><span class="line">2485Destroying the bus stations[最大流]最短路+最大流</span><br><span class="line">3468Treasure Hunting[最大流](二分匹配)+最短路</span><br><span class="line">3551Hard Problem[最大流]</span><br><span class="line">3998Sequence(难)[DP+最大流]最长上升子序列</span><br><span class="line">3917Road constructions[最大权闭包]</span><br><span class="line">3879Base Station[最大权闭包]</span><br><span class="line">3061Battle[最大权闭包]</span><br><span class="line">3996Gold Mine[最大权闭包]</span><br><span class="line">3472HS BDC[混合欧拉]</span><br><span class="line">hdu4183来回走不重复点的网络流.</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">1533Going Home(基础)[费用流]</span><br><span class="line">3488Tour[费用流]圈</span><br><span class="line">3435A new Graph Game[费用流]圈</span><br><span class="line">1853Cyclic Tour[费用流]圈</span><br><span class="line">2686Matrix[费用流]</span><br><span class="line">3376Matrix Again[费用流]</span><br><span class="line">3667Transportation[费用流]拆边</span><br><span class="line">3315My Brute[费用流](可用KM)</span><br><span class="line">3395Special Fish[费用流](可用KM匹配)</span><br><span class="line">2448Mining Station on the Sea[费用流](可用最短路+KM匹配)</span><br><span class="line">4067Random Maze(难)[费用流]</span><br><span class="line">3947River Problem(难)[费用流]神奇费用流,流量不等式建图</span><br><span class="line">3046Pleasant sheep and big big wolf [最小割]</span><br><span class="line">1565方格取数(1)[最小割]</span><br><span class="line">1569方格取数(2)[最小割]</span><br><span class="line">3820Golden Eggs[最小割]方格加强</span><br><span class="line">3491Thieves[最小割]最小点割集</span><br><span class="line">3657Game[最小割]最大点权独立集</span><br><span class="line">3313Key Vertex[最小割]</span><br><span class="line">3251Being a Hero[最小割]</span><br><span class="line">3157Crazy Circuits[上下流]</span><br><span class="line">3002King of Destruction[全局最小割]</span><br><span class="line">3691Nubulsa Expo[全局最小割]</span><br><span class="line">【POJ】</span><br><span class="line">1087A Plug for UNIX  [最大流](可用二分匹配)</span><br><span class="line">1274The Perfect Stall [最大流](可用二分匹配)</span><br><span class="line">1325Machine Schedule[最大流](可用二分匹配)</span><br><span class="line">1698Alice&apos;s Chance[最大流](可用二分匹配)</span><br><span class="line">2239Selecting Courses[最大流](可用二分匹配)</span><br><span class="line">2446Chessboard[最大流](可用二分匹配) 好题啊</span><br><span class="line">2536Gopher II[最大流](可用二分匹配)</span><br><span class="line">2771Guardian of Decency[最大流]二分匹配最大独立集</span><br><span class="line">3041 Asteroids [最大流](简单二分匹配)</span><br><span class="line">2584 T-Shirt Gumbo [最大流](多重匹配)</span><br><span class="line">3189 Steady Cow Assignment(中等)[二分最大流](多重匹配)</span><br><span class="line">1149 PIGS  [最大流] 绝对经典的构图题</span><br><span class="line">1273 Drainage Ditches  [最大流](基础)</span><br><span class="line">1459 Power Network(基础)[最大流]</span><br><span class="line">3281 Dining [最大流]</span><br><span class="line">2112 Optimal Milking(基础)  [二分最大流]</span><br><span class="line">2289 Jamie&apos;s Contact Groups [二分最大流]</span><br><span class="line">2391 Ombrophobic Bovines(中等) [二分最大流]</span><br><span class="line">2455 Secret Milking Machine(基础) [二分最大流]</span><br><span class="line">3228 Gold Transportation [二分最大流](并查集)</span><br><span class="line">2699 The Maximum Number of Strong Kings(较难)  [枚举人数 + 最大流]</span><br><span class="line">3498March of the Penguins(中等)  [最大流]枚举汇点,满足点容量限制的网络流</span><br><span class="line">2987 Firing(较难)  [最大权闭包]</span><br><span class="line">1637 Sightseeing tour(Crazy)  [混合欧拉]</span><br><span class="line">2135 Farm Tour  [费用流] (来回最短路)</span><br><span class="line">2175Evacuation Plan(中等) [费用流] 消圈</span><br><span class="line">2195Going Home[费用流]</span><br><span class="line">2516 Minimum Cost [费用流]</span><br><span class="line">3422 Kaka&apos;s Matrix Travels(中等)  [费用流]拆点</span><br><span class="line">3680 Intervals(较难)  [费用流]经典,费用流+离散化</span><br><span class="line">3686The Windy&apos;s[费用流](KM匹配)</span><br><span class="line">3762The Bonus Salary![费用流]</span><br><span class="line">1815 Friendship(中等)  [最小割]最小点割集</span><br><span class="line">1966  Cable TV Network(中等)  [最小割]最小点割集</span><br><span class="line">2125 Destroying The Graph(难)  [最小割]最小点权覆盖</span><br><span class="line">3084 Panic Room(中等，好题)  [最小割]边连通度</span><br><span class="line">3204 Ikki&apos;s Story I - Road Reconstruction(基础) [最小割]求关键边</span><br><span class="line">3308 Paratroopers(较难) [最小割]乘积取对数,最小点权覆盖</span><br><span class="line">3436ACM Computer Factory[最小割]收集流,残留搜集找边</span><br><span class="line">3469 Dual Core CPU(中等)  [最小割]收集流</span><br><span class="line">3921Destroying the bus stations[最小割]点连通</span><br><span class="line">2396 Budget(中等)  [有源汇的上下界可行流]</span><br><span class="line">3155 Hard Life(很挑战一题)  [最大密度子图]</span><br><span class="line">2914Minimum Cut[无向图最小割]</span><br><span class="line">============================以下是dancing links系列============================</span><br><span class="line">1001Easy FindingPOJ-3740</span><br><span class="line">1002Power StationsHDOJ-3663</span><br><span class="line">1003Treasure MapZOJ-3209</span><br><span class="line">1004LampHDOJ-2828</span><br><span class="line">1005whosyourdaddyHDOJ-3498</span><br><span class="line">1006Bomberman - Just Search!HDOJ-3529</span><br><span class="line">1007Square DestroyerPOJ-1084</span><br><span class="line">1008MatrixHDOJ-2119</span><br><span class="line">1009DivisibilityHDOJ-3335</span><br><span class="line">1010RadarHDOJ-2295</span><br><span class="line">1011Fire stationHDOJ-3656</span><br><span class="line">1012Repair DepotsHDOJ-3156</span><br><span class="line">1013DominoesHDOJ-2518</span><br><span class="line">1014Street FighterHDOJ-3957</span><br><span class="line">1015Sudoku KillerHDOJ-1426</span><br><span class="line">1016SudokuPOJ-2676</span><br><span class="line">1017SudokuPOJ-3074</span><br><span class="line">1018SudokuPOJ-3076</span><br><span class="line">1019Su-Su-SudokuHDOJ-2780</span><br><span class="line">1020SudokuHDOJ-3111</span><br><span class="line">1021SudokuHDOJ-3909</span><br><span class="line">1022Squiggly SudokuHDOJ-4069</span><br><span class="line">1023Triangle War IIZOJ-3038</span><br><span class="line">1024A Puzzling ProblemHDOJ-1603</span><br><span class="line">1025Maximum CliqueHDOJ-1530</span><br><span class="line">hust1017 精确覆盖。</span><br><span class="line">fzu1686,nuaa1507 重复覆盖。</span><br><span class="line">hit2199,2882,2959 精确覆盖(数独)。</span><br><span class="line">SPOJ1771精确覆盖(N皇后问题)。</span><br><span class="line">poj3435</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备ACM比赛的时候，懵逼的发现自己竟然不知道怎么求解图论的最短路径问题，至此开始，收集一系列有关图论的知识体系以及大部分题目，力争这段时间完成，在说图论之前，我们首先要知道图论的定义包含哪些。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="Graph Theory" scheme="http://yoursite.com/tags/Graph-Theory/"/>
    
  </entry>
  
  <entry>
    <title>c结构指针</title>
    <link href="http://yoursite.com/2018/06/01/fifth/"/>
    <id>http://yoursite.com/2018/06/01/fifth/</id>
    <published>2018-06-01T06:01:28.201Z</published>
    <updated>2018-06-01T06:07:32.347Z</updated>
    
    <content type="html"><![CDATA[<p>  这篇文章内容介绍非常清楚，可以弄下来仅供参考。<br>指针结构与指针的关系亦有两重：其一是在定义结构时，将指针作为结构中的一个成员；其二是指向结构的指针（称为结构指针）。前者同一般的结构成员一样可直接进行访问，后者是本节讨论的重点。<br><a id="more"></a></p><blockquote><p>结构指针说明的一般形式是：<br>struct 结构类型名称 <em> 结构指针变量名；<br>例如：struct date </em> pdate, today;<br>说明了两个变量，一个是指向结构date的结构指针pdate，today是一个date结构变量。语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pdate = &amp;today;</span><br><span class="line">pdate today (struct date)</span><br><span class="line">　　year</span><br><span class="line">　　month</span><br><span class="line">　　day</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>  通过结构变量today访问其成员的操作，也可以用等价的指针形式表示：<br>today.year = 2001;　　等价于　　(<em>pdate).year = 2001;<br>由于运算符”</em>“的优先级比运算符”.”的优先级低，所以必须有”( )”将<em>pdate括起来。若省去括号，则含义就变成了”</em>(pdate.year)”。<br>在Ｃ语言中，通过结构指针访问成员可以采用运算符”-&gt;”进行操作，对于指向结构的指针，为了访问其成员可以采用下列语句形式：<br>结构指针-&gt;成员名;<br>这样，上面通过结构指针pdate访问成员year的操作就可以写成：<br>pdate-&gt;year = 2001;<br>如果结构指针p指向一个结构数组，那么对指针p的操作就等价于对数组下标的操作。<br>　　结构指针是指向一种结构类型的指针变量，它是结构在内存中的首地址，结构指针具有一般指针的特性，如在一定条件下两个指针可以进行比较，也可以与整数进行加减。但在指针操作时应注意：进行地址运算时的放大因子由所指向的结构的实际大小决定。</p></blockquote><h2 id="例11-7"><a href="#例11-7" class="headerlink" title="例11-7"></a>例11-7</h2><p>用结构指针改写加密程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">struct table</span><br><span class="line">&#123; char input, output;</span><br><span class="line">&#125; ;</span><br><span class="line">struct table translate[ ]=</span><br><span class="line">&#123; &apos;a&apos;, &apos;d&apos;, &apos;b&apos;, &apos;w&apos;, &apos;c&apos;, &apos;k&apos;, &apos;d&apos;, &apos;;&apos; , &apos;e&apos;, &apos;i&apos;,</span><br><span class="line">&apos;i&apos;, &apos;a&apos;, &apos;k&apos;, &apos;b&apos;, &apos;;&apos;, &apos;c&apos;, &apos;w&apos;, &apos;e&apos;</span><br><span class="line">&#125;; 　　　　　　/* 建立加密对照表 */</span><br><span class="line">main( )</span><br><span class="line">&#123; char ch;</span><br><span class="line">struct table *p, *pend; /* p和pend为指向结构table的指针 */</span><br><span class="line">pend = &amp; translate[ sizeof(translate)/sizeof(struct table)-1 ];</span><br><span class="line">/* pend指向结构数组translate的最后一个元素 */</span><br><span class="line">while ( (ch=getchar( )) != &apos;/n&apos;)</span><br><span class="line">&#123; for ( p=translate ; p-&gt;input!=ch &amp;&amp; p!=pend; p++ ) ;</span><br><span class="line">if ( p-&gt;input==ch ) </span><br><span class="line">putchar( p-&gt;output);</span><br><span class="line">else</span><br><span class="line">putchar (ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读者可以将两个程序对照阅读，体会结构指针特点。程序中用pend指向数组的最后一个元素。<br>由于结构指针和在结构中将指针作为成员，使得对于结构变量的运算和对成员的操作变得较为复杂。由于取内容的”*”与”.”和”-&gt;”运算符的优先级与结合性不同，使得对成员的访问和操作又增加了一层难度，再因为”++”和”–”运算所具有的”先操作”与”后操作”的特性，以及”++”和”–”运算的结合性，使得”++”和–”运算与结构操作混合在一起时，实际操作会更为复杂。</p><h2 id="例11-8"><a href="#例11-8" class="headerlink" title="例11-8"></a>例11-8</h2><blockquote><p>请分析程序的运算结果。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">struct s</span><br><span class="line">&#123; int x, *y; /* y: 结构中的成员是指向整型的指针 */</span><br><span class="line">&#125; *p; /* p: 指向结构的指针 */</span><br><span class="line">int data[5]=&#123;10, 20, 30, 40, 50,&#125;; /* data: 整型数组 */</span><br><span class="line">struct s array[5]=</span><br><span class="line">&#123; 100, &amp;data[0], 200, &amp;data[1], 300, &amp;data[2],</span><br><span class="line">400, &amp;data[3], 500, &amp;data[4]</span><br><span class="line">&#125;; /* array: 结构数组 */</span><br><span class="line">main ( )</span><br><span class="line">&#123; p=array; /* 指针p指向结构数组的首地址 */</span><br><span class="line">printf (&quot;For printer:/n&quot;);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x);</span><br><span class="line">printf (&quot;%d/n&quot;, (*p).x); </span><br><span class="line">printf (&quot;%d/n&quot;, *p-&gt;y);</span><br><span class="line">printf (&quot;%d/n&quot;, *(*p).y);</span><br><span class="line">printf (&quot;%d/n&quot;, ++p-&gt;x);</span><br><span class="line">printf (&quot;%d/n&quot;, (++p)-&gt;x);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x++);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x); </span><br><span class="line">printf (&quot;%d/n&quot;, ++ (*p-&gt;y));</span><br><span class="line">printf (&quot;%d/n&quot;, ++ * p-&gt;y); </span><br><span class="line">printf (&quot;%d/n&quot;, * ++ p-&gt;y);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x); </span><br><span class="line">printf (&quot;%d/n&quot;, * (++p)-&gt;y);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x); </span><br><span class="line">printf (&quot;%d/n&quot;, * p-&gt;y ++);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x); </span><br><span class="line">printf (&quot;%d/n&quot;, * (p-&gt;y) ++);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x); </span><br><span class="line">printf (&quot;%d/n&quot;, * p ++ -&gt;y);</span><br><span class="line">printf (&quot;%d/n&quot;, p-&gt;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结构数组array的初始化后的状态如图11.4所示。程序中指针操作的含义如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;x /* 取结构指针p指向的结构的成员x的值，输出 100 */</span><br><span class="line">(*p).x /* 取结构指针p的内容的成员x的值，功能同上，输出 100 */</span><br><span class="line">*p-&gt;y /* 取结构指针p的指针成员y的内容，输出 10 */</span><br><span class="line">*(*p).y /* 取结构指针p的内容的指针成员y的内容，功能同上，输出10 */</span><br><span class="line">++p-&gt;x /* p所指的x加1，x先加1后再输出 101 ，p不加1 */</span><br><span class="line">(++p)-&gt;x /* p先加1后再取x的值，x不加1，输出 200 */</span><br><span class="line">p-&gt;x++ /* 先取x的值后x再加1，输出 200 */</span><br><span class="line">p-&gt;x /* 输出 201 */</span><br><span class="line">++(*p-&gt;y) /* p所指的y的内容先加1，输出 21 ，p不加1，y也不加1 */</span><br><span class="line">++ *p-&gt;y /* 同上，由运算的结合性隐含了括号，输出 22 */</span><br><span class="line">* ++p-&gt;y /* y先加1后再取y的内容，输出30，p不加1，y的内容不加1 */</span><br><span class="line">p-&gt;x /* 输出 201 */</span><br><span class="line">*(++p)-&gt;y /* p先加1后取所指y的内容，输出 30 */</span><br><span class="line">p-&gt;x /* 输出 300 */</span><br><span class="line">*p-&gt;y ++ /* 取p所指的y的内容，输出 30，然后p所指的y加1 */</span><br><span class="line">p-&gt;x /* 输出 300 */</span><br><span class="line">*(p-&gt;y)++ /* 取p所指的y的内容，输出 40，然后p所指的y加1 */</span><br><span class="line">p-&gt;x /* 输出 300 */</span><br><span class="line">*p++-&gt;y /* 取p所指的y的内容，输出 50，然后p加1 */</span><br><span class="line">p-&gt;x /* 输出 400 */</span><br></pre></td></tr></table></figure><h2 id="例11-9"><a href="#例11-9" class="headerlink" title="例11-9"></a>例11-9</h2><p>可用一个结构表示学生的学号和成绩，编写程序，对班中30名学生按成绩进行排序，并输出排序后的学号、成绩和全班平均分。</p><figure class="highlight plain"><figcaption><span><stdio.h></stdio.h></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#define STNUM 30 /* 全班同学人数 */</span><br><span class="line">struct stuinf</span><br><span class="line">&#123; int stid; /* 学生学号 */</span><br><span class="line">int score; /* 学生成绩 */</span><br><span class="line">&#125; stu[STNUM]; /* stu: 结构数组 */</span><br><span class="line">main ( )</span><br><span class="line">&#123; struct stuinf *ptemp, /* ptemp:指向结构的指针, 临时变量 */</span><br><span class="line">*p[STNUM]; /* p:指向结构的指针构成的指针数组 */</span><br><span class="line">int i, j, k, sum=0; /* i,j,k:临时变量；sum:分数累计 */</span><br><span class="line">for (i=0; i&lt;=STNUM-1; i++) /* 输入学生的学号和成绩 */</span><br><span class="line">&#123; scanf (&quot;%d%d&quot;, &amp;stu[i].stid, &amp;stu[i].score); /* 输入学生的学号和成绩 */</span><br><span class="line">p[i] = &amp;stu[i];</span><br><span class="line">/* 指针数组p[i]的第i个指针(元素)指向结构数组的第i个元素 */</span><br><span class="line">sum += stu[i].score;　　 　 　/* 累计学生的分数 */</span><br><span class="line">&#125;</span><br><span class="line">for ( i=0; i&lt;=STNUM-2; i++ ) /* 排序操作 */</span><br><span class="line">&#123; k = i; /* k：在第i次循环中，指向当前最高分的指针在指针数组p中的下标 */</span><br><span class="line">for (j=i; j&lt;=STNUM-1; j++)</span><br><span class="line">if (p[k]-&gt;score &lt; p[j]-&gt;score) k=j;</span><br><span class="line">/* 查找当前最大值, k中存放最大值对应的指针在指针数组p中的下标 */</span><br><span class="line">if ( k!=i ) /* 当k不等于i时，交换两个指向结构的指针 */</span><br><span class="line">&#123; ptemp = p[i];</span><br><span class="line">p[i] = p[k];</span><br><span class="line">p[k] = ptemp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (i=0; i&lt;=STNUM-1; i++) /* 按排序顺序输出学号和成绩 */</span><br><span class="line">printf(&quot;%d,%d/n&quot;, (*p[i]).stid, p[i]-&gt;score);</span><br><span class="line">printf (&quot;average score = %d/n&quot;, sum/STNUM); /* 输出平均分 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　程序中使用了较为复杂的数据结构，包括：结构数组stu，指向结构的指针ptemp，由指向结构的指针构成的指针数组p。<br>程序在结构数组stu和指针数组p之间建立了对应的指针关系，从而为简化后续处理打下了良好的基础。在排序过程中，程序使用选择排序的思想，先查找确定当前的最大值，再进行一次有实效的数据交换。进行数据交换时，也没有交换结构数据本身，而是交换了指向结构数据的指针。在输出时，按照排序后指针的顺序，输出排序后的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  这篇文章内容介绍非常清楚，可以弄下来仅供参考。&lt;br&gt;指针结构与指针的关系亦有两重：其一是在定义结构时，将指针作为结构中的一个成员；其二是指向结构的指针（称为结构指针）。前者同一般的结构成员一样可直接进行访问，后者是本节讨论的重点。&lt;br&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://yoursite.com/categories/c-c/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>有关java中@的代指--注解</title>
    <link href="http://yoursite.com/2018/06/01/java@/"/>
    <id>http://yoursite.com/2018/06/01/java@/</id>
    <published>2018-06-01T05:35:20.013Z</published>
    <updated>2018-06-01T05:50:57.584Z</updated>
    
    <content type="html"><![CDATA[<p>java中的注解，java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标准(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。<br><a id="more"></a></p><h2 id="什么是java注解"><a href="#什么是java注解" class="headerlink" title="什么是java注解"></a>什么是java注解</h2><blockquote><p> 注解，顾名思义，注解,就是对某一事物进行添加注释说明，会存放一些信息，这些信息可能对以后某个时段来说是很有用处的。<br> Java注解又叫java标注，java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标准(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。</p></blockquote><h2 id="自定义Java标注"><a href="#自定义Java标注" class="headerlink" title="自定义Java标注"></a>自定义Java标注</h2><h3 id="为什么要自定义注解"><a href="#为什么要自定义注解" class="headerlink" title="为什么要自定义注解"></a>为什么要自定义注解</h3><blockquote><p>  Java从1.5版本以后默认内置三个标注：<br>Ø @Override:只能用在方法之上的，用来告诉别人这一个方法是改写父类的。<br>Ø @Deprecated:建议别人不要使用旧的API的时候用的,编译的时候会用产生警告信息,可以设定在程序里的所有的元素上.<br>Ø @SuppressWarnings:这一个类型可以来暂时把一些警告信息消息关闭.<br>但是，仅仅这三个标注是不能满足我们开发时一些需求的。所以java允许我们自定义注解来使用。</p></blockquote><h3 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h3><blockquote><p>自定义步骤大致分为两步：<br>  1通过@interface关键字(注意，不是interface，是@interace)声明注解名称，以及注解的成员属性或者叫做注解的参数。<br>  2使用java内置的四个元注解对这个自定义标注的功能和范围进行一些限制<br>问题来了，什么是元注解？</p></blockquote><h3 id="什么是元注解"><a href="#什么是元注解" class="headerlink" title="什么是元注解"></a>什么是元注解</h3><blockquote><p>元注解，就是定义注解的注解，也就是说这些元注解是的作用就是专门用来约束其它注解的注解。请区别上面那三个注解，他们也是通过元注解定义而来的。<br>元注解有哪些呢，主要有四个@Target,@Retention,@Documented,@Inherited？<br>元注解有：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Target,@Retention,@Documented,@Inherited </span><br><span class="line">@Target 表示该注解用于什么地方，可能的 ElemenetType 参数包括： </span><br><span class="line">ElemenetType.CONSTRUCTOR 构造器声明 </span><br><span class="line">ElemenetType.FIELD 域声明（包括 enum 实例） </span><br><span class="line">ElemenetType.LOCAL_VARIABLE 局部变量声明 </span><br><span class="line">ElemenetType.METHOD 方法声明 </span><br><span class="line">ElemenetType.PACKAGE 包声明 </span><br><span class="line">ElemenetType.PARAMETER 参数声明 </span><br><span class="line">ElemenetType.TYPE 类，接口（包括注解类型）或enum声明  </span><br><span class="line">@Retention 表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括： </span><br><span class="line">RetentionPolicy.SOURCE 注解将被编译器丢弃 </span><br><span class="line">RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 </span><br><span class="line">RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。   </span><br><span class="line">@Documented 将此注解包含在 javadoc 中 </span><br><span class="line">@Inherited 允许子类继承父类中的注解</span><br></pre></td></tr></table></figure><h3 id="自定义及使用注解示例"><a href="#自定义及使用注解示例" class="headerlink" title="自定义及使用注解示例"></a>自定义及使用注解示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//自定义一个类级别的标注Description </span><br><span class="line">package lighter.javaeye.com;</span><br><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">@Target(ElementType.TYPE)//这个标注应用于类</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)//标注会一直保留到运行时</span><br><span class="line">@Documented//将此注解包含在javadoc中</span><br><span class="line">public @interface Description &#123;</span><br><span class="line">String value();</span><br><span class="line">&#125; </span><br><span class="line">再定义个方法级别的注解Name</span><br><span class="line">package lighter.javaeye.com;</span><br><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target; </span><br><span class="line">//注意这里的@Target与@Description里的不同,参数成员也不同</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Name &#123;</span><br><span class="line">String originate();</span><br><span class="line">String community();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   然后使用以上两个注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package lighter.javaeye.com; </span><br><span class="line">  @Description(value=&quot;javaeye,做最棒的软件开发交流社区&quot;)</span><br><span class="line">  public class JavaEyer &#123;</span><br><span class="line">  @Name(originate=&quot;创始人:robbin&quot;,community=&quot;javaEye&quot;)</span><br><span class="line">  public String getName()</span><br><span class="line">  &#123;</span><br><span class="line">     return null;</span><br><span class="line">  &#125;        </span><br><span class="line">  @Name(originate=&quot;创始人:江南白衣&quot;,community=&quot;springside&quot;)</span><br><span class="line">  public String getName2()</span><br><span class="line">  &#123;</span><br><span class="line">     return &quot;借用两位的id一用,写这一个例子,请见谅!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>说明：其中标注“@Description(value=”javaeye,做最棒的软件开发交流社区”)”，可以写成“@Description(“javaeye,做最棒的软件开发交流社区”) ”，结果也是一样的。因为Description标注定义的时候其参数(或者说属性)为value。而value比较特殊，它在被指定参数的时候可以不用显示的写出来。当然如果定义的时候参数名不是value而是其它的比如des，那么使用注解的时候，必须显示写出参数名，然后再赋值：@Description(Des=”xxx”)</strong><br>提取出注解的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> package lighter.javaeye.com; </span><br><span class="line"> import java.lang.reflect.Method;</span><br><span class="line"> import java.util.HashSet;</span><br><span class="line"> import java.util.Set;</span><br><span class="line"> public class TestAnnotation &#123;</span><br><span class="line">   /*** author lighter* 说明:具体关天Annotation的API的用法请参见javaDoc文档*/</span><br><span class="line">  public static void main(String[] args) throws Exception &#123;</span><br><span class="line">   String CLASS_NAME = &quot;lighter.javaeye.com.JavaEyer&quot;;</span><br><span class="line">   Class test = Class.forName(CLASS_NAME);</span><br><span class="line">   Method[] method = test.getMethods();</span><br><span class="line">   boolean flag = test.isAnnotationPresent(Description.class);</span><br><span class="line">  if(flag)</span><br><span class="line">  &#123;</span><br><span class="line">   Description des = (Description)test.getAnnotation(Description.class);</span><br><span class="line">   System.out.println(&quot;描述:&quot;+des.value());</span><br><span class="line">   System.out.println(&quot;-----------------&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">   //把JavaEyer这一类有利用到@Name的全部方法保存到Set中去</span><br><span class="line">   Set&lt;Method&gt; set = new HashSet&lt;Method&gt;();</span><br><span class="line">   for(int i=0;i&lt;method.length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   boolean otherFlag = method[i].isAnnotationPresent(Name.class);</span><br><span class="line">   if(otherFlag) set.add(method[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   for(Method m: set)</span><br><span class="line">   &#123;</span><br><span class="line">   Name name = m.getAnnotation(Name.class);</span><br><span class="line">   System.out.println(name.originate());</span><br><span class="line">   System.out.println(&quot;创建的社区:&quot;+name.community());</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p>所有的Annotation会自动继承java.lang.annotation这一个接口,所以不能再去继承别的类或是接口.<br>   最重要的一点,Annotation类型里面的参数该怎么设定:<br>   第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型.<br>   第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中的注解，java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标准(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。&lt;br&gt;
    
    </summary>
    
      <category term="JAVA SE" scheme="http://yoursite.com/categories/JAVA-SE/"/>
    
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://yoursite.com/2018/06/01/forth/"/>
    <id>http://yoursite.com/2018/06/01/forth/</id>
    <published>2018-06-01T05:24:28.434Z</published>
    <updated>2018-06-01T05:25:52.821Z</updated>
    
    <content type="html"><![CDATA[<p>我们总是探讨求解最优的问题，却总是忽略了求解的过程，如何达到最优化的问题，才是我们应该研究的目的，综上贪心算法便给我们提供了一点思路。<br><a id="more"></a></p><h2 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h2><blockquote><p> 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。<br> 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。<br>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p></blockquote><h2 id="二、贪心算法的基本思路："><a href="#二、贪心算法的基本思路：" class="headerlink" title="二、贪心算法的基本思路："></a>二、贪心算法的基本思路：</h2><blockquote><p>1.建立数学模型来描述问题。<br>2.把求解的问题分成若干个子问题。<br>3.对每一子问题求解，得到子问题的局部最优解。<br>4.把子问题的解局部最优解合成原来解问题的一个解。</p></blockquote><h2 id="三、贪心算法适用的问题"><a href="#三、贪心算法适用的问题" class="headerlink" title="三、贪心算法适用的问题"></a>三、贪心算法适用的问题</h2><blockquote><p>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。<br>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p></blockquote><h2 id="四、贪心算法的实现框架"><a href="#四、贪心算法的实现框架" class="headerlink" title="四、贪心算法的实现框架"></a>四、贪心算法的实现框架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从问题的某一初始解出发；</span><br><span class="line">while （能朝给定总目标前进一步）</span><br><span class="line">&#123; </span><br><span class="line">  利用可行的决策，求出可行解的一个解元素；</span><br><span class="line">&#125;</span><br><span class="line">由所有解元素组合成问题的一个可行解；</span><br></pre></td></tr></table></figure><h2 id="五、贪心策略的选择"><a href="#五、贪心策略的选择" class="headerlink" title="五、贪心策略的选择"></a>五、贪心策略的选择</h2><blockquote><p> 因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p></blockquote><h2 id="六、例题分析"><a href="#六、例题分析" class="headerlink" title="六、例题分析"></a>六、例题分析</h2><blockquote><p>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。</p></blockquote><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><blockquote><p>有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。<br>要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<br>物品 A B C D E F G<br>重量 35 30 60 50 40 10 25<br>价值 10 40 30 50 35 40 30<br>分析：<br>目标函数： ∑pi最大<br>约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)<br>（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？<br>（2）每次挑选所占重量最小的物品装入是否能得到最优解？<br>（3）每次选取单位重量价值最大的物品，成为解本题的策略。<br>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。<br>贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。<br>可惜的是，它需要证明后才能真正运用到题目的算法中。<br>一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。<br>对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：<br>（1）贪心策略：选取价值最大者。反例：<br>W=30<br>物品：A B C<br>重量：28 12 12<br>价值：30 20 20<br>根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。<br>（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。<br>（3）贪心策略：选取单位重量价值最大的物品。反例：<br>W=30<br>物品：A B C<br>重量：28 20 10<br>价值：28 20 10<br>根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。<br>值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。比如，求最小生成树的Prim算法和Kruskal算法都是漂亮的贪心算法。</p></blockquote><h3 id="均分纸牌"><a href="#均分纸牌" class="headerlink" title="均分纸牌"></a>均分纸牌</h3><blockquote><p>有N堆纸牌，编号分别为1，2，…，n。每堆上有若干张,但纸牌总数必为n的倍数.可以在任一堆上取若干张纸牌,然后移动。移牌的规则为：在编号为1上取的纸牌，只能移到编号为2的堆上；在编号为n的堆上取的纸牌，只能移到编号为n-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。例如：n=4，4堆纸牌分别为：① 9 ② 8 ③ 17 ④ 6 移动三次可以达到目的：从③取4张牌放到④ 再从③区3张放到②然后从②去1张放到①。<br>输入输出样例：4<br>9 8 17 6<br>屏幕显示：3<br>算法分析：设a[i]为第I堆纸牌的张数（0&lt;=I&lt;=n），v为均分后每堆纸牌的张数，s为最小移动次数。<br>我们用贪心算法，按照从左到右的顺序移动纸牌。如第I堆的纸牌数不等于平均值，则移动一次（即s加1），分两种情况移动：<br>1．若a[i]&gt;v，则将a[i]-v张从第I堆移动到第I+1堆；<br>2．若a[i]&lt;v，则将v-a[i]张从第I+1堆移动到第I堆。<br>为了设计的方便，我们把这两种情况统一看作是将a[i]-v从第I堆移动到第I+1堆，移动后有a[i]=v; a[I+1]=a[I+1]+a[i]-v.<br>在从第I+1堆取出纸牌补充第I堆的过程中可能回出现第I+1堆的纸牌小于零的情况。<br>如n=3，三堆指派数为1 2 27 ，这时v=10，为了使第一堆为10，要从第二堆移9张到第一堆，而第二堆只有2张可以移，这是不是意味着刚才使用贪心法是错误的呢？<br>我们继续按规则分析移牌过程，从第二堆移出9张到第一堆后，第一堆有10张，第二堆剩下-7张，在从第三堆移动17张到第二堆，刚好三堆纸牌都是10，最后结果是对的，我们在移动过程中，只是改变了移动的顺序，而移动次数不便，因此此题使用贪心法可行的。<br>Java源程序：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Greedy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  int n = 0, avg =0, s = 0;</span><br><span class="line">  Scanner scanner = new Scanner(System.in);</span><br><span class="line">  ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line">  System.out.println(&quot;Please input the number of heaps:&quot;);</span><br><span class="line">  n = scanner.nextInt();</span><br><span class="line">  System.out.println(&quot;Please input heap number:&quot;);</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">   array.add(scanner.nextInt());</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0; i &lt; array.size(); i ++)&#123;</span><br><span class="line">   avg += array.get(i);</span><br><span class="line">  &#125;</span><br><span class="line">  avg = avg/array.size();</span><br><span class="line">  System.out.println(array.size());</span><br><span class="line">  System.out.println(avg);</span><br><span class="line">  for(int i = 0; i &lt; array.size()-1; i ++)&#123;</span><br><span class="line">   s++;</span><br><span class="line">   array.set(i+1, array.get(i+1)+array.get(i)-avg);   </span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(&quot;s:&quot; + s);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用贪心算法解题，需要解决两个问题：<br>一是问题是否适合用贪心法求解。我们看一个找币的例子，如果一个货币系统有三种币值，面值分别为一角、五分和一分，求最小找币数时，可以用贪心法求解；如果将这三种币值改为一角一分、五分和一分，就不能使用贪心法求解。用贪心法解题很方便，但它的适用范围很小，判断一个问题是否适合用贪心法求解，目前还没有一个通用的方法，在信息学竞赛中，需要凭个人的经验来判断。<br>二是确定了可以用贪心算法之后，如何选择一个贪心标准，才能保证得到问题的最优解。在选择贪心标准时，我们要对所选的贪心标准进行验证才能使用，不要被表面上看似正确的贪心标准所迷惑，如下面的例子。</p></blockquote><h3 id="最大整数"><a href="#最大整数" class="headerlink" title="最大整数"></a>最大整数</h3><blockquote><p>设有n个正整数，将它们连接成一排，组成一个最大的多位整数。<br>例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。<br>又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。<br>输入：n<br>N个数<br>输出：连成的多位数<br>算法分析：此题很容易想到使用贪心法，在考试时有很多同学把整数按从大到小的顺序连接起来，测试题目的例子也都符合，但最后测试的结果却不全对。按这种标准，我们很容易找到反例：12，121应该组成12121而非12112，那么是不是相互包含的时候就从小到大呢？也不一定，如12，123就是12312而非12123，这种情况就有很多种了。是不是此题不能用贪心法呢？<br>其实此题可以用贪心法来求解，只是刚才的标准不对，正确的标准是：先把整数转换成字符串，然后在比较a+b和b+a，如果a+b&gt;=b+a，就把a排在b的前面，反之则把a排在b的后面。</p></blockquote><p>java源程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  String str = &quot;&quot;;</span><br><span class="line">  ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();</span><br><span class="line">  Scanner in = new Scanner(System.in);</span><br><span class="line">  System.out.println(&quot;Please input the number of data:&quot;);</span><br><span class="line">  int n = in.nextInt();</span><br><span class="line">  System.out.println(&quot;Please input the data:&quot;);</span><br><span class="line">  while (n-- &gt; 0) &#123;</span><br><span class="line">   array.add(in.next());   </span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 0; i &lt; array.size(); i ++)</span><br><span class="line">   for(int j = i + 1; j &lt; array.size(); j ++)&#123;</span><br><span class="line">   if((array.get(i) + array.get(j)).compareTo(array.get(j) + array.get(i)) &lt; 0)&#123;</span><br><span class="line">   String temp = array.get(i);</span><br><span class="line">   array.set(i, array.get(j));</span><br><span class="line">   array.set(j, temp);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">  for(int i = 0; i &lt; array.size(); i ++)&#123;</span><br><span class="line">   str += array.get(i);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(&quot;str=:&quot;+str);  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>贪心算法所作的选择可以依赖于以往所作过的选择，但决不依赖于将来的选择，也不依赖于子问题的解，因此贪心算法与其他算法相比具有一定的速度优势。如果一个问题可以同时用几种方法解决，贪心算法应该是最好的选择之一。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们总是探讨求解最优的问题，却总是忽略了求解的过程，如何达到最优化的问题，才是我们应该研究的目的，综上贪心算法便给我们提供了一点思路。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>指针-C</title>
    <link href="http://yoursite.com/2018/06/01/third/"/>
    <id>http://yoursite.com/2018/06/01/third/</id>
    <published>2018-06-01T04:09:35.403Z</published>
    <updated>2018-06-01T04:29:16.884Z</updated>
    
    <content type="html"><![CDATA[<p>指针是Ｃ语言中广泛使用的一种数据类型。 运用指针编程是Ｃ语言最主要的风格之一。利用指针变量可以表示各种数据结构； 能很方便地使用数组和字符串； 并能象汇编语言一样处理内存地址，从而编出精练而高效的程序。指针极大地丰富了Ｃ语言的功能。 学习指针是学习Ｃ语言中最重要的一环， 能否正确理解和使用指针是我们是否掌握Ｃ语言的一个标志。同时， 指针也是Ｃ语言中最为困难的一部分，在学习中除了要正确理解基本概念，还必须要多编程，上机调试。只要作到这些，指针也是不难掌握的。<br><a id="more"></a></p><blockquote><p>　　指针的基本概念 在计算机中，所有的数据都是存放在存储器中的。 一般把存储器中的一个字节称为一个内存单元， 不同的数据类型所占用的内存单元数不等，如整型量占2个单元，字符量占1个单元等， 在第二章中已有详细的介绍。为了正确地访问这些内存单元， 必须为每个内存单元编上号。 根据一个内存单元的编号即可准确地找到该内存单元。内存单元的编号也叫做地址。 既然根据内存单元的编号或地址就可以找到所需的内存单元，所以通常也把这个地址称为指针。 内存单元的指针和内存单元的内容是两个不同的概念。 可以用一个通俗的例子来说明它们之间的关系。我们到银行去存取款时， 银行工作人员将根据我们的帐号去找我们的存款单， 找到之后在存单上写入存款、取款的金额。在这里，帐号就是存单的指针， 存款数是存单的内容。对于一个内存单元来说，单元的地址即为指针， 其中存放的数据才是该单元的内容。在Ｃ语言中， 允许用一个变量来存放指针，这种变量称为指针变量。因此， 一个指针变量的值就是某个内存单元的地址或称为某内存单元的指针。图中，设有字符变量C，其内容为“K”(ASCII码为十进制数 75)，C占用了011A号单元(地址用十六进数表示)。设有指针变量P，内容为011A， 这种情况我们称为P指向变量C，或说P是指向变量C的指针。 严格地说，一个指针是一个地址， 是一个常量。而一个指针变量却可以被赋予不同的指针值，是变。 但在常把指针变量简称为指针。为了避免混淆，我们中约定：“指针”是指地址， 是常量，“指针变量”是指取值为地址的变量。 定义指针的目的是为了通过指针去访问内存单元。<br>　<br>　　 既然指针变量的值是一个地址， 那么这个地址不仅可以是变量的地址， 也可以是其它数据结构的地址。在一个指针变量中存放一<br>个数组或一个函数的首地址有何意义呢？ 因为数组或函数都是连续存放的。通过访问指针变量取得了数组或函数的首地址， 也就找到了该数组或函数。这样一来， 凡是出现数组，函数的地方都可以用一个指针变量来表示， 只要该指针变量中赋予数组或函数的首地址即可。这样做， 将会使程序的概念十分清楚，程序本身也精练，高效。在Ｃ语言中， 一种数据类型或数据结构往往都占有一组连续的内存单元。 用“地址”这个概念并不能很好地描述一种数据类型或数据结构， 而“指针”虽然实际上也是一个地址，但它却是一个数据结构的首地址， 它是“指向”一个数据结构的，因而概念更为清楚，表示更为明确。 这也是引入“指针”概念的一个重要原因。</p></blockquote><h2 id="指针变量的类型说明"><a href="#指针变量的类型说明" class="headerlink" title="指针变量的类型说明"></a>指针变量的类型说明</h2><p>对指针变量的类型说明包括三个内容：<br>(1)指针类型说明，即定义变量为一个指针变量；<br>(2)指针变量名；<br>(3)变量值(指针)所指向的变量的数据类型。<br>其一般形式为： 类型说明符 ※变量名；<br>其中，※表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示本指针变量所指向的变量的数据类型。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int ※p1;/※表示p1是一个指针变量，它的值是某个整型变量的地址。 </span><br><span class="line">或者说p1指向一个整型变量。至于p1究竟指向哪一个整型变量， 应由向p1赋予的地址来决定。※/</span><br><span class="line">staic int ※p2; /※p2是指向静态整型变量的指针变量※/</span><br><span class="line">float ※p3; /※p3是指向浮点变量的指针变量※/</span><br><span class="line">char ※p4; /※p4是指向字符变量的指针变量※/</span><br></pre></td></tr></table></figure></p><p>应该注意的是，一个指针变量只能指向同类型的变量，如P3 只能指向浮点变量，不能时而指向一个浮点变量， 时而又指向一个字符变量。</p><h2 id="指针变量的赋值"><a href="#指针变量的赋值" class="headerlink" title="指针变量的赋值"></a>指针变量的赋值</h2><p>　　指针变量同普通变量一样，使用之前不仅要定义说明， 而且必须赋予具体的值。未经赋值的指针变量不能使用， 否则将造成系统混乱，甚至死机。指针变量的赋值只能赋予地址， 决不能赋予任何其它数据，否则将引起错误。在Ｃ语言中， 变量的地址是由编译系统分配的，对用户完全透明，用户不知道变量的具体地址。 Ｃ语言中提供了地址运算符&amp;来表示变量的地址。其一般形式为： &amp; 变量名； 如&amp;a变示变量a的地址，&amp;b表示变量b的地址。 变量本身必须预先说明。设有指向整型变量的指针变量p，如要把整型变量a 的地址赋予p可以有以下两种方式：</p><blockquote><p>(1)指针变量初始化的方法 int a;<br>int ※p=&a;<br>(2)赋值语句的方法 int a;<br>int ※p;<br>p=&a;<br>不允许把一个数赋予指针变量，故下面的赋值是错误的： int ※p;p=1000; 被赋值的指针变量前不能再加“※”说明符，如写为※p=&amp;a 也是错误的</p><p>指针变量的运算</p><p>指针变量可以进行某些运算，但其运算的种类是有限的。 它只能进行赋值运算和部分算术运算及关系运算。</p></blockquote><h4 id="1-指针运算符"><a href="#1-指针运算符" class="headerlink" title="1.指针运算符"></a>1.指针运算符</h4><blockquote><p>(1)取地址运算符&amp;<br>　　 取地址运算符&amp;是单目运算符，其结合性为自右至左，其功能是取变量的地址。在scanf函数及前面介绍指针变量赋值中，我们已经了解并使用了&amp;运算符。</p><p>(2)取内容运算符※<br>　　 取内容运算符※是单目运算符，其结合性为自右至左，用来表示指针变量所指的变量。在※运算符之后跟的变量必须是指针变量。需要注意的是指针运算符※和指针变量说明中的指针说明符※ 不是一回事。在指针变量说明中，“※”是类型说明符，表示其后的变量是指针类型。而表达式中出现的“※”则是一个运算符用以表示指针变量所指的变量。<br>表示指针变量p取得了整型变量a的地址。本语句表示输出变量a的值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a=5,※p=&amp;a;</span><br><span class="line">printf (&quot;%d&quot;,※p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-指针变量的运算"><a href="#2-指针变量的运算" class="headerlink" title="2.指针变量的运算"></a>2.指针变量的运算</h3><p>(1)赋值运算</p><blockquote><p>指针变量的赋值运算有以下几种形式：<br>①指针变量初始化赋值，前面已作介绍。</p><p>②把一个变量的地址赋予指向相同数据类型的指针变量。例如：<br>int a,※pa;<br>pa=&a; /※把整型变量a的地址赋予整型指针变量pa※/</p><p>③把一个指针变量的值赋予指向相同类型变量的另一个指针变量。如：<br>int a,※pa=&amp;a,※pb;<br>pb=pa; /※把a的地址赋予指针变量pb※/<br>由于pa,pb均为指向整型变量的指针变量，因此可以相互赋值。 ④把数组的首地址赋予指向数组的指针变量。<br>例如： int a[5],※pa;<br>pa=a; (数组名表示数组的首地址，故可赋予指向数组的指针变量pa)<br>也可写为：<br>pa=&amp;a[0]; /※数组第一个元素的地址也是整个数组的首地址，<br>也可赋予pa※/<br>当然也可采取初始化赋值的方法：<br>int a[5],※pa=a;</p><p>⑤把字符串的首地址赋予指向字符类型的指针变量。例如： char ※pc;pc=”c language”;或用初始化赋值的方法写为： char ※pc=”C Language”; 这里应说明的是并不是把整个字符串装入指针变量， 而是把存放该字符串的字符数组的首地址装入指针变量。 在后面还将详细介绍。</p><p>⑥把函数的入口地址赋予指向函数的指针变量。例如： int (※pf)();pf=f; /※f为函数名※/</p></blockquote><p>(2)加减算术运算　　</p><blockquote><p>对于指向数组的指针变量，可以加上或减去一个整数n。设pa是指向数组a的指针变量，则pa+n,pa-n,pa++,++pa,pa–,–pa 运算都是合法的。指针变量加或减一个整数n的意义是把指针指向的当前位置(指向某数组元素)向前或向后移动n个位置。应该注意，数组指针变量向前或向后移动一个位置和地址加1或减1 在概念上是不同的。因为数组可以有不同的类型， 各种类型的数组元素所占的字节长度是不同的。如指针变量加1，即向后移动1 个位置表示指针变量指向下一个数据元素的首地址。而不是在原地址基础上加1。<br>例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[5],※pa;</span><br><span class="line">pa=a; /※pa指向数组a，也是指向a[0]※/</span><br><span class="line">pa=pa+2; /※pa指向a[2]，即pa的值为&amp;pa[2]※/</span><br></pre></td></tr></table></figure><blockquote><p>指针变量的加减运算只能对数组指针变量进行， 对指向其它类型变量的指针变量作加减运算是毫无意义的。两个指针变量之间的运算只有指向同一数组的两个指针变量之间才能进行运算， 否则运算毫无意义。</p><p>①两指针变量相减<br>两指针变量相减所得之差是两个指针所指数组元素之间相差的元素个数。实际上是两个指针值(地址) 相减之差再除以该数组元素的长度(字节数)。例如pf1和pf2 是指向同一浮点数组的两个指针变量，设pf1的值为2010H，pf2的值为2000H，而浮点数组每个元素占4个字节，所以pf1-pf2的结果为(2000H-2010H)/4=4，表示pf1和 pf2之间相差4个元素。两个指针变量不能进行加法运算。 例如， pf1+pf2是什么意思呢?毫无实际意义。</p></blockquote><blockquote><p>②两指针变量进行关系运算<br>指向同一数组的两指针变量进行关系运算可表示它们所指数组元素之间的关系。例如：<br>pf1==pf2表示pf1和pf2指向同一数组元素<br>pf1&gt;pf2表示pf1处于高地址位置<br>pf1&lt;pf2表示pf2处于低地址位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a=10,b=20,s,t,※pa,※pb;</span><br><span class="line">pa=&amp;a;</span><br><span class="line">pb=&amp;b;</span><br><span class="line">s=※pa+※pb;</span><br><span class="line">t=※pa※※pb;</span><br><span class="line">printf(&quot;a=%d/nb=%d/na+b=%d/na※b=%d/n&quot;,a,b,a+b,a※b);</span><br><span class="line">printf(&quot;s=%d/nt=%d/n&quot;,s,t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>……<br>说明pa,pb为整型指针变量<br>给指针变量pa赋值，pa指向变量a。<br>给指针变量pb赋值，pb指向变量b。<br>本行的意义是求a+b之和，(※pa就是a，※pb就是b)。<br>本行是求a※b之积。<br>输出结果。<br>输出结果。<br>……</p><blockquote><p>指针变量还可以与0比较。设p为指针变量，则p==0表明p是空指针，它不指向任何变量；p!=0表示p不是空指针。空指针是由对指针变量赋予0值而得到的。例如： #define NULL 0　int ※p=NULL; 对指针变量赋0值和不赋值是不同的。指针变量未赋值时，可以是任意值，是不能使用的。否则将造成意外错误。而指针变量赋0值后，则可以使用，只是它不指向具体的变量而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a,b,c,※pmax,※pmin;</span><br><span class="line">printf(&quot;input three numbers:/n&quot;);</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">if(a&gt;b)&#123;</span><br><span class="line">pmax=&amp;a;</span><br><span class="line">pmin=&amp;b;&#125;</span><br><span class="line">else&#123;</span><br><span class="line">pmax=&amp;b;</span><br><span class="line">pmin=&amp;a;&#125;</span><br><span class="line">if(c&gt;※pmax) pmax=&amp;c;</span><br><span class="line">if(c&lt;※pmin) pmin=&amp;c;</span><br><span class="line">printf(&quot;max=%d/nmin=%d/n&quot;,※pmax,※pmin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>……<br>pmax,pmin为整型指针变量。<br>输入提示。<br>输入三个数字。<br>如果第一个数字大于第二个数字．．．<br>指针变量赋值<br>指针变量赋值</p><p>指针变量赋值<br>指针变量赋值<br>判断并赋值<br>判断并赋值<br>输出结果<br>……</p><h5 id="数组指针变量的说明和使用"><a href="#数组指针变量的说明和使用" class="headerlink" title="数组指针变量的说明和使用"></a>数组指针变量的说明和使用</h5><blockquote><p>　　指向数组的指针变量称为数组指针变量。 在讨论数组指针变量的说明和使用之前，我们先明确几个关系。<br>一个数组是由连续的一块内存单元组成的。 数组名就是这块连续内存单元的首地址。一个数组也是由各个数组元素(下标变量) 组成的。每个数组元素按其类型不同占有几个连续的内存单元。 一个数组元素的首地址也是指它所占有的几个内存单元的首地址。 一个指针变量既可以指向一个数组，也可以指向一个数组元素， 可把数组名或第一个元素的地址赋予它。如要使指针变量指向第i号元素可以把i元素的首地址赋予它或把数组名加i赋予它。</p><p>　　设有实数组a，指向a的指针变量为pa，从图6.3中我们可以看出有以下关系：<br>pa,a,&amp;a[0]均指向同一单元，它们是数组a的首地址，也是0 号元素a[0]的首地址。pa+1,a+1,&amp;a[1]均指向1号元素a[1]。类推可知a+i,a+i,&amp;a[i]<br>指向i号元素a[i]。应该说明的是pa是变量，而a,&amp;a[i]都是常量。在编程时应予以注意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a[5],i;</span><br><span class="line">for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">a[i]=i;</span><br><span class="line">printf(&quot;a[%d]=%d/n&quot;,i,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;/n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>…….<br>主函数<br>定义一个整型数组和一个整型变量<br>循环语句<br>给数组赋值<br>打印每一个数组的值<br>……<br>输出换行<br>……<br>※※数组指针变量说明的一般形式为：<br>类型说明符 ※ 指针变量名<br>　　 其中类型说明符表示所指数组的类型。 从一般形式可以看出指向数组的指针变量和指向普通变量的指针变量的说明是相同的。<br>引入指针变量后，就可以用两种方法来访问数组元素了。<br>　　 第一种方法为下标法，即用a[i]形式访问数组元素。 在第四章中介绍数组时都是采用这种方法。<br>　　 第二种方法为指针法，即采用※(pa+i)形式，用间接访问的方法来访问数组元素。※※<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a[5],i,※pa;</span><br><span class="line">pa=a;</span><br><span class="line">for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">※pa=i;</span><br><span class="line">pa++;</span><br><span class="line">&#125;</span><br><span class="line">pa=a;</span><br><span class="line">for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">printf(&quot;a[%d]=%d/n&quot;,i,※pa);</span><br><span class="line">pa++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>……<br>主函数<br>定义整型数组和指针<br>将指针pa指向数组a<br>循环<br>将变量i的值赋给由指针pa指向的a[]的数组单元<br>将指针pa指向a[]的下一个单元<br>……<br>指针pa重新取得数组a的首地址<br>循环<br>用数组方式输出数组a中的所有元素<br>将指针pa指向a[]的下一个单元<br>……<br>……<br>下面，另举一例，该例与上例本意相同，但是实现方式不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int a[5],i,※pa=a;</span><br><span class="line">for(i=0;i&lt;5;)&#123;</span><br><span class="line">※pa=i;</span><br><span class="line">printf(&quot;a[%d]=%d/n&quot;,i++,※pa++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主函数<br>定义整型数组和指针，并使指针指向数组a<br>循环<br>将变量i的值赋给由指针pa指向的a[]的数组单元<br>用指针输出数组a中的所有元素，同时指针pa指向a[]的下一个单元<br>……<br>……</p><h5 id="数组名和数组指针变量作函数参数"><a href="#数组名和数组指针变量作函数参数" class="headerlink" title="数组名和数组指针变量作函数参数"></a>数组名和数组指针变量作函数参数</h5><blockquote><p>在第五章中曾经介绍过用数组名作函数的实参和形参的问题。在学习指针变量之后就更容易理解这个问题了。 数组名就是数组的首地址，实参向形参传送数组名实际上就是传送数组的地址， 形参得到该地址后也指向同一数组。 这就好象同一件物品有两个彼此不同的名称一样。同样，指针变量的值也是地址， 数组指针变量的值即为数组的首地址，当然也可作为函数的参数使用。※※</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">float aver(float ※pa);</span><br><span class="line">main()&#123;</span><br><span class="line">float sco[5],av,※sp;</span><br><span class="line">int i;</span><br><span class="line">sp=sco;</span><br><span class="line">printf(&quot;/ninput 5 scores:/n&quot;);</span><br><span class="line">for(i=0;i&lt;5;i++) scanf(&quot;%f&quot;,&amp;sco[i]);</span><br><span class="line">av=aver(sp);</span><br><span class="line">printf(&quot;average score is %5.2f&quot;,av);</span><br><span class="line">&#125;</span><br><span class="line">float aver(float ※pa)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">float av,s=0;</span><br><span class="line">for(i=0;i&lt;5;i++) s=s+※pa++;</span><br><span class="line">av=s/5;</span><br><span class="line">return av;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指向多维数组的指针变量"><a href="#指向多维数组的指针变量" class="headerlink" title="指向多维数组的指针变量"></a>指向多维数组的指针变量</h1><p>本小节以二维数组为例介绍多维数组的指针变量。</p><h2 id="一、多维数组地址的表示方法"><a href="#一、多维数组地址的表示方法" class="headerlink" title="一、多维数组地址的表示方法"></a>一、多维数组地址的表示方法</h2><p>设有整型二维数组a[3][4]如下：<br>0 1 2 3<br>4 5 6 7<br>8 9 10 11</p><blockquote><p>   设数组a的首地址为1000，各下标变量的首地址及其值如图所示。在第四章中介绍过， Ｃ语言允许把一个二维数组分解为多个一维数组来处理。因此数组a可分解为三个一维数组，即a[0]，a[1]，a[2]。每一个一维数组又含有四个元素。例如a[0]数组，含有a[0][0]，a[0][1]，a[0][2]，a[0][3]四个元素。 数组及数组元素的地址表示如下：a是二维数组名，也是二维数组0行的首地址，等于1000。a[0]是第一个一维数组的数组名和首地址，因此也为1000。※(a+0)或※a是与a[0]等效的， 它表示一维数组a[0]0 号元素的首地址。 也为1000。&amp;a[0][0]是二维数组a的0行0列元素首地址，同样是1000。因此，a，a[0]，※(a+0)，※a?amp;a[0][0]是相等的。同理，a+1是二维数组1行的首地址，等于1008。a[1]是第二个一维数组的数组名和首地址，因此也为1008。 &amp;a[1][0]是二维数组a的1行0列元素地址，也是1008。因此a+1,a[1],※(a+1),&amp;a[1][0]是等同的。 由此可得出：a+i，a[i]，※(a+i)，&amp;a[i][0]是等同的。 此外，&amp;a[i]和a[i]也是等同的。因为在二维数组中不能把&amp;a[i]理解为元素a[i]的地址，不存在元素a[i]。</p><p>   Ｃ语言规定，它是一种地址计算方法，表示数组a第i行首地址。由此，我们得出：a[i]，&amp;a[i]，※(a+i)和a+i也都是等同的。另外，a[0]也<br>可以看成是a[0]+0是一维数组a[0]的0号元素的首地址， 而a[0]+1则是a[0]的1号元素首地址，由此可得出a[i]+j则是一维数组a[i]的j号元素首地址，它等于&amp;a[i][j]。由a[i]=※(a+i)得a[i]+j=※(a+i)+j，由于※(a+i)+j是二维数组a的i行j列元素的首地址。该元素的值等于※(※(a+i)+j)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Explain]</span><br><span class="line"> #define PF &quot;%d,%d,%d,%d,%d,/n&quot;</span><br><span class="line"> main()&#123;</span><br><span class="line"> static int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;</span><br><span class="line"> printf(PF,a,※a,a[0],&amp;a[0],&amp;a[0][0]);</span><br><span class="line"> printf(PF,a+1,※(a+1),a[1],&amp;a[1],&amp;a[1][0]);</span><br><span class="line"> printf(PF,a+2,※(a+2),a[2],&amp;a[2],&amp;a[2][0]);</span><br><span class="line"> printf(&quot;%d,%d/n&quot;,a[1]+1,※(a+1)+1);</span><br><span class="line"> printf(&quot;%d,%d/n&quot;,※(a[1]+1),※(※(a+1)+1));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="二、多维数组的指针变量"><a href="#二、多维数组的指针变量" class="headerlink" title="二、多维数组的指针变量"></a>二、多维数组的指针变量</h2><blockquote><p>　　把二维数组a 分解为一维数组a[0],a[1],a[2]之后，设p为指向二维数组的指针变量。可定义为： int (※p)[4] 它表示p是一个指针变量，它指向二维数组a 或指向第一个一维数组a[0]，其值等于a,a[0]，或&amp;a[0][0]等。而p+i则指向一维数组a[i]。从前面的分析可得出※(p+i)+j是二维数组i行j 列的元素的地址，而※(※(p+i)+j)则是i行j列元素的值。</p><p>　　二维数组指针变量说明的一般形式为： 类型说明符 (※指针变量名)[长度] 其中“类型说明符”为所指数组的数据类型。“※”表示其后的变量是指针类型。 “长度”表示二维数组分解为多个一维数组时， 一维数组的长度，也就是二维数组的列数。应注意“(※指针变量名)”两边的括号不可少，如缺少括号则表示是指针数组(本章后面介绍)，意义就完全不同了。<br>[Explain]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">static int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;</span><br><span class="line">int(※p)[4];</span><br><span class="line">int i,j;</span><br><span class="line">p=a;</span><br><span class="line">for(i=0;i&lt;3;i++)</span><br><span class="line">for(j=0;j&lt;4;j++) printf(&quot;%2d &quot;,※(※(p+i)+j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>‘Expain字符串指针变量的说明和使用字符串指针变量的定义说明与指向字符变量的指针变量说明是相同的。只能按对指针变量的赋值不同来区别。 对指向字符变量的指针变量应赋予该字符变量的地址。如： char c,※p=&c;表示p是一个指向字符变量c的指针变量。而： char ※s=”C Language”;则表示s是一个指向字符串的指针变量。把字符串的首地址赋予s。<br>请看下面一例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">char ※ps;</span><br><span class="line">ps=&quot;C Language&quot;;</span><br><span class="line">printf(&quot;%s&quot;,ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果为：<br>C Language</p><p>  上例中，首先定义ps是一个字符指针变量， 然后把字符串的首地址赋予ps(应写出整个字符串，以便编译系统把该串装入连续的一块内存单元)，并把首地址送入ps。程序中的： char ※ps;ps=”C Language”;等效于： char ※ps=”C Language”;输出字符串中n个字符后的所有字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">char ※ps=&quot;this is a book&quot;;</span><br><span class="line">int n=10;</span><br><span class="line">ps=ps+n;</span><br><span class="line">printf(&quot;%s/n&quot;,ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：<br>book 在程序中对ps初始化时，即把字符串首地址赋予ps，当ps= ps+10之后，ps指向字符“b”，因此输出为”book”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">char st[20],※ps;</span><br><span class="line">int i;</span><br><span class="line">printf(&quot;input a string:/n&quot;);</span><br><span class="line">ps=st;</span><br><span class="line">scanf(&quot;%s&quot;,ps);</span><br><span class="line">for(i=0;ps[i]!=&apos;/0&apos;;i++)</span><br><span class="line">if(ps[i]==&apos;k&apos;)&#123;</span><br><span class="line">printf(&quot;there is a &apos;k&apos; in the string/n&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(ps[i]==&apos;/0&apos;) printf(&quot;There is no &apos;k&apos; in the string/n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本例是在输入的字符串中查找有无‘k’字符。 下面这个例子是将指针变量指向一个格式字符串，用在printf函数中，用于输出二维数组的各种地址表示的值。但在printf语句中用指针变量PF代替了格式串。 这也是程序中常用的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">static int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;</span><br><span class="line">char ※PF;</span><br><span class="line">PF=&quot;%d,%d,%d,%d,%d/n&quot;;</span><br><span class="line">printf(PF,a,※a,a[0],&amp;a[0],&amp;a[0][0]);</span><br><span class="line">printf(PF,a+1,※(a+1),a[1],&amp;a[1],&amp;a[1][0]);</span><br><span class="line">printf(PF,a+2,※(a+2),a[2],&amp;a[2],&amp;a[2][0]);</span><br><span class="line">printf(&quot;%d,%d/n&quot;,a[1]+1,※(a+1)+1);</span><br><span class="line">printf(&quot;%d,%d/n&quot;,※(a[1]+1),※(※(a+1)+1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　 在下例是讲解，把字符串指针作为函数参数的使用。要求把一个字符串的内容复制到另一个字符串中，并且不能使用strcpy函数。函数cprstr的形参为两个字符指针变量。pss指向源字符串，pds指向目标字符串。表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(※pds=※pss)!=`/0&apos;</span><br><span class="line">cpystr(char ※pss,char ※pds)&#123;</span><br><span class="line">while((※pds=※pss)!=&apos;/0&apos;)&#123;</span><br><span class="line">pds++;</span><br><span class="line">pss++; &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">char ※pa=&quot;CHINA&quot;,b[10],※pb;</span><br><span class="line">pb=b;</span><br><span class="line">cpystr(pa,pb);</span><br><span class="line">printf(&quot;string a=%s/nstring b=%s/n&quot;,pa,pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　 </p><blockquote><p>在上例中，程序完成了两项工作：一是把pss指向的源字符复制到pds所指向的目标字符中，二是判断所复制的字符是否为`/0’，若是则表明源字符串结束，不再循环。否则，pds和pss都加1，指向下一字符。在主函数中，以指针变量pa,pb为实参，分别取得确定值后调用cprstr函数。由于采用的指针变量pa和pss,pb和pds均指向同一字符串，因此在主函数和cprstr函数中均可使用这些字符串。也可以把cprstr函数简化为以下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cprstr(char ※pss,char※pds)</span><br><span class="line">&#123;while ((※pds++=※pss++)!=`/0&apos;);&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>　　 </p><blockquote><p>即把指针的移动和赋值合并在一个语句中。 进一步分析还可发现<code>/0&#39;的ASCⅡ码为0，对于while语句只看表达式的值为非0就循环，为0则结束循环，因此也可省去“!=</code>/0’”这一判断部分，而写为以下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cprstr (char ※pss,char ※pds)</span><br><span class="line">&#123;while (※pdss++=※pss++);&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>表达式的意义可解释为，源字符向目标字符赋值， 移动指针，若所赋值为非0则循环，否则结束循环。这样使程序更加简洁。简化后的程序如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cpystr(char ※pss,char ※pds)&#123;</span><br><span class="line">while(※pds++=※pss++);</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">char ※pa=&quot;CHINA&quot;,b[10],※pb;</span><br><span class="line">pb=b;</span><br><span class="line">cpystr(pa,pb);</span><br><span class="line">printf(&quot;string a=%s/nstring b=%s/n&quot;,pa,pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用字符串指针变量与字符数组的区别"><a href="#使用字符串指针变量与字符数组的区别" class="headerlink" title="使用字符串指针变量与字符数组的区别"></a>使用字符串指针变量与字符数组的区别</h2><p>用字符数组和字符指针变量都可实现字符串的存储和运算。 但是两者是有区别的。在使用时应注意以下几个问题：</p><blockquote><ol><li><p>字符串指针变量本身是一个变量，用于存放字符串的首地址。而字符串本身是存放在以该首地址为首的一块连续的内存空间中并以‘/0’作为串的结束。字符数组是由于若干个数组元素组成的，它可用来存放整个字符串。</p></li><li><p>对字符数组作初始化赋值，必须采用外部类型或静态类型，如： static char st[]={“C Language”};而对字符串指针变量则无此限制，如： char ※ps=”C Language”;</p></li><li><p>对字符串指针方式 char ※ps=”C Language”;可以写为： char ※ps;　ps=”C Language”;而对数组方式：<br>static char st[]={“C Language”};<br>不能写为：<br>char st[20];st={“C Language”};<br>而只能对字符数组的各元素逐个赋值。</p></li></ol></blockquote><p>　　从以上几点可以看出字符串指针变量与字符数组在使用时的区别，同时也可看出使用指针变量更加方便。前面说过，当一个指针变量在未取得确定地址前使用是危险的，容易引起错误。但是对指针变量直接赋值是可以的。因为C系统对指针变量赋值时要给以确定的地址。因此，<br>char ※ps=”C Langage”;<br>或者 char ※ps;<br>ps=”C Language”;都是合法的。</p><h2 id="函数指针变量"><a href="#函数指针变量" class="headerlink" title="函数指针变量"></a>函数指针变量</h2><blockquote><p>　　在Ｃ语言中规定，一个函数总是占用一段连续的内存区， 而函数名就是该函数所占内存区的首地址。 我们可以把函数的这个首地址(或称入口地址)赋予一个指针变量， 使该指针变量指向该函数。然后通过指针变量就可以找到并调用这个函数。 我们把这种指向函数的指针变量称为“函数指针变量”。<br>函数指针变量定义的一般形式为：<br>类型说明符 (※指针变量名)();<br>其中“类型说明符”表示被指函数的返回值的类型。“(※ 指针变量名)”表示“※”后面的变量是定义的指针变量。 最后的空括号表示指针变量所指的是一个函数。<br>例如： int (※pf)();<br>表示pf是一个指向函数入口的指针变量，该函数的返回值(函数值)是整型。<br>下面通过例子来说明用指针形式实现对函数调用的方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int max(int a,int b)&#123;</span><br><span class="line">if(a&gt;b)return a;</span><br><span class="line">else return b;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">int max(int a,int b);</span><br><span class="line">int(※pmax)();</span><br><span class="line">int x,y,z;</span><br><span class="line">pmax=max;</span><br><span class="line">printf(&quot;input two numbers:/n&quot;);</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">z=(※pmax)(x,y);</span><br><span class="line">printf(&quot;maxmum=%d&quot;,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述程序可以看出用，函数指针变量形式调用函数的步骤如下：</p><blockquote><ol><li><p>先定义函数指针变量，如后一程序中第9行 int (※pmax)();定义pmax为函数指针变量。</p></li><li><p>把被调函数的入口地址(函数名)赋予该函数指针变量，如程序中第11行 pmax=max;</p></li><li><p>用函数指针变量形式调用函数，如程序第14行 z=(※pmax)(x,y);　调用函数的一般形式为： (※指针变量名) (实参表)使用函数指针变量还应注意以下两点：</p><p> a. 函数指针变量不能进行算术运算，这是与数组指针变量不同的。数组指针变量加减一个整数可使指针移动指向后面或前面的数组元素，而函数指针的移动是毫无意义的。</p><p> b. 函数调用中”(※指针变量名)”的两边的括号不可少，其中的※不应该理解为求值运算，在此处它只是一种表示符号。</p></li></ol></blockquote><h2 id="指针型函数"><a href="#指针型函数" class="headerlink" title="指针型函数"></a>指针型函数</h2><p>前面我们介绍过，所谓函数类型是指函数返回值的类型。 在Ｃ语言中允许一个函数的返回值是一个指针(即地址)， 这种返回指针值的函数称为指针型函数。<br>定义指针型函数的一般形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 ※函数名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">…… /※函数体※/</span><br><span class="line">&#125;</span><br><span class="line">其中函数名之前加了“※”号表明这是一个指针型函数，即返回值是一个指针。类型说明符表示了返回的指针值所指向的数据类型。</span><br><span class="line">如：</span><br><span class="line">int ※ap(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">...... /※函数体※/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>　　 表示ap是一个返回指针值的指针型函数， 它返回的指针指向一个整型变量。下例中定义了一个指针型函数 day_name，它的返回值指向一个字符串。该函数中定义了一个静态指针数组name。name 数组初始化赋值为八个字符串，分别表示各个星期名及出错提示。形参n表示与星期名所对应的整数。在主函数中， 把输入的整数i作为实参， 在printf语句中调用day_name函数并把i值传送给形参 n。day_name函数中的return语句包含一个条件表达式， n 值若大于7或小于1则把name[0] 指针返回主函数输出出错提示字符串“Illegal day”。否则返回主函数输出对应的星期名。主函数中的第7行是个条件语句，其语义是，如输入为负数(i&lt;0)则中止程序运行退出程序。exit是一个库函数，exit(1)表示发生错误后退出程序， exit(0)表示正常退出。</p><p>　　应该特别注意的是函数指针变量和指针型函数这两者在写法和意义上的区别。如int(※p)()和int ※p()是两个完全不同的量。int(※p)()是一个变量说明，说明p 是一个指向函数入口的指针变量，该函数的返回值是整型量，(※p)的两边的括号不能少。int ※p() 则不是变量说明而是函数说明，说明p是一个指针型函数，其返回值是一个指向整型量的指针，※p两边没有括号。作为函数说明， 在括号内最好写入形式参数，这样便于与变量说明区别。 对于指针型函数定义，int ※p()只是函数头部分，一般还应该有函数体部分。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">int i;</span><br><span class="line">char ※day_name(int n);</span><br><span class="line">printf(&quot;input Day No:/n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;i);</span><br><span class="line">if(i&lt;0) exit(1);</span><br><span class="line">printf(&quot;Day No:%2d--&gt;%s/n&quot;,i,day_name(i));</span><br><span class="line">&#125;</span><br><span class="line">char ※day_name(int n)&#123;</span><br><span class="line">static char ※name[]=&#123; &quot;Illegal day&quot;,</span><br><span class="line">&quot;Monday&quot;,</span><br><span class="line">&quot;Tuesday&quot;,</span><br><span class="line">&quot;Wednesday&quot;,</span><br><span class="line">&quot;Thursday&quot;,</span><br><span class="line">&quot;Friday&quot;,</span><br><span class="line">&quot;Saturday&quot;,</span><br><span class="line">&quot;Sunday&quot;&#125;;</span><br><span class="line">return((n&lt;1||n&gt;7) ? name[0] : name[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 本程序是通过指针函数，输入一个1～7之间的整数， 输出对应的星期名。指针数组的说明与使用一个数组的元素值为指针则是指针数组。 指针数组是一组有序的指针的集合。 指针数组的所有元素都必须是具有相同存储类型和指向相同数据类型的指针变量。<br>　　 指针数组说明的一般形式为： 类型说明符※数组名[数组长度]<br>　　 其中类型说明符为指针值所指向的变量的类型。例如： int ※pa[3] 表示pa是一个指针数组，它有三个数组元素， 每个元素值都是一个指针，指向整型变量。通常可用一个指针数组来指向一个二维数组。 指针数组中的每个元素被赋予二维数组每一行的首地址， 因此也可理解为指向一个一维数组。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int a[3][3]=&#123;1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">int ※pa[3]=&#123;a[0],a[1],a[2]&#125;;</span><br><span class="line">int ※p=a[0];</span><br><span class="line">main()&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;3;i++)</span><br><span class="line">printf(&quot;%d,%d,%d/n&quot;,a[i][2-i],※a[i],※(※(a+i)+i));</span><br><span class="line">for(i=0;i&lt;3;i++)</span><br><span class="line">printf(&quot;%d,%d,%d/n&quot;,※pa[i],p[i],※(p+i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>　　 本例程序中，pa是一个指针数组，三个元素分别指向二维数组a的各行。然后用循环语句输出指定的数组元素。其中※a[i]表示i行0列元素值；※(※(a+i)+i)表示i行i列的元素值；※pa[i]表示i行0列元素值；由于p与a[0]相同，故p[i]表示0行i列的值；※(p+i)表示0行i列的值。读者可仔细领会元素值的各种不同的表示方法。 应该注意指针数组和二维数组指针变量的区别。 这两者虽然都可用来表示二维数组，但是其表示方法和意义是不同的。</p><p>　　二维数组指针变量是单个的变量，其一般形式中”(※指针变量名)”两边的括号不可少。而指针数组类型表示的是多个指针( 一组有序指针)在一般形式中”※指针数组名”两边不能有括号。例如： int (※p)[3];表示一个指向二维数组的指针变量。该二维数组的列数为3或分解为一维数组的长度为3。 int ※p[3] 表示p是一个指针数组，有三个下标变量p[0]，p[1]，p[2]均为指针变量。</p><p>　　指针数组也常用来表示一组字符串， 这时指针数组的每个元素被赋予一个字符串的首地址。 指向字符串的指针数组的初始化更为简单。例如在例6.20中即采用指针数组来表示一组字符串。 其初始化赋值为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char ※name[]=&#123;&quot;Illagal day&quot;,</span><br><span class="line">&quot;Monday&quot;,</span><br><span class="line">&quot;Tuesday&quot;,</span><br><span class="line">&quot;Wednesday&quot;,</span><br><span class="line">&quot;Thursday&quot;,</span><br><span class="line">&quot;Friday&quot;,</span><br><span class="line">&quot;Saturday&quot;,</span><br><span class="line">&quot;Sunday&quot;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>　　 完成这个初始化赋值之后，name[0]即指向字符串”Illegal day”，name[1]指?quot;Monday”……。</p><p>　　指针数组也可以用作函数参数。在本例主函数中，定义了一个指针数组name，并对name 作了初始化赋值。其每个元素都指向一个字符串。然后又以name 作为实参调用指针型函数day name，在调用时把数组名 name 赋予形参变量name，输入的整数i作为第二个实参赋予形参n。在day name函数中定义了两个指针变量pp1和pp2，pp1被赋予name[0]的值(即※name)，pp2被赋予name[n]的值即※(name+ n)。由条件表达式决定返回pp1或pp2指针给主函数中的指针变量ps。最后输出i和ps的值。</p></blockquote><h2 id="指针数组作指针型函数的参数"><a href="#指针数组作指针型函数的参数" class="headerlink" title="指针数组作指针型函数的参数"></a>指针数组作指针型函数的参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">static char ※name[]=&#123; &quot;Illegal day&quot;,</span><br><span class="line">&quot;Monday&quot;,</span><br><span class="line">&quot;Tuesday&quot;,</span><br><span class="line">&quot;Wednesday&quot;,</span><br><span class="line">&quot;Thursday&quot;,</span><br><span class="line">&quot;Friday&quot;,</span><br><span class="line">&quot;Saturday&quot;,</span><br><span class="line">&quot;Sunday&quot;&#125;;</span><br><span class="line">char ※ps;</span><br><span class="line">int i;</span><br><span class="line">char ※day name(char ※name[],int n);</span><br><span class="line">printf(&quot;input Day No:/n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;i);</span><br><span class="line">if(i&lt;0) exit(1);</span><br><span class="line">ps=day name(name,i);</span><br><span class="line">printf(&quot;Day No:%2d--&gt;%s/n&quot;,i,ps);</span><br><span class="line">&#125;</span><br><span class="line">char ※day name(char ※name[],int n)</span><br><span class="line">&#123;</span><br><span class="line">char ※pp1,※pp2;</span><br><span class="line">pp1=※name;</span><br><span class="line">pp2=※(name+n);</span><br><span class="line">return((n&lt;1||n&gt;7)? pp1:pp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下例要求输入5个国名并按字母顺序排列后输出。在以前的例子中采用了普通的排序方法， 逐个比较之后交换字符串的位置。交换字符串的物理位置是通过字符串复制函数完成的。 反复的交换将使程序执行的速度很慢，同时由于各字符串(国名) 的长度不同，又增加了存储管理的负担。 用指针数组能很好地解决这些问题。把所有的字符串存放在一个数组中， 把这些字符数组的首地址放在一个指针数组中，当需要交换两个字符串时， 只须交换指针数组相应两元素的内容(地址)即可，而不必交换字符串本身。程序中定义了两个函数，一个名为sort完成排序， 其形参为指<br>针数组name，即为待排序的各字符串数组的指针。形参n为字符串的个数。另一个函数名为print，用于排序后字符串的输出，其形参与sort的形参相同。主函数main中，定义了指针数组name 并作了初始化赋值。然后分别调用sort函数和print函数完成排序和输出。值得说明的是在sort函数中，对两个字符串比较，采用了strcmp 函数，strcmp函数允许参与比较的串以指针方式出现。name[k]和name[ j]均为指针，因此是合法的。字符串比较后需要交换时， 只交换指针数组元素的值，而不交换具体的字符串， 这样将大大减少时间的开销，提高了运行效率。</p><p>现编程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">void sort(char ※name[],int n);</span><br><span class="line">void print(char ※name[],int n);</span><br><span class="line">static char ※name[]=&#123; &quot;CHINA&quot;,&quot;AMERICA&quot;,&quot;AUSTRALIA&quot;,</span><br><span class="line">&quot;FRANCE&quot;,&quot;GERMAN&quot;&#125;;</span><br><span class="line">int n=5;</span><br><span class="line">sort(name,n);</span><br><span class="line">print(name,n);</span><br><span class="line">&#125;</span><br><span class="line">void sort(char ※name[],int n)&#123;</span><br><span class="line">char ※pt;</span><br><span class="line">int i,j,k;</span><br><span class="line">for(i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">k=i;</span><br><span class="line">for(j=i+1;j&lt;n;j++)</span><br><span class="line">if(strcmp(name[k],name[j])&gt;0) k=j;</span><br><span class="line">if(k!=i)&#123;</span><br><span class="line">pt=name[i];</span><br><span class="line">name[i]=name[k];</span><br><span class="line">name[k]=pt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void print(char ※name[],int n)&#123;</span><br><span class="line">int i;</span><br><span class="line">for (i=0;i&lt;n;i++) printf(&quot;%s/n&quot;,name[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main函数的参数"><a href="#main函数的参数" class="headerlink" title="ｍａｉｎ函数的参数"></a>ｍａｉｎ函数的参数</h2><blockquote><p>　　前面介绍的main函数都是不带参数的。因此main 后的括号都是空括号。实际上，main函数可以带参数，这个参数可以认为是 main函数的形式参数。Ｃ语言规定main函数的参数只能有两个， 习惯上这两个参数写为argc和argv。因此，main函数的函数头可写为： main (argc,argv)Ｃ语言还规定argc(第一个形参)必须是整型变量,argv( 第二个形参)必须是指向字符串的指针数组。</p></blockquote><p>加上形参说明后，main函数的函数头应写为：<br><figure class="highlight plain"><figcaption><span>(argc,argv)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int argv;</span><br><span class="line">char ※argv[];或写成：</span><br><span class="line">main (int argc,char ※argv[])</span><br></pre></td></tr></table></figure></p><blockquote><p> 由于main函数不能被其它函数调用， 因此不可能在程序内部取得实际值。那么，在何处把实参值赋予main函数的形参呢? 实际上,main函数的参数值是从操作系统命令行上获得的。当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数即可把这些实参传送到main的形参中去。</p><p>　　DOS提示符下命令行的一般形式为： C:/&gt;可执行文件名 参数 参数……; 但是应该特别注意的是，main 的两个形参和命令行中的参数在<br>位置上不是一一对应的。因为,main的形参只有二个，而命令行中的参数个数原则上未加限制。argc参数表示了命令行中参数的个数(注意：文件名本身也算一个参数)，argc的值是在输入命令行时由系统按实际参数的个数自动赋予的。例如有命令行为： C:/&gt;E6 24 BASIC dbase FORTRAN由于文件名E6 24本身也算一个参数，所以共有4个参数，因此argc取得的值为4。argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处理)的首地址。 指针数组的长度即为参数个数。数组元素初值由系统自动赋予。其表示如图6.8所示：<br><figure class="highlight plain"><figcaption><span>argc,char ※argv)&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(argc--&gt;1)</span><br><span class="line">printf(&quot;%s/n&quot;,※++argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>本例是显示命令行中输入的参数如果上例的可执行文件名为e24.exe，存放在A驱动器的盘内。<br>因此输入的命令行为： C:/&gt;a:e24 BASIC dBASE FORTRAN</p></blockquote><p>则运行结果为：<br>BASIC<br>dBASE<br>FORTRAN</p><blockquote><p>　　 该行共有4个参数，执行main时，argc的初值即为4。argv的4个元素分为4个字符串的首地址。执行while语句，每循环一次 argv值减1，当argv等于1时停止循环，共循环三次， 因此共可输出三个参数。在printf函数中，由于打印项※++argv是先加1再打印， 故第一次打印的是argv[1]所指的字符串BASIC。第二、 三次循环分别打印后二个字符串。而参数e24是文件名，不必输出。</p><p>　　下例的命令行中有两个参数，第二个参数20即为输入的n值。在程序中※++argv的值为字符串“20”，然后用函数”atoi”把它换为整型作为while语句中的循环控制变量，输出20个偶数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main(int argc,char※argv[])&#123;</span><br><span class="line">int a=0,n;</span><br><span class="line">n=atoi(※++argv);</span><br><span class="line">while(n--) printf(&quot;%d &quot;,a++※2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>本程序是从0开始输出n个偶数。指向指针的指针变量如果一个指针变量存放的又是另一个指针变量的地址， 则称这个指针变量为指向指针的指针变量。</p><p>在前面已经介绍过，通过指针访问变量称为间接访问， 简称间访。由于指针变量直接指向变量，所以称为单级间访。 而如果通过指向指针的指针变量来访问变量则构成了二级或多级间访。在Ｃ语言程序中，对间访的级数并未明确限制， 但是间访级数太多时不容易理解解，也容易出错，因此，一般很少超过二级间访。 指向指针的指针变量说明的一般形式为：</p></blockquote><p>类型说明符※※ 指针变量名；<br>例如： int ※※ pp; 表示pp是一个指针变量，它指向另一个指针变量， 而这个指针变量指向一个整型量。下面举一个例子来说明这种关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x,※p,※※pp;</span><br><span class="line">x=10;</span><br><span class="line">p=&amp;x;</span><br><span class="line">pp=&amp;p;</span><br><span class="line">printf(&quot;x=%d/n&quot;,※※pp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>　　 上例程序中p 是一个指针变量，指向整型量x；pp也是一个指针变量， 它指向指针变量p。通过pp变量访问x的写法是※※pp。程序最后输出x的值为10。通过上例，读者可以学习指向指针的指针变量的说明和使用方法。</p><p>　　下述程序中首先定义说明了指针数组ps并作了初始化赋值。 又说明了pps是一个指向指针的指针变量。在5次循环中， pps 分别取得了ps[0]，ps[1]，ps[2]，ps[3]，ps[4]的地址值(如图6.10所示)。再通过这些地址即可找到该字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static char ※ps[]=&#123; &quot;BASIC&quot;,&quot;DBASE&quot;,&quot;C&quot;,&quot;FORTRAN&quot;,</span><br><span class="line">&quot;PASCAL&quot;&#125;;</span><br><span class="line">char ※※pps;</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">pps=ps+i;</span><br><span class="line">printf(&quot;%s/n&quot;,※pps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>本程序是用指向指针的指针变量编程，输出多个字符串。</p><h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><blockquote><ol><li><p>指针是Ｃ语言中一个重要的组成部分，使用指针编程有以下优点：<br>(1)提高程序的编译效率和执行速度。<br>(2)通过指针可使用主调函数和被调函数之间共享变量或数据结构，便于实现双向数据通讯。<br>(3)可以实现动态的存储分配。<br>(4)便于表示各种数据结构，编写高质量的程序。</p></li><li><p>指针的运算<br>(1)取地址运算符&amp;：求变量的地址<br>(2)取内容运算符※：表示指针所指的变量<br>(3)赋值运算<br>·把变量地址赋予指针变量<br>·同类型指针变量相互赋值<br>·把数组，字符串的首地址赋予指针变量<br>·把函数入口地址赋予指针变量<br>(4)加减运算<br>对指向数组，字符串的指针变量可以进行加减运算，如p+n,p-n,p++,p–等。对指向同一数组的两个指针变量可以相减。对指向其它类型的指针变量作加减运算是无意义的。<br>(5)关系运算<br>指向同一数组的两个指针变量之间可以进行大于、小于、 等于比较运算。指针可与0比较，p==0表示p为空指针。</p></li><li><p>与指针有关的各种说明和意义见下表。</p></li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ※p; 　　　 p为指向整型量的指针变量</span><br><span class="line">int ※p[n]; 　　p为指针数组，由n个指向整型量的指针元素组成。</span><br><span class="line">int (※p)[n]; 　p为指向整型二维数组的指针变量，二维数组的列数为n</span><br><span class="line">int ※p() 　　　p为返回指针值的函数，该指针指向整型量</span><br><span class="line">int (※p)() 　　p为指向函数的指针，该函数返回整型量</span><br><span class="line">int ※※p 　　　 p为一个指向另一指针的指针变量，该指针指向一个整型量。</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li><p>有关指针的说明很多是由指针，数组，函数说明组合而成的。<br>但并不是可以任意组合，例如数组不能由函数组成，即数组元素不能是一个函数；函数也不能返回一个数组或返回另一个函数。例如<br>int a<a href="">5</a>；就是错误的。</p></li><li><p>关于括号<br>在解释组合说明符时， 标识符右边的方括号和圆括号优先于标识符左边的“※”号，而方括号和圆括号以相同的优先级从左到右结合。但可以用圆括号改变约定的结合顺序。</p></li><li><p>阅读组合说明符的规则是“从里向外”。<br>从标识符开始，先看它右边有无方括号或园括号，如有则先作出解释，再看左边有无※号。 如果在任何时候遇到了闭括号，则在继续之前必须用相同的规则处理括号内的内容。例如：<br>int※(※(※a)())[10]<br>↑ ↑↑↑↑↑↑<br>7 6 4 2 1 3 5<br>上面给出了由内向外的阅读顺序，下面来解释它：<br>(1)标识符a被说明为；<br>(2)一个指针变量，它指向；<br>(3)一个函数，它返回；<br>(4)一个指针，该指针指向；<br>(5)一个有10个元素的数组，其类型为；<br>(6)指针型，它指向；<br>(7)int型数据。<br>因此a是一个函数指针变量，该函数返回的一个指针值又指向一个指针数组，该指针数组的元素指向整型量。</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指针是Ｃ语言中广泛使用的一种数据类型。 运用指针编程是Ｃ语言最主要的风格之一。利用指针变量可以表示各种数据结构； 能很方便地使用数组和字符串； 并能象汇编语言一样处理内存地址，从而编出精练而高效的程序。指针极大地丰富了Ｃ语言的功能。 学习指针是学习Ｃ语言中最重要的一环， 能否正确理解和使用指针是我们是否掌握Ｃ语言的一个标志。同时， 指针也是Ｃ语言中最为困难的一部分，在学习中除了要正确理解基本概念，还必须要多编程，上机调试。只要作到这些，指针也是不难掌握的。&lt;br&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://yoursite.com/categories/c-c/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c/c++" scheme="http://yoursite.com/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>动态规划详解</title>
    <link href="http://yoursite.com/2018/06/01/second/"/>
    <id>http://yoursite.com/2018/06/01/second/</id>
    <published>2018-05-31T23:48:20.772Z</published>
    <updated>2018-06-01T03:39:32.872Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。<br><a id="more"></a><br>首先，我们看一下这道题（此题目来源于北大POJ）：</p><p>数字三角形(POJ1163)</p><p>在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99<br>输入格式：<br>5  //表示三角形的行数接下来输入三角形行数<br>7<br>3   8<br>8   1   0<br>2   7   4   4<br>4   5   2   6   5<br>要求输出最大和<br>接下来，我们来分析一下解题思路：<br>首先，肯定得用二维数组来存放数字三角形<br>然后我们用D( r, j) 来表示第r行第 j 个数字(r,j从1开始算)<br>我们用MaxSum(r, j)表示从D(r,j)到底边的各条路径中，最佳路径的数字之和。<br>因此，此题的最终问题就变成了求 MaxSum(1,1)<br>当我们看到这个题目的时候，首先想到的就是可以用简单的递归来解题：<br>D(r, j)出发，下一步只能走D(r+1,j)或者D(r+1, j+1)。故对于N行的三角形，我们可以写出如下的递归式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( r == N)</span><br><span class="line"> MaxSum(r,j) = D(r,j)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> MaxSum( r, j) = Max&#123; MaxSum(r＋1,j), MaxSum(r+1,j+1) &#125; + D(r,j)</span><br></pre></td></tr></table></figure></p><p> 根据上面这个简单的递归式，我们就可以很轻松地写出完整的递归代码：</p><figure class="highlight plain"><figcaption><span><iostream></iostream></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;   </span><br><span class="line">#define MAX 101</span><br><span class="line">using namespace std;   </span><br><span class="line">int D[MAX][MAX];</span><br><span class="line">int n;</span><br><span class="line">int MaxSum(int i, int j)&#123;  </span><br><span class="line">if(i==n)</span><br><span class="line"> return D[i][j];  </span><br><span class="line">int x = MaxSum(i+1,j);  </span><br><span class="line">int y = MaxSum(i+1,j+1);  </span><br><span class="line"> return max(x,y)+D[i][j];</span><br><span class="line">&#125;  </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line"> for(j=1;j&lt;=i;j++)  </span><br><span class="line">  cin &gt;&gt; D[i][j];  </span><br><span class="line">cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于如上这段递归的代码，当我提交到POJ时，会显示代码运行超时了，为什么会超时呢？</p><p>答案很简单，因为我们重复计算了.<br><a href="https://img-blog.csdn.net/20150811140840233?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" target="_blank" rel="noopener">picture</a><br>就拿第三行数字1来说，当我们计算从第2行的数字3开始的MaxSum时会计算出从1开始的MaxSum，当我们计算从第二行的数字8开始的MaxSum的时候又会计算一次从1开始的MaxSum，也就是说有重复计算。这样就浪费了大量的时间。也就是说如果采用递规的方法，深度遍历每条路径，存在大量重复计算。则时间复杂度为 2的n次方,对于 n = 100 行，肯定超时。<br>接下来，我们就要考虑如何进行改进，我们自然而然就可以想到如果每算出一个MaxSum(r,j)就保存起来，下次用到其值的时候直接取用，则可免去重复计算。那么可以用n方的时间复杂度完成计算。因为三角形的数字总数是 n(n+1)/2<br>根据这个思路，我们就可以将上面的代码进行改进，使之成为记忆递归型的动态规划程序：</p><figure class="highlight plain"><figcaption><span><iostream></iostream></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;   </span><br><span class="line">using namespace std;  </span><br><span class="line">#define MAX 101  </span><br><span class="line">int D[MAX][MAX];  </span><br><span class="line">int n;</span><br><span class="line">int maxSum[MAX][MAX];  </span><br><span class="line">int MaxSum(int i, int j)&#123;</span><br><span class="line">if( maxSum[i][j] != -1 )   </span><br><span class="line">return maxSum[i][j];</span><br><span class="line">if(i==n) </span><br><span class="line">maxSum[i][j] = D[i][j];   </span><br><span class="line">else&#123;  </span><br><span class="line">int x = MaxSum(i+1,j); </span><br><span class="line">int y = MaxSum(i+1,j+1); </span><br><span class="line">maxSum[i][j] = max(x,y)+ D[i][j];   </span><br><span class="line">&#125;   </span><br><span class="line">return maxSum[i][j];   </span><br><span class="line">&#125;   </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line">for(j=1;j&lt;=i;j++) &#123; </span><br><span class="line">cin &gt;&gt; D[i][j]; </span><br><span class="line">maxSum[i][j] = -1; </span><br><span class="line">&#125;  </span><br><span class="line">cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在短时间内就AC了。但是，我们并不能满足于这样的代码，因为递归总是需要使用大量堆栈上的空间，很容易造成栈溢出，我们现在就要考虑如何把递归转换为递推，让我们一步一步来完成这个过程。<br>我们首先需要计算的是最后一行，因此可以把最后一行直接写出，</p><blockquote><p>7<br>3 8<br>8 1 0<br>2 7 4 4<br>表格最下一行为（5X5）：<br>4  5  2  6  5</p></blockquote><p>现在开始分析倒数第二行的每一个数，现分析数字2，2可以和最后一行4相加，也可以和最后一行的5相加，但是很显然和5相加要更大一点，结果为7，我们此时就可以将7保存起来，然后分析数字7，7可以和最后一行的5相加，也可以和最后一行的2相加，很显然和5相加更大，结果为12，因此我们将12保存起来。以此类推。</p><blockquote><p>7<br>3 8<br>8 1 0<br>2 7 4 4<br>表格（5X5）后两行为：<br>7 12 10 10<br>4 5  2  6  5<br>然后按同样的道理分析倒数第三行和倒数第四行，最后分析第一行，我们可以依次得到如下结果：<br>20 13 10<br>7  12 10 10<br>4  5  2  6  5<br>之后变成：<br>30<br>23 21<br>20 13 10<br>7  12 10 10<br>4  5  2  6  5<br>上面的推导过程相信大家不难理解，理解之后我们就可以写出如下的递推型动态规划程序： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;   </span><br><span class="line">using namespace std;   </span><br><span class="line">#define MAX 101      </span><br><span class="line">int D[MAX][MAX]; </span><br><span class="line">int n;</span><br><span class="line">int maxSum[MAX][MAX];   </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;&gt; n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line">for(j=1;j&lt;=i;j++)  </span><br><span class="line">cin &gt;&gt; D[i][j]; </span><br><span class="line">for( int i = 1;i &lt;= n; ++ i )   </span><br><span class="line">maxSum[n][i] = D[n][i]; </span><br><span class="line">for( int i = n-1; i&gt;= 1;  --i )   </span><br><span class="line">for( int j = 1; j &lt;= i; ++j )   </span><br><span class="line">maxSum[i][j] = max(maxSum[i+1][j],maxSum[i+1][j+1]) + D[i][j];  </span><br><span class="line">cout &lt;&lt; maxSum[1][1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们的代码仅仅是这样就够了吗？当然不是，我们仍然可以继续优化，而这个优化当然是对于空间进行优化，其实完全没必要用二维maxSum数组存储每一个MaxSum(r,j),只要从底层一行行向上递推，那么只要一维数组maxSum[100]即可,即只要存储一行的MaxSum值就可以。</p><p>接下里的步骤就按上图的过程一步一步推导就可以了。进一步考虑，我们甚至可以连maxSum数组都可以不要，直接用D的第n行直接替代maxSum即可。但是这里需要强调的是：虽然节省空间，但是时间复杂度还是不变的。</p><p>依照上面的方式，我们可以写出如下代码：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;   </span><br><span class="line">#include &lt;algorithm&gt;  </span><br><span class="line">using namespace std;   </span><br><span class="line">#define MAX 101     </span><br><span class="line">int D[MAX][MAX];</span><br><span class="line">int n;   </span><br><span class="line">int * maxSum;       </span><br><span class="line">int main()&#123;  </span><br><span class="line">int i,j;  </span><br><span class="line">cin &gt;n;  </span><br><span class="line">for(i=1;i&lt;=n;i++) </span><br><span class="line">for(j=1;j&lt;=i;j++)  </span><br><span class="line">cin &gt;D[i][j]; </span><br><span class="line">maxSum = D[n]; //maxSum指向第n行  </span><br><span class="line">for( int i = n-1; i&gt;= 1;  --i )   </span><br><span class="line">for( int j = 1; j &lt;= i; ++j ) </span><br><span class="line">maxSum[j] = max(maxSum[j],maxSum[j+1]) + D[i][j];  </span><br><span class="line">cout &lt;&lt; maxSum[1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 接下来，我们就进行一下总结：</p><p>递归到动规的一般转化方法</p><p>递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。</p></blockquote><h1 id="动规解题的一般思路"><a href="#动规解题的一般思路" class="headerlink" title="动规解题的一般思路"></a>动规解题的一般思路</h1><h2 id="1-将原问题分解为子问题"><a href="#1-将原问题分解为子问题" class="headerlink" title="1. 将原问题分解为子问题"></a>1. 将原问题分解为子问题</h2><blockquote><p>把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。<br>子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。</p></blockquote><h2 id="2-确定状态"><a href="#2-确定状态" class="headerlink" title="2.确定状态"></a>2.确定状态</h2><blockquote><p> 在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。<br>所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。<br>整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。</p></blockquote><h2 id="3-确定一些初始状态（边界状态）的值"><a href="#3-确定一些初始状态（边界状态）的值" class="headerlink" title="3.确定一些初始状态（边界状态）的值"></a>3.确定一些初始状态（边界状态）的值</h2><blockquote><p>  以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。`</p></blockquote><h2 id="4-确定状态转移方程"><a href="#4-确定状态转移方程" class="headerlink" title="4. 确定状态转移方程"></a>4. 确定状态转移方程</h2><blockquote><p>  定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。<br>  数字三角形的状态转移方程：可<a href="https://img-blog.csdn.net/20150811160833998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" target="_blank" rel="noopener">查看</a></p></blockquote><h2 id="能用动规解决的问题的特点"><a href="#能用动规解决的问题的特点" class="headerlink" title="能用动规解决的问题的特点"></a>能用动规解决的问题的特点</h2><blockquote><p>1) 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。</p><p>2) 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://yoursite.com/2018/05/30/hello-world/"/>
    <id>http://yoursite.com/2018/05/30/hello-world/</id>
    <published>2018-05-30T06:13:52.736Z</published>
    <updated>2018-06-01T02:17:28.423Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my blog.You can talk or help my ideas to more places where can help other people.<br>my email is in about tag,you can talk with me by it.</p><h2 id="My-knowledge-are-here"><a href="#My-knowledge-are-here" class="headerlink" title="My knowledge are here"></a>My knowledge are here</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my present knowledge</span><br><span class="line">&lt;c/c++&gt; &lt;algorithm&gt;</span><br><span class="line">&lt;java se&gt; &lt;java ee&gt; </span><br><span class="line">&lt;Java Server Pages&gt;</span><br><span class="line">&lt;html/js/css&gt; &lt;3ds max&gt;</span><br><span class="line">&lt;database&gt;</span><br><span class="line">&lt;app build&gt;</span><br></pre></td></tr></table></figure><p>I will spend more time to make my knowledge adequate.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to my blog.You can talk or help my ideas to more places where can help other people.&lt;br&gt;my email is in about tag,you can talk wit
      
    
    </summary>
    
      <category term="日常" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
  </entry>
  
</feed>
