<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图论基础知识(一)]]></title>
    <url>%2F2018%2F06%2F01%2Fgraph%2F</url>
    <content type="text"><![CDATA[准备ACM比赛的时候，懵逼的发现自己竟然不知道怎么求解图论的最短路径问题，至此开始，收集一系列有关图论的知识体系以及大部分题目，力争这段时间完成，在说图论之前，我们首先要知道图论的定义包含哪些。 123456789图由定点(vertex)的集V和边(edge)的集E组成。每一条边就是一幅点对(v,w)。如果点对是有序的，则图是有向的，又称为有向图。图中的一条路径是一个顶点序列：w1,w2,w3…wN是的(wi,wi+1)属于E。如果有一个顶点v到它自身的的边(v,v)，那么(v,v)也被称为环。如果一个无向图中从每个顶点到其他每个顶点都存在一条路径，则称无向图是连通(也称强连通)。如果一个有向图不是强连通的，但是它的基础图图是联通的，那么有向图称为弱连通的。完全图是其每一对顶点建都存在一条边的图。 紧接着就是图论有关算法涉及到的大多数定理了。稍微从各大网站还有大佬们的博客上爬虫下来的相关信息，了解到了主要有关图论的acm知识点，我以接下来的55点介绍，不一定能完全覆盖，但是大多数常考理论也都在里面涉及，相关算法方面，我也会在随后的一段时间里扩充。 什么是图, 一种高级数据结构, 三元组组成 &lt;V,E,ψ&gt;,V,点的集合, E ,边的集合, ψ是从边集合E到结点无序偶(有序偶)集合上的函数 也可简记为G = &lt;V,E其中V是非空点集合,E是连接结点的边集, 无向图, 每一条边都是无向边的图. 有向图 , 每一条边都是有向边的图. 还有混合图, 就是既有有向边又有无向边的图 邻接点 在一个图中, 若两个结点由一条或者多条边相连 在一个图中不与其它边相连的点叫做孤立结点,仅由孤立节点组成的图称为零图, 仅由一个孤立节点组成的图称为平凡图 关联与同一结点的边称为邻接边, 关联与同一结点的一条边称为自回路或环,环的方向没有意义 与一个点相连的边数称为度数,每一个环在其对应结点上的度数增加2 度数为奇数的的结点必为偶数个 有向图, 出度与入度 定理, 在任何有向图中出度与入度之和必相等 含有平行边的任何一个图称为多重图 把不含有环和平行边的图称为简单图,若任何一对结点之间都有边相连, 则称为完全图, 有n个结点的无向完全图记为Kn 生成子图 : 包含G中所有结点,且该字图为G的生成子图 路和通路 给定图 G = &lt;V,E&gt;,设v0,v1,…vn€V,e1,e2,…en, €E,其中ei是关联于vi-1,vi的边,交替序列v0e1v1e2v2 e3 e3v3..envn称为联结v0到vn的路 v0到vn分别称作路的起点和终点,边的数目n称作路的长度,v0 = vn时,这条路称为回路 若一条路中e1,e2,e3,…en都不相同,称作迹. 若一条路中所有的结点v0,v1,v2…vn均不相同,称为通路 闭的通路即除v0 = vn外,其余结点均不相同的路称为圈 欧拉图 - 给定无孤立节点图G,若存在一条路,经过图中每边一次且仅一次,该条路称为欧拉路,若存在一条回路, 经过图中每边一次且仅一次,成回路为欧拉回路,具有欧拉回路的图称为欧拉图 定理 无向图具有一条欧拉路, 当且仅当G是连通的,且有零个或奇数度结点 推论 无向图G具有一条欧拉回路, 当且仅当G是连通的,并且所有结点度数全为偶数 定义给定有向图G,通过图中每边一次且仅一次的一条单向路(回路),称作单向欧拉路(回路) 定理 有向图G具有一条单向欧拉回路,当且仅当是连通的, 且每个结点的出度等于入度.一个有向图G具有一条单向欧拉路,当且仅当它是连通的,而且除了两个节点为出度等于入度,但这两个结点中,一个的入度比出度大1,另一个出度比入度大1 汉密尔顿路,周游世界问题 定义 给定图G,若存在一条路经过图中每一个结点恰好一次,这条路称作汉密尔顿路. 若存在一条回路,经过图中每一个结点恰好一次, 称为汉密尔顿回路 定理 若图G = &lt;V,E具有汉密尔顿回路,则对于结点集V的每个非空子集S均有W(G-S) &lt;= |S|成立,.其中W(G-S)是G-S中的连通分支数目,常用来证明某些图是非汉密尔顿图 充分条件 设G具有n个结点的简单图,如果G中每一对结点度数之和大于等于n-1,则在G中存在一条汉密尔顿路 例 考虑在七天之内安排气门课程的考试,使得同一位教师所任的两门课考试不排在接连的两天中,证明如果没有教不同的老师担任,则在这两个结点之间有一条边,因为每一个老师所任课程不超过4,则每个节点的度数至少是3,任意两个结点度数之和至少是6,故G总是存在一条汉密尔顿路,它对应于一个七门考试科目的一个适当的安排 定理 设G是具有n个结点的简单图,如果G中每一对结点度数之和大于等于n,则在G中存在一条汉密尔顿回路 平面图, 设 G = &lt;V,E是一个无向图,如果能够把G的所有结点和边画在平面上,且使得任何两条边除了断点之外没有其它的交点,则成G是一个平面图 一个有限平面图,面的次数之和是边数的两倍, 欧拉定理 凸多面体, v个顶点,e条边,r块面,则v-e+r = 2, 同样对于一个联通的平面图G,共有v个结点,e条边,r个面,则欧拉公式 v-e+r = 2成立 定理 设G是一个由V个结点,e条边的连通简单平面图,若v&gt;=3,则e&lt;=3v-6 用该定理可判断某些图是否为非平面图 对偶图 树和生成树 定义 : 一个连通且无回路的的无向图称为树.书中度数为一的结点成为树叶,度数大于一的点称为分枝点或者内点. 一个无回路的无向图称为森林,他的每个连通分录称为森林 定理 任何一棵树中至少有两片树叶 若图G的生成子图是一个树,则成该树是G的一个生成树 设图G中有一棵生成树T,则T中的边叫做树枝,图G中不在树T中的称为弦, 弦的集合称为T的补 定理 连通图至少有一棵生成树 一条回路和任何一棵生成树的补至少有一条公共边 一个割边集和任何一棵生成树至少有一条公共边 在图G的所有生成树中,树权最小的那颗生成树称为最小生成树 最小生成树算法Kruskal 如果一个有向图在不考虑边的方向的情况下是一棵树, 那么,称这个有向图为有向树 根树及其应用 一棵有向树, 如果恰有一个结点的入度为0,其余所有结点的入度都为一,入度为0的结点称为根,出度为0的结点称为叶,出度不为零的结点称为分支点或者内点 层次,任意结点的层次就是从根到结点的单向通路长度 定义 在根树中, 若每一个结点的出度正好小于或等于m,称这棵树为m叉树. 如果每一个结点的出度恰好等于m或零, 则称这棵树为完全m叉树, 若所有树叶层次相同,则称为正则m叉树 设有完全m叉树, 其树叶数为t,分枝点数为i,(m-1)i = t-1 应用 : 假设有一台计算机, 它有一条加法指令,可计算三个数的和,如果要计算9个数的和,至少要执行几次加法指令 (3-1) i = 9-1 定义: 在根树中, 一个结点的通路长度,就是从树根到此节点的通路中的边数. 我们把分枝点的通路长度称为内部通路长度, 树叶的通路长度称为外部通路长度 定理 : 若完全二叉树有n个分枝点,且内部通路长度的总和为I, 外部通路长度的总和为E,则 E = I+2n 最优二叉树问题, 霍夫曼树, 前缀码问题。 附赠：来自csdn某位大佬贡献的各大OJ上有关的图论500题，已经按类按OJ型号题目位置划分完毕，可以供大家学习使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544=============================以下是最小生成树+并查集======================================【HDU】1213 How Many Tables 基础并查集★1272 小希的迷宫 基础并查集★1325&amp;&amp;poj1308 Is It A Tree? 基础并查集★1856 More is better 基础并查集★1102 Constructing Roads 基础最小生成树★1232 畅通工程 基础并查集★1233 还是畅通工程 基础最小生成树★1863 畅通工程 基础最小生成树★1875 畅通工程再续 基础最小生成树★1879 继续畅通工程 基础最小生成树★3371 Connect the Cities 简单最小生成树★1301 Jungle Roads 基础最小生成树★1162 Eddy&apos;s picture 基础最小生成树★1198 Farm Irrigation 基础最小生成树★1598 find the most comfortable road 枚举+最小生成树★★1811 Rank of Tetris 并查集+拓扑排序★★3926 Hand in Hand 同构图★3938 Portal 离线+并查集★★2489 Minimal Ratio Tree dfs枚举组合情况+最小生成树★4081 Qin Shi Huang&apos;s National Road System 最小生成树+DFS★★4126 Genghis Khan the Conqueror 枚举+最小生成树+DFS(难)★★★★-------------------------------------------------------------------1829&amp;&amp;poj2492 A Bug&apos;s Life 基础种类并查集★1558 Segment set 计算几何+并查集★3461 Code Lock 并查集(有点难想到)★★3367 Pseudoforest 最大生成树★2473 Junk-Mail Filter 并查集+设立虚父节点(马甲)★★3172 Virtual Friends 带权并查集★3635 Dragon Balls 带权并查集★3047 Zjnu Stadium 带权并查集★3038 How Many Answers Are Wrong 种类并查集★★2818 Building Block 带权并查集★3234 Exclusive-OR 异或并查集(难)★★★2121 Ice_cream’s world II 最小树形图(要输出根有点恶心)★★4009 Transfer water 最小树形图(模板题)★3311 Dig The Wells 斯坦纳树(状压DP)(模板题)★★4085 Peach Blossom Spring 斯坦纳树(状压DP)(有可能是森林...)★★★---------------------------------------------------------------------2586 How far away ？ LCA★2874 Connections between cities LCA★3486 Interviewe RMQ★2888 Check Corners 二维RMQ★3183 A Magic Lamp RMQ(有点难想到,有点难联系到RMQ)★★--------------------------------------------------------------------【POJ】1258 最经典的MST★1789 Truck History 最小生成树★1287 Networking 简单★2349 Arctic Network 简单★1611 The Suspects 并查集★2377 kruskal★2524 Ubiquitous Religions 并查集★2236 Wireless Network 并查集+计算几何★2560 Kruskal 并查集★1861 Kruskal ★3625 prim★1679 - The Unique MST(基础) 判断MST是否唯一★3522 - Slim Span(基础) 求一颗生成树，让最大边最小边差值最小★2485 Highways MST中的最长边★2395 最小生成树的最长边★1751 Highways 求出方案★POJ-1182 食物链 种类并查集★★POJ 1456 Supermarket 贪心+区间合并★POJ-1703 种类并查集★POJ-1988 种类并查集★POJ-1733 Parity game 种类并查集，先要离散化一下，不影响结果★POJ-1417 True Liars(难) 并查集+DP 种类并查集★★POJ-2912 Rochambeau(难) baidu的题,很不错...是食物链的加强版.判断裁判比较难想.★★★POJ 2728 Desert King(中等) 最优比率生成树★★POJ 1639 Picnic Planning(较难) 顶点度数有限制的最小生成树★★POJ 3164 Command Network(难) 最小树形图★★-------------------------------------------------------------------poj3723 好题!!! ★★poj3228 好好题!!! ★★-------------------------------------------------------------------【ZOJ】ZOJ-3261 逆向并查集 ★★===============================以下是最短路系列====================================【HDU】1548 A strange lift 基础最短路(或bfs)★2544 最短路 基础最短路★3790 最短路径问题 基础最短路★2066 一个人的旅行 基础最短路(多源多汇,可以建立超级源点和终点)★2112 HDU Today 基础最短路★1874 畅通工程续 基础最短路★1217 Arbitrage 货币交换 Floyd (或者 Bellman-Ford 判环)★1245 Saving James Bond 计算几何+最短路★1317 XYZZY Bellman-Ford判环,有负权★1535 Invitation Cards 有向图的来回最短路,(反向建图)★1546 Idiomatic Phrases Game 最短路★2680 Choose the best route 最短路★2923 Einbahnstrasse 最短路★3339 In Action 最短路+背包★2224 The shortest path 双调旅行商问题★★2807 The Shortest Path 矩阵运算+最短路(floyd)★★1595 find the longest of the shortest枚举+最短路(删掉任意一条边的最长最短路)★★3986 Harry Potter and the Final Battle 枚举+最短路(删掉任意一条边的最长最短路)★★1599 find the mincost route floyd求最小环★1839 Delay Constrained... 二分下限+最短路(带限制最短路)★★ 3631 Shortest Path Floyd插点法★★4114 Disney&apos;s FastPass 最短路+二维状压DP(难)★★★3832 Earth Hour 三点连通(斯坦纳树)★3873 Invade the Mars Dij变体(好题!,带限制最短路)★★★4063 Aircraft 几何构图+最短路★★★★-------------------------------------------------------------------hdu4179 Difficult Routes dis[][]开二维状态的最短路(带限制最短路)★★-------------------------------------------------------------------1869 六度分离 Floyd最短路★1385 Minimum Transport Cost 最短路+输出路径(输出字典序最小路径,有点恶心)★★ 1224 free DIY Tour 最短路+输出路径★1142 A Walk Through the Forest 最短路+记忆搜索★★1596 find the safest road 乘积最小的最短路★1598 find the most comfortable road 二分速度差+最短路(带限制最短路)★★2722 Here We Go(relians) Again 最短路★2962 Trucking 二分+最短路(带限制最短路)★★1690 Bus System 最短路★2433 Travel 删边+最短路之和(预处理桥边)★★★ 2363 Cycling 二分+最短路(带限制最短路)★★2377 Bus Pass 最短路(寻找一个点的最长最短路最小)★★2833 WuKong 最短路+记忆化搜索(求两条最短路的最多公共点)★★1688 Sightseeing 最短次短路条数★★3191 How Many Paths Are There 次短路条数★★2482 Transit search 最短路★★★3768 Shopping 最短路+dfs(或最短路+状压DP)★★3035 War 平面图最小割(建图麻烦)★★3870 Catch the Theves 平面图最小割(建图麻烦)★★3860 Circuit Board 平面图最小割(建图麻烦)★★-------------------------------------------------------------------【POJ】1062 昂贵的聘礼 竟然可以和最短路联系起来★★1094 Sorting It All Out Floyd判环+拓扑排序★1125 Stockbroker Grapevine Floyd★1135 Domino Effect 最短路,比较有意思★★1161 Walls 最短路(图太恶心了)★★1502 MPI Maelstrom Floyd★1511 Invitation Cards 来回最短路★1556 The Doors 计算几何+最短路★★1724 ROADS 带限制的最短路,dis[][]开二维来记录信息(或广搜)★★1734 Sightseeing trip floyd最小环路径★1797 Heavy Transportation 二分枚举+最短路★1847 Tram 简单最短路★1860 Currency Exchange 货币兑换★1949 Chores 反向建边,求最长路★★2139 Six Degrees of Cowvin Bacon Floyd★2240 Arbitrage 货币兑换★2253 Frogger 二分+最短路★2312 坦克大战 spfa最短路本质变形--&gt;广搜★2387 Til the Cows Come Home 基础最短路★2394 Checking an Alibi 最短路★2449 Remmarguts&apos; Date A*求第K短路★★2457 Part Acquisition 最短路 (输出路径)★★2472 106 miles to Chicago 乘积最短路(log一下,乘变加)★★-------------------------------------------------------------------2502 Subway2570 Fiber Network floyd3013 圣诞树3037 Skiing3072 Robot3114 Countries in War 强联通+最短路3160 Father Christmas flymouse 强联通+最长路3255 Roadblock3259 Wormholes （寻找负权回路）3268 Silver Cow Part3311 Hie with the Pie floyd+状压3328 Cliff Climbing3439 Server Relocation3463 Sightseeing 次短路条数3159 3521 Geometric Map 计算几何+最短路3549 GSM phone 计算几何+最短路3594 Escort of Dr. Who How3613 Cow Relays 经过N条边的最短路 // floyd + 二分矩阵3615 Cow Hurdles3621 最优比率环3635 full tank?3660 传递闭包3662 Telephone Lines============================以下是差分约束系列============================【HDU】1384 Intervals1529 Cashier Employment1531 King1534 Schedule Problem3440 House Man3592 World Exhibition3666 THE MATRIX PROBLEM-------------------------------------------------------------------【POJ】120112751364171629492983315931693687============================以下是二分匹配系列============================普通匹配,多重匹配【HDU】1068 Girls and Boys1150 Machine Schedule1151 Air Raid1179 Ollivanders: Makers of Fine Wands since 382 BC.1281 棋盘游戏1498 50 years, 50 colors1507 Uncle Tom&apos;s Inherited Land*1528 Card Game Cheater1845 Jimmy’s Assignment2063 过山车2119 Matrix2444 The Accomodation of Students2768 Cat vs. Dog3081 Marriage Match II3360 National Treasures1045 也可搜索1350 最小路径覆盖3118 类似二分匹配3729238910542819 完全匹配1668 二分+多重匹配3605 多重匹配3861 强连通+二分匹配2236 无题II-------------------------------------------------------------------hdu3468hdu4185 奇偶匹配-------------------------------------------------------------------【POJ】1087 A Plug for UNIX1274 The Perfect Stall1469 COURSES1486 Sorting Slides 二分图的必须边1548 Robots1698 Alice&apos;s Chance1719 Shooting Contest1904 King&apos;s Quest 求二分图所有可能的匹配边2060 Taxi Cab Scheme 最小路径覆盖2112 Optimal Milking 二分+多重匹配2226 Muddy Fields 行列的覆盖2239 Selecting Courses2289 Jamie&apos;s Contact Groups 二分+多重匹配2446 Chessboard2536 Gopher II2584 T-Shirt Gumbo2594 Treasure Exploration 可相交最小路径覆盖2672 Hotkeys2724 Purifying Machine3020 Antenna Placement3041 Asteroids 简单行列匹配 3189 Steady Cow Assignment 二分+多重匹配3207 Ikki&apos;s Story IV - Panda&apos;s Trick3216 Repairing Company3343 Against Mammoths3692 Kindergarten2771 最大独立集============================以下是KM算法系列============================【HDU】2255 奔小康赚大钱1533 Going Home1853 Cyclic Tour3488 Tour3435 A new Graph Game2426 Interesting Housing Problem2853 Assignment3718 Similarity3722 Card Game3395 Special Fish2282 Chocolate2813 One fihgt one2448 Mining Station on the Sea3315 My Brute3523 Image copy detection-------------------------------------------------------------------【POJ】2195 Going Home 最小权值匹配2400 Supervisor, Supervisee 输出所有最小权匹配2516 Minimum Cost 最小权值匹配或最小费用流3565 Ants3686 The Windy&apos;s 最小权值匹配 ============================以下是最大团&amp;稳定婚姻系列============================【HDU】-------------------------------------------------------------------1530 Maximum Clique1435 Stable Match3585 maximum shortest distance 二分+最大团1522 Marriage is Stable1914 The Stable Marriage Problem-------------------------------------------------------------------【POJ】-------------------------------------------------------------------1129 四色定理 着色问题1419 最大独立集2989 极大团3487 The Stable Marriage Problem 稳定婚姻============================以下是强双联通系列============================【HDU】强连通:1269 迷宫城堡 判断是否是一个强连通2767 Proving Equivalences 至少加几条边让整个图变成强连通3836 Equivalent Sets 至少加几条边让整个图变成强连通1827 Summer Holiday 传递的最小费用3072 Intelligence System 传递的最小费用3861 The King’s Problem 强连通+二分匹配3639 Hawk-and-Chicken 强连通缩点 + 树形dp（累加子节点的总权值）3594 Cactus 仙人掌图-------------------------------------------------------------------双连通:2242 考研路茫茫——空调教室 双联通缩点+树形DP2460 Network 边双连通3849 By Recognizing These Guys, We Find Social Networks Useful 双连通求桥3896 Greatest TC 双连通4005 The war 边双连通-------------------------------------------------------------------LCA:2586 How far away ？2874 Connections between cities3078 Network LCA+排序3830 Checkers 二分+LCA-------------------------------------------------------------------【POJ】强连通:1236 Network of Schools2553 The Bottom of a Graph 好题！ 找出度为0的集合2186 Popular Cows 好题！ 找出度为0的，其他分量都指向它的集合2375 Cow Ski Area 强连通2762 Going from u to v or from v to u? 缩点+拓扑排序3160 Father Christmas flymouse 强连通+最短路3180 The Cow Prom 判断有几个环， 分量中元素大于1的个数3114 Countries in War 强连通+最短路3592 Instantaneous Transference 强连通分量+最长路1904 King&apos;s Quest 强连通+并查集 ------------------------------------------------------------------- 双连通：3694 Network 边双连通 (同hdu2460)3177 Redundant Paths 构造边双连通3352 Road Construction 构造边双连通2942 Knights of the Round Table (点双连通经典题)1515 Street Directions (无向图改有向图)1438 One-way Traffic (混合图改有向图)-------------------------------------------------------------------LCA:1330 Nearest Common Ancestors1470 Closest Common Ancestors1986 Distance Queries3417 Network3728 The merchant LCA+并查集,更新询问2763 Housewife Wind LCA+树状数组============================以下是2-SAT系列============================【HDU】3062 Party1824 Let&apos;s go home3622 Bomb Game3715 Go Deeper1815 Building roads2723 Get Luffy Out1816 Get Luffy Out *1814 Peaceful Commission4115 Eliminate the Conflict-------------------------------------------------------------------【POJ】2296 Map Labeler2723 Get Luffy Out2749 Building roads3207 Ikki&apos;s Story IV - Panda&apos;s Trick3648 Wedding3678 Katu Puzzle3683 Priest John&apos;s Busiest Day3905 Perfect Election============================以下是欧拉回路系列============================【HDU】1878 欧拉回路 判断3018 Ant Trip 一笔画问题11162894 兹鼓欧拉回路19563472 混合欧拉-------------------------------------------------------------------【POJ】2513 欧拉路1041 John&apos;s trip 欧拉回路1386 Play on Words 单词接龙2230 Watchcow 欧拉回路2513 Colored Sticks 无向图欧拉路2337 Catenyms 欧拉路径1392 Ouroboros Snake 兹鼓欧拉回路1780 code1637 混合欧拉-------------------------------------------------------------------【zoj】1992============================以下是拓扑排序系列============================【HDU】 1285 确定比赛名次2094 产生冠军2647 Reward3342 Legal or Not1811 Rank of Tetris 拓扑+并查集3231 三维拓扑-------------------------------------------------------------------【POJ】1094 Sorting It All Out Floyd+拓扑2367 Genealogical tree3660 Cow Contest3687 Labeling Balls 神奇的拓扑1128 Frame Stacking DFS版拓扑1270 Following Orders 拓扑+回溯1420 Spreadsheet 模拟拓扑2762 Going from u to v or from v to u? 强连通+拓扑3553 Task schedule============================以下是竞赛图系列============================竞赛图下的哈密顿问题Strange Country II ZOJ-3332Task Sequences POJ-1776The book SGU-122Tour Route POJ-3780Tour Route HDOJ-3414============================以下是网络流系列============================【HDU】-------------------------------------------------------------------1532 Drainage Ditches(基础) [最大流]3549 Flow Problem(基础) [最大流]3572 Task Schedule [最大流]任务分配,判断满流 2732 Leapin&apos; Lizards(难) [最大流]3338 Kakuro Extension [最大流][数和]神奇最大流行进列出2883 kebab [最大流]判断满流3605 Escape [最大流](多重匹配3081 Marriage Match II [二分最大流]+并查集3277 Marriage Match III [二分最大流]同上,多了拆点3416 Marriage Match IV [最大流]最短路+最大流2485 Destroying the bus stations [最大流]最短路+最大流3468 Treasure Hunting [最大流](二分匹配)+最短路3551 Hard Problem [最大流]3998 Sequence(难) [DP+最大流]最长上升子序列3917 Road constructions [最大权闭包]3879 Base Station [最大权闭包]3061 Battle [最大权闭包]3996 Gold Mine [最大权闭包]3472 HS BDC [混合欧拉]hdu4183 来回走不重复点的网络流.-------------------------------------------------------------------1533 Going Home(基础) [费用流]3488 Tour [费用流]圈3435 A new Graph Game [费用流]圈1853 Cyclic Tour [费用流]圈2686 Matrix [费用流]3376 Matrix Again [费用流]3667 Transportation [费用流]拆边3315 My Brute [费用流](可用KM)3395 Special Fish [费用流](可用KM匹配)2448 Mining Station on the Sea [费用流](可用最短路+KM匹配)4067 Random Maze(难) [费用流]3947 River Problem(难) [费用流]神奇费用流,流量不等式建图3046 Pleasant sheep and big big wolf [最小割]1565 方格取数(1) [最小割]1569 方格取数(2) [最小割]3820 Golden Eggs [最小割]方格加强3491 Thieves [最小割]最小点割集3657 Game [最小割]最大点权独立集3313 Key Vertex [最小割]3251 Being a Hero [最小割] 3157 Crazy Circuits [上下流]3002 King of Destruction [全局最小割]3691 Nubulsa Expo [全局最小割]【POJ】1087 A Plug for UNIX [最大流](可用二分匹配)1274 The Perfect Stall [最大流](可用二分匹配)1325 Machine Schedule [最大流](可用二分匹配)1698 Alice&apos;s Chance [最大流](可用二分匹配)2239 Selecting Courses [最大流](可用二分匹配)2446 Chessboard [最大流](可用二分匹配) 好题啊2536 Gopher II [最大流](可用二分匹配)2771 Guardian of Decency [最大流]二分匹配最大独立集3041 Asteroids [最大流](简单二分匹配)2584 T-Shirt Gumbo [最大流](多重匹配)3189 Steady Cow Assignment(中等) [二分最大流](多重匹配)1149 PIGS [最大流] 绝对经典的构图题1273 Drainage Ditches [最大流](基础)1459 Power Network(基础) [最大流]3281 Dining [最大流]2112 Optimal Milking(基础) [二分最大流]2289 Jamie&apos;s Contact Groups [二分最大流]2391 Ombrophobic Bovines(中等) [二分最大流]2455 Secret Milking Machine(基础) [二分最大流]3228 Gold Transportation [二分最大流](并查集)2699 The Maximum Number of Strong Kings(较难) [枚举人数 + 最大流]3498 March of the Penguins(中等) [最大流]枚举汇点,满足点容量限制的网络流2987 Firing(较难) [最大权闭包]1637 Sightseeing tour(Crazy) [混合欧拉]2135 Farm Tour [费用流] (来回最短路)2175 Evacuation Plan(中等) [费用流] 消圈2195 Going Home [费用流]2516 Minimum Cost [费用流]3422 Kaka&apos;s Matrix Travels(中等) [费用流]拆点3680 Intervals(较难) [费用流]经典,费用流+离散化3686 The Windy&apos;s [费用流](KM匹配)3762 The Bonus Salary! [费用流]1815 Friendship(中等) [最小割]最小点割集1966 Cable TV Network(中等) [最小割]最小点割集2125 Destroying The Graph(难) [最小割]最小点权覆盖3084 Panic Room(中等，好题) [最小割]边连通度3204 Ikki&apos;s Story I - Road Reconstruction(基础) [最小割]求关键边3308 Paratroopers(较难) [最小割]乘积取对数,最小点权覆盖3436 ACM Computer Factory [最小割]收集流,残留搜集找边3469 Dual Core CPU(中等) [最小割]收集流3921 Destroying the bus stations [最小割]点连通2396 Budget(中等) [有源汇的上下界可行流]3155 Hard Life(很挑战一题) [最大密度子图]2914 Minimum Cut [无向图最小割]============================以下是dancing links系列============================1001 Easy Finding POJ-37401002 Power Stations HDOJ-36631003 Treasure Map ZOJ-32091004 Lamp HDOJ-28281005 whosyourdaddy HDOJ-34981006 Bomberman - Just Search! HDOJ-35291007 Square Destroyer POJ-10841008 Matrix HDOJ-21191009 Divisibility HDOJ-33351010 Radar HDOJ-22951011 Fire station HDOJ-36561012 Repair Depots HDOJ-31561013 Dominoes HDOJ-25181014 Street Fighter HDOJ-39571015 Sudoku Killer HDOJ-14261016 Sudoku POJ-26761017 Sudoku POJ-30741018 Sudoku POJ-30761019 Su-Su-Sudoku HDOJ-27801020 Sudoku HDOJ-31111021 Sudoku HDOJ-39091022 Squiggly Sudoku HDOJ-40691023 Triangle War II ZOJ-30381024 A Puzzling Problem HDOJ-16031025 Maximum Clique HDOJ-1530hust1017 精确覆盖。fzu1686,nuaa1507 重复覆盖。hit2199,2882,2959 精确覆盖(数独)。SPOJ1771 精确覆盖(N皇后问题)。poj3435]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>algorithm</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c结构指针]]></title>
    <url>%2F2018%2F06%2F01%2Ffifth%2F</url>
    <content type="text"><![CDATA[这篇文章内容介绍非常清楚，可以弄下来仅供参考。指针结构与指针的关系亦有两重：其一是在定义结构时，将指针作为结构中的一个成员；其二是指向结构的指针（称为结构指针）。前者同一般的结构成员一样可直接进行访问，后者是本节讨论的重点。 结构指针说明的一般形式是：struct 结构类型名称 结构指针变量名；例如：struct date pdate, today;说明了两个变量，一个是指向结构date的结构指针pdate，today是一个date结构变量。语句：12345pdate = &amp;today;pdate today (struct date) year month day 通过结构变量today访问其成员的操作，也可以用等价的指针形式表示：today.year = 2001; 等价于 (pdate).year = 2001;由于运算符”“的优先级比运算符”.”的优先级低，所以必须有”( )”将pdate括起来。若省去括号，则含义就变成了”(pdate.year)”。在Ｃ语言中，通过结构指针访问成员可以采用运算符”-&gt;”进行操作，对于指向结构的指针，为了访问其成员可以采用下列语句形式：结构指针-&gt;成员名;这样，上面通过结构指针pdate访问成员year的操作就可以写成：pdate-&gt;year = 2001;如果结构指针p指向一个结构数组，那么对指针p的操作就等价于对数组下标的操作。 结构指针是指向一种结构类型的指针变量，它是结构在内存中的首地址，结构指针具有一般指针的特性，如在一定条件下两个指针可以进行比较，也可以与整数进行加减。但在指针操作时应注意：进行地址运算时的放大因子由所指向的结构的实际大小决定。 例11-7用结构指针改写加密程序123456789101112131415161718192021#include &quot;stdio.h&quot;struct table&#123; char input, output;&#125; ;struct table translate[ ]=&#123; &apos;a&apos;, &apos;d&apos;, &apos;b&apos;, &apos;w&apos;, &apos;c&apos;, &apos;k&apos;, &apos;d&apos;, &apos;;&apos; , &apos;e&apos;, &apos;i&apos;,&apos;i&apos;, &apos;a&apos;, &apos;k&apos;, &apos;b&apos;, &apos;;&apos;, &apos;c&apos;, &apos;w&apos;, &apos;e&apos;&#125;; /* 建立加密对照表 */main( )&#123; char ch;struct table *p, *pend; /* p和pend为指向结构table的指针 */pend = &amp; translate[ sizeof(translate)/sizeof(struct table)-1 ];/* pend指向结构数组translate的最后一个元素 */while ( (ch=getchar( )) != &apos;/n&apos;)&#123; for ( p=translate ; p-&gt;input!=ch &amp;&amp; p!=pend; p++ ) ;if ( p-&gt;input==ch ) putchar( p-&gt;output);elseputchar (ch);&#125;&#125; 读者可以将两个程序对照阅读，体会结构指针特点。程序中用pend指向数组的最后一个元素。由于结构指针和在结构中将指针作为成员，使得对于结构变量的运算和对成员的操作变得较为复杂。由于取内容的”*”与”.”和”-&gt;”运算符的优先级与结合性不同，使得对成员的访问和操作又增加了一层难度，再因为”++”和”–”运算所具有的”先操作”与”后操作”的特性，以及”++”和”–”运算的结合性，使得”++”和–”运算与结构操作混合在一起时，实际操作会更为复杂。 例11-8 请分析程序的运算结果。 123456789101112131415161718192021222324252627282930313233#include &quot;stdio.h&quot;struct s&#123; int x, *y; /* y: 结构中的成员是指向整型的指针 */&#125; *p; /* p: 指向结构的指针 */int data[5]=&#123;10, 20, 30, 40, 50,&#125;; /* data: 整型数组 */struct s array[5]=&#123; 100, &amp;data[0], 200, &amp;data[1], 300, &amp;data[2],400, &amp;data[3], 500, &amp;data[4]&#125;; /* array: 结构数组 */main ( )&#123; p=array; /* 指针p指向结构数组的首地址 */printf (&quot;For printer:/n&quot;);printf (&quot;%d/n&quot;, p-&gt;x);printf (&quot;%d/n&quot;, (*p).x); printf (&quot;%d/n&quot;, *p-&gt;y);printf (&quot;%d/n&quot;, *(*p).y);printf (&quot;%d/n&quot;, ++p-&gt;x);printf (&quot;%d/n&quot;, (++p)-&gt;x);printf (&quot;%d/n&quot;, p-&gt;x++);printf (&quot;%d/n&quot;, p-&gt;x); printf (&quot;%d/n&quot;, ++ (*p-&gt;y));printf (&quot;%d/n&quot;, ++ * p-&gt;y); printf (&quot;%d/n&quot;, * ++ p-&gt;y);printf (&quot;%d/n&quot;, p-&gt;x); printf (&quot;%d/n&quot;, * (++p)-&gt;y);printf (&quot;%d/n&quot;, p-&gt;x); printf (&quot;%d/n&quot;, * p-&gt;y ++);printf (&quot;%d/n&quot;, p-&gt;x); printf (&quot;%d/n&quot;, * (p-&gt;y) ++);printf (&quot;%d/n&quot;, p-&gt;x); printf (&quot;%d/n&quot;, * p ++ -&gt;y);printf (&quot;%d/n&quot;, p-&gt;x);&#125; 结构数组array的初始化后的状态如图11.4所示。程序中指针操作的含义如下： 1234567891011121314151617181920p-&gt;x /* 取结构指针p指向的结构的成员x的值，输出 100 */(*p).x /* 取结构指针p的内容的成员x的值，功能同上，输出 100 */*p-&gt;y /* 取结构指针p的指针成员y的内容，输出 10 */*(*p).y /* 取结构指针p的内容的指针成员y的内容，功能同上，输出10 */++p-&gt;x /* p所指的x加1，x先加1后再输出 101 ，p不加1 */(++p)-&gt;x /* p先加1后再取x的值，x不加1，输出 200 */p-&gt;x++ /* 先取x的值后x再加1，输出 200 */p-&gt;x /* 输出 201 */++(*p-&gt;y) /* p所指的y的内容先加1，输出 21 ，p不加1，y也不加1 */++ *p-&gt;y /* 同上，由运算的结合性隐含了括号，输出 22 */* ++p-&gt;y /* y先加1后再取y的内容，输出30，p不加1，y的内容不加1 */p-&gt;x /* 输出 201 */*(++p)-&gt;y /* p先加1后取所指y的内容，输出 30 */p-&gt;x /* 输出 300 */*p-&gt;y ++ /* 取p所指的y的内容，输出 30，然后p所指的y加1 */p-&gt;x /* 输出 300 */*(p-&gt;y)++ /* 取p所指的y的内容，输出 40，然后p所指的y加1 */p-&gt;x /* 输出 300 */*p++-&gt;y /* 取p所指的y的内容，输出 50，然后p加1 */p-&gt;x /* 输出 400 */ 例11-9可用一个结构表示学生的学号和成绩，编写程序，对班中30名学生按成绩进行排序，并输出排序后的学号、成绩和全班平均分。 123456789101112131415161718192021222324252627282930#define STNUM 30 /* 全班同学人数 */struct stuinf&#123; int stid; /* 学生学号 */int score; /* 学生成绩 */&#125; stu[STNUM]; /* stu: 结构数组 */main ( )&#123; struct stuinf *ptemp, /* ptemp:指向结构的指针, 临时变量 */*p[STNUM]; /* p:指向结构的指针构成的指针数组 */int i, j, k, sum=0; /* i,j,k:临时变量；sum:分数累计 */for (i=0; i&lt;=STNUM-1; i++) /* 输入学生的学号和成绩 */&#123; scanf (&quot;%d%d&quot;, &amp;stu[i].stid, &amp;stu[i].score); /* 输入学生的学号和成绩 */p[i] = &amp;stu[i];/* 指针数组p[i]的第i个指针(元素)指向结构数组的第i个元素 */sum += stu[i].score; /* 累计学生的分数 */&#125;for ( i=0; i&lt;=STNUM-2; i++ ) /* 排序操作 */&#123; k = i; /* k：在第i次循环中，指向当前最高分的指针在指针数组p中的下标 */for (j=i; j&lt;=STNUM-1; j++)if (p[k]-&gt;score &lt; p[j]-&gt;score) k=j;/* 查找当前最大值, k中存放最大值对应的指针在指针数组p中的下标 */if ( k!=i ) /* 当k不等于i时，交换两个指向结构的指针 */&#123; ptemp = p[i];p[i] = p[k];p[k] = ptemp;&#125;&#125;for (i=0; i&lt;=STNUM-1; i++) /* 按排序顺序输出学号和成绩 */printf(&quot;%d,%d/n&quot;, (*p[i]).stid, p[i]-&gt;score);printf (&quot;average score = %d/n&quot;, sum/STNUM); /* 输出平均分 */&#125; 总结 程序中使用了较为复杂的数据结构，包括：结构数组stu，指向结构的指针ptemp，由指向结构的指针构成的指针数组p。程序在结构数组stu和指针数组p之间建立了对应的指针关系，从而为简化后续处理打下了良好的基础。在排序过程中，程序使用选择排序的思想，先查找确定当前的最大值，再进行一次有实效的数据交换。进行数据交换时，也没有交换结构数据本身，而是交换了指向结构数据的指针。在输出时，按照排序后指针的顺序，输出排序后的数据。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关java中@的代指--注解]]></title>
    <url>%2F2018%2F06%2F01%2Fjava%40%2F</url>
    <content type="text"><![CDATA[java中的注解，java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标准(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。 什么是java注解 注解，顾名思义，注解,就是对某一事物进行添加注释说明，会存放一些信息，这些信息可能对以后某个时段来说是很有用处的。 Java注解又叫java标注，java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标准(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。 自定义Java标注为什么要自定义注解 Java从1.5版本以后默认内置三个标注：Ø @Override:只能用在方法之上的，用来告诉别人这一个方法是改写父类的。Ø @Deprecated:建议别人不要使用旧的API的时候用的,编译的时候会用产生警告信息,可以设定在程序里的所有的元素上.Ø @SuppressWarnings:这一个类型可以来暂时把一些警告信息消息关闭.但是，仅仅这三个标注是不能满足我们开发时一些需求的。所以java允许我们自定义注解来使用。 如何自定义注解 自定义步骤大致分为两步： 1通过@interface关键字(注意，不是interface，是@interace)声明注解名称，以及注解的成员属性或者叫做注解的参数。 2使用java内置的四个元注解对这个自定义标注的功能和范围进行一些限制问题来了，什么是元注解？ 什么是元注解 元注解，就是定义注解的注解，也就是说这些元注解是的作用就是专门用来约束其它注解的注解。请区别上面那三个注解，他们也是通过元注解定义而来的。元注解有哪些呢，主要有四个@Target,@Retention,@Documented,@Inherited？元注解有： 123456789101112131415@Target,@Retention,@Documented,@Inherited @Target 表示该注解用于什么地方，可能的 ElemenetType 参数包括： ElemenetType.CONSTRUCTOR 构造器声明 ElemenetType.FIELD 域声明（包括 enum 实例） ElemenetType.LOCAL_VARIABLE 局部变量声明 ElemenetType.METHOD 方法声明 ElemenetType.PACKAGE 包声明 ElemenetType.PARAMETER 参数声明 ElemenetType.TYPE 类，接口（包括注解类型）或enum声明 @Retention 表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括： RetentionPolicy.SOURCE 注解将被编译器丢弃 RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 @Documented 将此注解包含在 javadoc 中 @Inherited 允许子类继承父类中的注解 自定义及使用注解示例12345678910111213141516171819202122232425262728//自定义一个类级别的标注Description package lighter.javaeye.com;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)//这个标注应用于类@Retention(RetentionPolicy.RUNTIME)//标注会一直保留到运行时@Documented//将此注解包含在javadoc中public @interface Description &#123;String value();&#125; 再定义个方法级别的注解Namepackage lighter.javaeye.com;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; //注意这里的@Target与@Description里的不同,参数成员也不同@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Name &#123;String originate();String community();&#125; 然后使用以上两个注解1234567891011121314package lighter.javaeye.com; @Description(value=&quot;javaeye,做最棒的软件开发交流社区&quot;) public class JavaEyer &#123; @Name(originate=&quot;创始人:robbin&quot;,community=&quot;javaEye&quot;) public String getName() &#123; return null; &#125; @Name(originate=&quot;创始人:江南白衣&quot;,community=&quot;springside&quot;) public String getName2() &#123; return &quot;借用两位的id一用,写这一个例子,请见谅!&quot;; &#125; &#125; 说明：其中标注“@Description(value=”javaeye,做最棒的软件开发交流社区”)”，可以写成“@Description(“javaeye,做最棒的软件开发交流社区”) ”，结果也是一样的。因为Description标注定义的时候其参数(或者说属性)为value。而value比较特殊，它在被指定参数的时候可以不用显示的写出来。当然如果定义的时候参数名不是value而是其它的比如des，那么使用注解的时候，必须显示写出参数名，然后再赋值：@Description(Des=”xxx”)提取出注解的信息1234567891011121314151617181920212223242526272829303132 package lighter.javaeye.com; import java.lang.reflect.Method; import java.util.HashSet; import java.util.Set; public class TestAnnotation &#123; /*** author lighter* 说明:具体关天Annotation的API的用法请参见javaDoc文档*/ public static void main(String[] args) throws Exception &#123; String CLASS_NAME = &quot;lighter.javaeye.com.JavaEyer&quot;; Class test = Class.forName(CLASS_NAME); Method[] method = test.getMethods(); boolean flag = test.isAnnotationPresent(Description.class); if(flag) &#123; Description des = (Description)test.getAnnotation(Description.class); System.out.println(&quot;描述:&quot;+des.value()); System.out.println(&quot;-----------------&quot;); &#125; //把JavaEyer这一类有利用到@Name的全部方法保存到Set中去 Set&lt;Method&gt; set = new HashSet&lt;Method&gt;(); for(int i=0;i&lt;method.length;i++) &#123; boolean otherFlag = method[i].isAnnotationPresent(Name.class); if(otherFlag) set.add(method[i]); &#125; for(Method m: set) &#123; Name name = m.getAnnotation(Name.class); System.out.println(name.originate()); System.out.println(&quot;创建的社区:&quot;+name.community()); &#125; &#125;&#125; 注意事项 所有的Annotation会自动继承java.lang.annotation这一个接口,所以不能再去继承别的类或是接口. 最重要的一点,Annotation类型里面的参数该怎么设定: 第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型. 第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String.]]></content>
      <categories>
        <category>JAVA SE</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2018%2F06%2F01%2Fforth%2F</url>
    <content type="text"><![CDATA[我们总是探讨求解最优的问题，却总是忽略了求解的过程，如何达到最优化的问题，才是我们应该研究的目的，综上贪心算法便给我们提供了一点思路。 一、基本概念： 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 二、贪心算法的基本思路： 1.建立数学模型来描述问题。2.把求解的问题分成若干个子问题。3.对每一子问题求解，得到子问题的局部最优解。4.把子问题的解局部最优解合成原来解问题的一个解。 三、贪心算法适用的问题 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。 四、贪心算法的实现框架123456从问题的某一初始解出发；while （能朝给定总目标前进一步）&#123; 利用可行的决策，求出可行解的一个解元素；&#125;由所有解元素组合成问题的一个可行解； 五、贪心策略的选择 因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。 六、例题分析 下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。 背包问题 有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。物品 A B C D E F G重量 35 30 60 50 40 10 25价值 10 40 30 50 35 40 30分析：目标函数： ∑pi最大约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？（2）每次挑选所占重量最小的物品装入是否能得到最优解？（3）每次选取单位重量价值最大的物品，成为解本题的策略。值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。可惜的是，它需要证明后才能真正运用到题目的算法中。一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：（1）贪心策略：选取价值最大者。反例：W=30物品：A B C重量：28 12 12价值：30 20 20根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。（3）贪心策略：选取单位重量价值最大的物品。反例：W=30物品：A B C重量：28 20 10价值：28 20 10根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。比如，求最小生成树的Prim算法和Kruskal算法都是漂亮的贪心算法。 均分纸牌 有N堆纸牌，编号分别为1，2，…，n。每堆上有若干张,但纸牌总数必为n的倍数.可以在任一堆上取若干张纸牌,然后移动。移牌的规则为：在编号为1上取的纸牌，只能移到编号为2的堆上；在编号为n的堆上取的纸牌，只能移到编号为n-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。例如：n=4，4堆纸牌分别为：① 9 ② 8 ③ 17 ④ 6 移动三次可以达到目的：从③取4张牌放到④ 再从③区3张放到②然后从②去1张放到①。输入输出样例：49 8 17 6屏幕显示：3算法分析：设a[i]为第I堆纸牌的张数（0&lt;=I&lt;=n），v为均分后每堆纸牌的张数，s为最小移动次数。我们用贪心算法，按照从左到右的顺序移动纸牌。如第I堆的纸牌数不等于平均值，则移动一次（即s加1），分两种情况移动：1．若a[i]&gt;v，则将a[i]-v张从第I堆移动到第I+1堆；2．若a[i]&lt;v，则将v-a[i]张从第I+1堆移动到第I堆。为了设计的方便，我们把这两种情况统一看作是将a[i]-v从第I堆移动到第I+1堆，移动后有a[i]=v; a[I+1]=a[I+1]+a[i]-v.在从第I+1堆取出纸牌补充第I堆的过程中可能回出现第I+1堆的纸牌小于零的情况。如n=3，三堆指派数为1 2 27 ，这时v=10，为了使第一堆为10，要从第二堆移9张到第一堆，而第二堆只有2张可以移，这是不是意味着刚才使用贪心法是错误的呢？我们继续按规则分析移牌过程，从第二堆移出9张到第一堆后，第一堆有10张，第二堆剩下-7张，在从第三堆移动17张到第二堆，刚好三堆纸牌都是10，最后结果是对的，我们在移动过程中，只是改变了移动的顺序，而移动次数不便，因此此题使用贪心法可行的。Java源程序： 123456789101112131415161718192021222324public class Greedy &#123; public static void main(String[] args) &#123; int n = 0, avg =0, s = 0; Scanner scanner = new Scanner(System.in); ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); System.out.println(&quot;Please input the number of heaps:&quot;); n = scanner.nextInt(); System.out.println(&quot;Please input heap number:&quot;); for (int i = 0; i &lt; n; i++) &#123; array.add(scanner.nextInt()); &#125; for(int i = 0; i &lt; array.size(); i ++)&#123; avg += array.get(i); &#125; avg = avg/array.size(); System.out.println(array.size()); System.out.println(avg); for(int i = 0; i &lt; array.size()-1; i ++)&#123; s++; array.set(i+1, array.get(i+1)+array.get(i)-avg); &#125; System.out.println(&quot;s:&quot; + s); &#125;&#125; 利用贪心算法解题，需要解决两个问题：一是问题是否适合用贪心法求解。我们看一个找币的例子，如果一个货币系统有三种币值，面值分别为一角、五分和一分，求最小找币数时，可以用贪心法求解；如果将这三种币值改为一角一分、五分和一分，就不能使用贪心法求解。用贪心法解题很方便，但它的适用范围很小，判断一个问题是否适合用贪心法求解，目前还没有一个通用的方法，在信息学竞赛中，需要凭个人的经验来判断。二是确定了可以用贪心算法之后，如何选择一个贪心标准，才能保证得到问题的最优解。在选择贪心标准时，我们要对所选的贪心标准进行验证才能使用，不要被表面上看似正确的贪心标准所迷惑，如下面的例子。 最大整数 设有n个正整数，将它们连接成一排，组成一个最大的多位整数。例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。输入：nN个数输出：连成的多位数算法分析：此题很容易想到使用贪心法，在考试时有很多同学把整数按从大到小的顺序连接起来，测试题目的例子也都符合，但最后测试的结果却不全对。按这种标准，我们很容易找到反例：12，121应该组成12121而非12112，那么是不是相互包含的时候就从小到大呢？也不一定，如12，123就是12312而非12123，这种情况就有很多种了。是不是此题不能用贪心法呢？其实此题可以用贪心法来求解，只是刚才的标准不对，正确的标准是：先把整数转换成字符串，然后在比较a+b和b+a，如果a+b&gt;=b+a，就把a排在b的前面，反之则把a排在b的后面。 java源程序：123456789101112131415161718192021222324public static void main(String[] args)&#123; String str = &quot;&quot;; ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); Scanner in = new Scanner(System.in); System.out.println(&quot;Please input the number of data:&quot;); int n = in.nextInt(); System.out.println(&quot;Please input the data:&quot;); while (n-- &gt; 0) &#123; array.add(in.next()); &#125; for(int i = 0; i &lt; array.size(); i ++) for(int j = i + 1; j &lt; array.size(); j ++)&#123; if((array.get(i) + array.get(j)).compareTo(array.get(j) + array.get(i)) &lt; 0)&#123; String temp = array.get(i); array.set(i, array.get(j)); array.set(j, temp); &#125; &#125; for(int i = 0; i &lt; array.size(); i ++)&#123; str += array.get(i); &#125; System.out.println(&quot;str=:&quot;+str); &#125;&#125; 贪心算法所作的选择可以依赖于以往所作过的选择，但决不依赖于将来的选择，也不依赖于子问题的解，因此贪心算法与其他算法相比具有一定的速度优势。如果一个问题可以同时用几种方法解决，贪心算法应该是最好的选择之一。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针-C]]></title>
    <url>%2F2018%2F06%2F01%2Fthird%2F</url>
    <content type="text"><![CDATA[指针是Ｃ语言中广泛使用的一种数据类型。 运用指针编程是Ｃ语言最主要的风格之一。利用指针变量可以表示各种数据结构； 能很方便地使用数组和字符串； 并能象汇编语言一样处理内存地址，从而编出精练而高效的程序。指针极大地丰富了Ｃ语言的功能。 学习指针是学习Ｃ语言中最重要的一环， 能否正确理解和使用指针是我们是否掌握Ｃ语言的一个标志。同时， 指针也是Ｃ语言中最为困难的一部分，在学习中除了要正确理解基本概念，还必须要多编程，上机调试。只要作到这些，指针也是不难掌握的。 指针的基本概念 在计算机中，所有的数据都是存放在存储器中的。 一般把存储器中的一个字节称为一个内存单元， 不同的数据类型所占用的内存单元数不等，如整型量占2个单元，字符量占1个单元等， 在第二章中已有详细的介绍。为了正确地访问这些内存单元， 必须为每个内存单元编上号。 根据一个内存单元的编号即可准确地找到该内存单元。内存单元的编号也叫做地址。 既然根据内存单元的编号或地址就可以找到所需的内存单元，所以通常也把这个地址称为指针。 内存单元的指针和内存单元的内容是两个不同的概念。 可以用一个通俗的例子来说明它们之间的关系。我们到银行去存取款时， 银行工作人员将根据我们的帐号去找我们的存款单， 找到之后在存单上写入存款、取款的金额。在这里，帐号就是存单的指针， 存款数是存单的内容。对于一个内存单元来说，单元的地址即为指针， 其中存放的数据才是该单元的内容。在Ｃ语言中， 允许用一个变量来存放指针，这种变量称为指针变量。因此， 一个指针变量的值就是某个内存单元的地址或称为某内存单元的指针。图中，设有字符变量C，其内容为“K”(ASCII码为十进制数 75)，C占用了011A号单元(地址用十六进数表示)。设有指针变量P，内容为011A， 这种情况我们称为P指向变量C，或说P是指向变量C的指针。 严格地说，一个指针是一个地址， 是一个常量。而一个指针变量却可以被赋予不同的指针值，是变。 但在常把指针变量简称为指针。为了避免混淆，我们中约定：“指针”是指地址， 是常量，“指针变量”是指取值为地址的变量。 定义指针的目的是为了通过指针去访问内存单元。 既然指针变量的值是一个地址， 那么这个地址不仅可以是变量的地址， 也可以是其它数据结构的地址。在一个指针变量中存放一个数组或一个函数的首地址有何意义呢？ 因为数组或函数都是连续存放的。通过访问指针变量取得了数组或函数的首地址， 也就找到了该数组或函数。这样一来， 凡是出现数组，函数的地方都可以用一个指针变量来表示， 只要该指针变量中赋予数组或函数的首地址即可。这样做， 将会使程序的概念十分清楚，程序本身也精练，高效。在Ｃ语言中， 一种数据类型或数据结构往往都占有一组连续的内存单元。 用“地址”这个概念并不能很好地描述一种数据类型或数据结构， 而“指针”虽然实际上也是一个地址，但它却是一个数据结构的首地址， 它是“指向”一个数据结构的，因而概念更为清楚，表示更为明确。 这也是引入“指针”概念的一个重要原因。 指针变量的类型说明对指针变量的类型说明包括三个内容：(1)指针类型说明，即定义变量为一个指针变量；(2)指针变量名；(3)变量值(指针)所指向的变量的数据类型。其一般形式为： 类型说明符 ※变量名；其中，※表示这是一个指针变量，变量名即为定义的指针变量名，类型说明符表示本指针变量所指向的变量的数据类型。例如：12345int ※p1;/※表示p1是一个指针变量，它的值是某个整型变量的地址。 或者说p1指向一个整型变量。至于p1究竟指向哪一个整型变量， 应由向p1赋予的地址来决定。※/staic int ※p2; /※p2是指向静态整型变量的指针变量※/float ※p3; /※p3是指向浮点变量的指针变量※/char ※p4; /※p4是指向字符变量的指针变量※/ 应该注意的是，一个指针变量只能指向同类型的变量，如P3 只能指向浮点变量，不能时而指向一个浮点变量， 时而又指向一个字符变量。 指针变量的赋值 指针变量同普通变量一样，使用之前不仅要定义说明， 而且必须赋予具体的值。未经赋值的指针变量不能使用， 否则将造成系统混乱，甚至死机。指针变量的赋值只能赋予地址， 决不能赋予任何其它数据，否则将引起错误。在Ｃ语言中， 变量的地址是由编译系统分配的，对用户完全透明，用户不知道变量的具体地址。 Ｃ语言中提供了地址运算符&amp;来表示变量的地址。其一般形式为： &amp; 变量名； 如&amp;a变示变量a的地址，&amp;b表示变量b的地址。 变量本身必须预先说明。设有指向整型变量的指针变量p，如要把整型变量a 的地址赋予p可以有以下两种方式： (1)指针变量初始化的方法 int a;int ※p=&a;(2)赋值语句的方法 int a;int ※p;p=&a;不允许把一个数赋予指针变量，故下面的赋值是错误的： int ※p;p=1000; 被赋值的指针变量前不能再加“※”说明符，如写为※p=&amp;a 也是错误的 指针变量的运算 指针变量可以进行某些运算，但其运算的种类是有限的。 它只能进行赋值运算和部分算术运算及关系运算。 1.指针运算符 (1)取地址运算符&amp; 取地址运算符&amp;是单目运算符，其结合性为自右至左，其功能是取变量的地址。在scanf函数及前面介绍指针变量赋值中，我们已经了解并使用了&amp;运算符。 (2)取内容运算符※ 取内容运算符※是单目运算符，其结合性为自右至左，用来表示指针变量所指的变量。在※运算符之后跟的变量必须是指针变量。需要注意的是指针运算符※和指针变量说明中的指针说明符※ 不是一回事。在指针变量说明中，“※”是类型说明符，表示其后的变量是指针类型。而表达式中出现的“※”则是一个运算符用以表示指针变量所指的变量。表示指针变量p取得了整型变量a的地址。本语句表示输出变量a的值。 1234main()&#123;int a=5,※p=&amp;a;printf (&quot;%d&quot;,※p);&#125; 2.指针变量的运算(1)赋值运算 指针变量的赋值运算有以下几种形式：①指针变量初始化赋值，前面已作介绍。 ②把一个变量的地址赋予指向相同数据类型的指针变量。例如：int a,※pa;pa=&a; /※把整型变量a的地址赋予整型指针变量pa※/ ③把一个指针变量的值赋予指向相同类型变量的另一个指针变量。如：int a,※pa=&amp;a,※pb;pb=pa; /※把a的地址赋予指针变量pb※/由于pa,pb均为指向整型变量的指针变量，因此可以相互赋值。 ④把数组的首地址赋予指向数组的指针变量。例如： int a[5],※pa;pa=a; (数组名表示数组的首地址，故可赋予指向数组的指针变量pa)也可写为：pa=&amp;a[0]; /※数组第一个元素的地址也是整个数组的首地址，也可赋予pa※/当然也可采取初始化赋值的方法：int a[5],※pa=a; ⑤把字符串的首地址赋予指向字符类型的指针变量。例如： char ※pc;pc=”c language”;或用初始化赋值的方法写为： char ※pc=”C Language”; 这里应说明的是并不是把整个字符串装入指针变量， 而是把存放该字符串的字符数组的首地址装入指针变量。 在后面还将详细介绍。 ⑥把函数的入口地址赋予指向函数的指针变量。例如： int (※pf)();pf=f; /※f为函数名※/ (2)加减算术运算 对于指向数组的指针变量，可以加上或减去一个整数n。设pa是指向数组a的指针变量，则pa+n,pa-n,pa++,++pa,pa–,–pa 运算都是合法的。指针变量加或减一个整数n的意义是把指针指向的当前位置(指向某数组元素)向前或向后移动n个位置。应该注意，数组指针变量向前或向后移动一个位置和地址加1或减1 在概念上是不同的。因为数组可以有不同的类型， 各种类型的数组元素所占的字节长度是不同的。如指针变量加1，即向后移动1 个位置表示指针变量指向下一个数据元素的首地址。而不是在原地址基础上加1。例如： 123int a[5],※pa;pa=a; /※pa指向数组a，也是指向a[0]※/pa=pa+2; /※pa指向a[2]，即pa的值为&amp;pa[2]※/ 指针变量的加减运算只能对数组指针变量进行， 对指向其它类型变量的指针变量作加减运算是毫无意义的。两个指针变量之间的运算只有指向同一数组的两个指针变量之间才能进行运算， 否则运算毫无意义。 ①两指针变量相减两指针变量相减所得之差是两个指针所指数组元素之间相差的元素个数。实际上是两个指针值(地址) 相减之差再除以该数组元素的长度(字节数)。例如pf1和pf2 是指向同一浮点数组的两个指针变量，设pf1的值为2010H，pf2的值为2000H，而浮点数组每个元素占4个字节，所以pf1-pf2的结果为(2000H-2010H)/4=4，表示pf1和 pf2之间相差4个元素。两个指针变量不能进行加法运算。 例如， pf1+pf2是什么意思呢?毫无实际意义。 ②两指针变量进行关系运算指向同一数组的两指针变量进行关系运算可表示它们所指数组元素之间的关系。例如：pf1==pf2表示pf1和pf2指向同一数组元素pf1&gt;pf2表示pf1处于高地址位置pf1&lt;pf2表示pf2处于低地址位置123456789main()&#123;int a=10,b=20,s,t,※pa,※pb;pa=&amp;a;pb=&amp;b;s=※pa+※pb;t=※pa※※pb;printf(&quot;a=%d/nb=%d/na+b=%d/na※b=%d/n&quot;,a,b,a+b,a※b);printf(&quot;s=%d/nt=%d/n&quot;,s,t);&#125; ……说明pa,pb为整型指针变量给指针变量pa赋值，pa指向变量a。给指针变量pb赋值，pb指向变量b。本行的意义是求a+b之和，(※pa就是a，※pb就是b)。本行是求a※b之积。输出结果。输出结果。…… 指针变量还可以与0比较。设p为指针变量，则p==0表明p是空指针，它不指向任何变量；p!=0表示p不是空指针。空指针是由对指针变量赋予0值而得到的。例如： #define NULL 0 int ※p=NULL; 对指针变量赋0值和不赋值是不同的。指针变量未赋值时，可以是任意值，是不能使用的。否则将造成意外错误。而指针变量赋0值后，则可以使用，只是它不指向具体的变量而已。1234567891011121314main()&#123;int a,b,c,※pmax,※pmin;printf(&quot;input three numbers:/n&quot;);scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);if(a&gt;b)&#123;pmax=&amp;a;pmin=&amp;b;&#125;else&#123;pmax=&amp;b;pmin=&amp;a;&#125;if(c&gt;※pmax) pmax=&amp;c;if(c&lt;※pmin) pmin=&amp;c;printf(&quot;max=%d/nmin=%d/n&quot;,※pmax,※pmin);&#125; ……pmax,pmin为整型指针变量。输入提示。输入三个数字。如果第一个数字大于第二个数字．．．指针变量赋值指针变量赋值 指针变量赋值指针变量赋值判断并赋值判断并赋值输出结果…… 数组指针变量的说明和使用 指向数组的指针变量称为数组指针变量。 在讨论数组指针变量的说明和使用之前，我们先明确几个关系。一个数组是由连续的一块内存单元组成的。 数组名就是这块连续内存单元的首地址。一个数组也是由各个数组元素(下标变量) 组成的。每个数组元素按其类型不同占有几个连续的内存单元。 一个数组元素的首地址也是指它所占有的几个内存单元的首地址。 一个指针变量既可以指向一个数组，也可以指向一个数组元素， 可把数组名或第一个元素的地址赋予它。如要使指针变量指向第i号元素可以把i元素的首地址赋予它或把数组名加i赋予它。 设有实数组a，指向a的指针变量为pa，从图6.3中我们可以看出有以下关系：pa,a,&amp;a[0]均指向同一单元，它们是数组a的首地址，也是0 号元素a[0]的首地址。pa+1,a+1,&amp;a[1]均指向1号元素a[1]。类推可知a+i,a+i,&amp;a[i]指向i号元素a[i]。应该说明的是pa是变量，而a,&amp;a[i]都是常量。在编程时应予以注意。12345678main()&#123;int a[5],i;for(i=0;i&lt;5;i++)&#123;a[i]=i;printf(&quot;a[%d]=%d/n&quot;,i,a[i]);&#125;printf(&quot;/n&quot;);&#125; …….主函数定义一个整型数组和一个整型变量循环语句给数组赋值打印每一个数组的值……输出换行……※※数组指针变量说明的一般形式为：类型说明符 ※ 指针变量名 其中类型说明符表示所指数组的类型。 从一般形式可以看出指向数组的指针变量和指向普通变量的指针变量的说明是相同的。引入指针变量后，就可以用两种方法来访问数组元素了。 第一种方法为下标法，即用a[i]形式访问数组元素。 在第四章中介绍数组时都是采用这种方法。 第二种方法为指针法，即采用※(pa+i)形式，用间接访问的方法来访问数组元素。※※12345678910111213main()&#123;int a[5],i,※pa;pa=a;for(i=0;i&lt;5;i++)&#123;※pa=i;pa++;&#125;pa=a;for(i=0;i&lt;5;i++)&#123;printf(&quot;a[%d]=%d/n&quot;,i,※pa);pa++;&#125;&#125; ……主函数定义整型数组和指针将指针pa指向数组a循环将变量i的值赋给由指针pa指向的a[]的数组单元将指针pa指向a[]的下一个单元……指针pa重新取得数组a的首地址循环用数组方式输出数组a中的所有元素将指针pa指向a[]的下一个单元…………下面，另举一例，该例与上例本意相同，但是实现方式不同。1234567main()&#123;int a[5],i,※pa=a;for(i=0;i&lt;5;)&#123;※pa=i;printf(&quot;a[%d]=%d/n&quot;,i++,※pa++);&#125;&#125; 主函数定义整型数组和指针，并使指针指向数组a循环将变量i的值赋给由指针pa指向的a[]的数组单元用指针输出数组a中的所有元素，同时指针pa指向a[]的下一个单元………… 数组名和数组指针变量作函数参数 在第五章中曾经介绍过用数组名作函数的实参和形参的问题。在学习指针变量之后就更容易理解这个问题了。 数组名就是数组的首地址，实参向形参传送数组名实际上就是传送数组的地址， 形参得到该地址后也指向同一数组。 这就好象同一件物品有两个彼此不同的名称一样。同样，指针变量的值也是地址， 数组指针变量的值即为数组的首地址，当然也可作为函数的参数使用。※※ 123456789101112131415161718float aver(float ※pa);main()&#123;float sco[5],av,※sp;int i;sp=sco;printf(&quot;/ninput 5 scores:/n&quot;);for(i=0;i&lt;5;i++) scanf(&quot;%f&quot;,&amp;sco[i]);av=aver(sp);printf(&quot;average score is %5.2f&quot;,av);&#125;float aver(float ※pa)&#123;int i;float av,s=0;for(i=0;i&lt;5;i++) s=s+※pa++;av=s/5;return av;&#125; 指向多维数组的指针变量本小节以二维数组为例介绍多维数组的指针变量。 一、多维数组地址的表示方法设有整型二维数组a[3][4]如下：0 1 2 34 5 6 78 9 10 11 设数组a的首地址为1000，各下标变量的首地址及其值如图所示。在第四章中介绍过， Ｃ语言允许把一个二维数组分解为多个一维数组来处理。因此数组a可分解为三个一维数组，即a[0]，a[1]，a[2]。每一个一维数组又含有四个元素。例如a[0]数组，含有a[0][0]，a[0][1]，a[0][2]，a[0][3]四个元素。 数组及数组元素的地址表示如下：a是二维数组名，也是二维数组0行的首地址，等于1000。a[0]是第一个一维数组的数组名和首地址，因此也为1000。※(a+0)或※a是与a[0]等效的， 它表示一维数组a[0]0 号元素的首地址。 也为1000。&amp;a[0][0]是二维数组a的0行0列元素首地址，同样是1000。因此，a，a[0]，※(a+0)，※a?amp;a[0][0]是相等的。同理，a+1是二维数组1行的首地址，等于1008。a[1]是第二个一维数组的数组名和首地址，因此也为1008。 &amp;a[1][0]是二维数组a的1行0列元素地址，也是1008。因此a+1,a[1],※(a+1),&amp;a[1][0]是等同的。 由此可得出：a+i，a[i]，※(a+i)，&amp;a[i][0]是等同的。 此外，&amp;a[i]和a[i]也是等同的。因为在二维数组中不能把&amp;a[i]理解为元素a[i]的地址，不存在元素a[i]。 Ｃ语言规定，它是一种地址计算方法，表示数组a第i行首地址。由此，我们得出：a[i]，&amp;a[i]，※(a+i)和a+i也都是等同的。另外，a[0]也可以看成是a[0]+0是一维数组a[0]的0号元素的首地址， 而a[0]+1则是a[0]的1号元素首地址，由此可得出a[i]+j则是一维数组a[i]的j号元素首地址，它等于&amp;a[i][j]。由a[i]=※(a+i)得a[i]+j=※(a+i)+j，由于※(a+i)+j是二维数组a的i行j列元素的首地址。该元素的值等于※(※(a+i)+j)。 12345678910[Explain] #define PF &quot;%d,%d,%d,%d,%d,/n&quot; main()&#123; static int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;; printf(PF,a,※a,a[0],&amp;a[0],&amp;a[0][0]); printf(PF,a+1,※(a+1),a[1],&amp;a[1],&amp;a[1][0]); printf(PF,a+2,※(a+2),a[2],&amp;a[2],&amp;a[2][0]); printf(&quot;%d,%d/n&quot;,a[1]+1,※(a+1)+1); printf(&quot;%d,%d/n&quot;,※(a[1]+1),※(※(a+1)+1)); &#125; 二、多维数组的指针变量 把二维数组a 分解为一维数组a[0],a[1],a[2]之后，设p为指向二维数组的指针变量。可定义为： int (※p)[4] 它表示p是一个指针变量，它指向二维数组a 或指向第一个一维数组a[0]，其值等于a,a[0]，或&amp;a[0][0]等。而p+i则指向一维数组a[i]。从前面的分析可得出※(p+i)+j是二维数组i行j 列的元素的地址，而※(※(p+i)+j)则是i行j列元素的值。 二维数组指针变量说明的一般形式为： 类型说明符 (※指针变量名)[长度] 其中“类型说明符”为所指数组的数据类型。“※”表示其后的变量是指针类型。 “长度”表示二维数组分解为多个一维数组时， 一维数组的长度，也就是二维数组的列数。应注意“(※指针变量名)”两边的括号不可少，如缺少括号则表示是指针数组(本章后面介绍)，意义就完全不同了。[Explain]12345678main()&#123;static int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;int(※p)[4];int i,j;p=a;for(i=0;i&lt;3;i++)for(j=0;j&lt;4;j++) printf(&quot;%2d &quot;,※(※(p+i)+j));&#125; ‘Expain字符串指针变量的说明和使用字符串指针变量的定义说明与指向字符变量的指针变量说明是相同的。只能按对指针变量的赋值不同来区别。 对指向字符变量的指针变量应赋予该字符变量的地址。如： char c,※p=&c;表示p是一个指向字符变量c的指针变量。而： char ※s=”C Language”;则表示s是一个指向字符串的指针变量。把字符串的首地址赋予s。请看下面一例。12345main()&#123;char ※ps;ps=&quot;C Language&quot;;printf(&quot;%s&quot;,ps);&#125; 运行结果为：C Language 上例中，首先定义ps是一个字符指针变量， 然后把字符串的首地址赋予ps(应写出整个字符串，以便编译系统把该串装入连续的一块内存单元)，并把首地址送入ps。程序中的： char ※ps;ps=”C Language”;等效于： char ※ps=”C Language”;输出字符串中n个字符后的所有字符。 123456main()&#123;char ※ps=&quot;this is a book&quot;;int n=10;ps=ps+n;printf(&quot;%s/n&quot;,ps);&#125; 运行结果为：book 在程序中对ps初始化时，即把字符串首地址赋予ps，当ps= ps+10之后，ps指向字符“b”，因此输出为”book”。12345678910111213main()&#123;char st[20],※ps;int i;printf(&quot;input a string:/n&quot;);ps=st;scanf(&quot;%s&quot;,ps);for(i=0;ps[i]!=&apos;/0&apos;;i++)if(ps[i]==&apos;k&apos;)&#123;printf(&quot;there is a &apos;k&apos; in the string/n&quot;);break;&#125;if(ps[i]==&apos;/0&apos;) printf(&quot;There is no &apos;k&apos; in the string/n&quot;);&#125; 本例是在输入的字符串中查找有无‘k’字符。 下面这个例子是将指针变量指向一个格式字符串，用在printf函数中，用于输出二维数组的各种地址表示的值。但在printf语句中用指针变量PF代替了格式串。 这也是程序中常用的方法。12345678910main()&#123;static int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;char ※PF;PF=&quot;%d,%d,%d,%d,%d/n&quot;;printf(PF,a,※a,a[0],&amp;a[0],&amp;a[0][0]);printf(PF,a+1,※(a+1),a[1],&amp;a[1],&amp;a[1][0]);printf(PF,a+2,※(a+2),a[2],&amp;a[2],&amp;a[2][0]);printf(&quot;%d,%d/n&quot;,a[1]+1,※(a+1)+1);printf(&quot;%d,%d/n&quot;,※(a[1]+1),※(※(a+1)+1));&#125; 在下例是讲解，把字符串指针作为函数参数的使用。要求把一个字符串的内容复制到另一个字符串中，并且不能使用strcpy函数。函数cprstr的形参为两个字符指针变量。pss指向源字符串，pds指向目标字符串。表达式：123456789101112(※pds=※pss)!=`/0&apos;cpystr(char ※pss,char ※pds)&#123;while((※pds=※pss)!=&apos;/0&apos;)&#123;pds++;pss++; &#125;&#125;main()&#123;char ※pa=&quot;CHINA&quot;,b[10],※pb;pb=b;cpystr(pa,pb);printf(&quot;string a=%s/nstring b=%s/n&quot;,pa,pb);&#125; 在上例中，程序完成了两项工作：一是把pss指向的源字符复制到pds所指向的目标字符中，二是判断所复制的字符是否为`/0’，若是则表明源字符串结束，不再循环。否则，pds和pss都加1，指向下一字符。在主函数中，以指针变量pa,pb为实参，分别取得确定值后调用cprstr函数。由于采用的指针变量pa和pss,pb和pds均指向同一字符串，因此在主函数和cprstr函数中均可使用这些字符串。也可以把cprstr函数简化为以下形式：12cprstr(char ※pss,char※pds)&#123;while ((※pds++=※pss++)!=`/0&apos;);&#125; 即把指针的移动和赋值合并在一个语句中。 进一步分析还可发现/0&#39;的ASCⅡ码为0，对于while语句只看表达式的值为非0就循环，为0则结束循环，因此也可省去“!=/0’”这一判断部分，而写为以下形式：12cprstr (char ※pss,char ※pds)&#123;while (※pdss++=※pss++);&#125; 表达式的意义可解释为，源字符向目标字符赋值， 移动指针，若所赋值为非0则循环，否则结束循环。这样使程序更加简洁。简化后的程序如下所示。123456789cpystr(char ※pss,char ※pds)&#123;while(※pds++=※pss++);&#125;main()&#123;char ※pa=&quot;CHINA&quot;,b[10],※pb;pb=b;cpystr(pa,pb);printf(&quot;string a=%s/nstring b=%s/n&quot;,pa,pb);&#125; 使用字符串指针变量与字符数组的区别用字符数组和字符指针变量都可实现字符串的存储和运算。 但是两者是有区别的。在使用时应注意以下几个问题： 字符串指针变量本身是一个变量，用于存放字符串的首地址。而字符串本身是存放在以该首地址为首的一块连续的内存空间中并以‘/0’作为串的结束。字符数组是由于若干个数组元素组成的，它可用来存放整个字符串。 对字符数组作初始化赋值，必须采用外部类型或静态类型，如： static char st[]={“C Language”};而对字符串指针变量则无此限制，如： char ※ps=”C Language”; 对字符串指针方式 char ※ps=”C Language”;可以写为： char ※ps; ps=”C Language”;而对数组方式：static char st[]={“C Language”};不能写为：char st[20];st={“C Language”};而只能对字符数组的各元素逐个赋值。 从以上几点可以看出字符串指针变量与字符数组在使用时的区别，同时也可看出使用指针变量更加方便。前面说过，当一个指针变量在未取得确定地址前使用是危险的，容易引起错误。但是对指针变量直接赋值是可以的。因为C系统对指针变量赋值时要给以确定的地址。因此，char ※ps=”C Langage”;或者 char ※ps;ps=”C Language”;都是合法的。 函数指针变量 在Ｃ语言中规定，一个函数总是占用一段连续的内存区， 而函数名就是该函数所占内存区的首地址。 我们可以把函数的这个首地址(或称入口地址)赋予一个指针变量， 使该指针变量指向该函数。然后通过指针变量就可以找到并调用这个函数。 我们把这种指向函数的指针变量称为“函数指针变量”。函数指针变量定义的一般形式为：类型说明符 (※指针变量名)();其中“类型说明符”表示被指函数的返回值的类型。“(※ 指针变量名)”表示“※”后面的变量是定义的指针变量。 最后的空括号表示指针变量所指的是一个函数。例如： int (※pf)();表示pf是一个指向函数入口的指针变量，该函数的返回值(函数值)是整型。下面通过例子来说明用指针形式实现对函数调用的方法。 1234567891011121314int max(int a,int b)&#123;if(a&gt;b)return a;else return b;&#125;main()&#123;int max(int a,int b);int(※pmax)();int x,y,z;pmax=max;printf(&quot;input two numbers:/n&quot;);scanf(&quot;%d%d&quot;,&amp;x,&amp;y);z=(※pmax)(x,y);printf(&quot;maxmum=%d&quot;,z);&#125; 从上述程序可以看出用，函数指针变量形式调用函数的步骤如下： 先定义函数指针变量，如后一程序中第9行 int (※pmax)();定义pmax为函数指针变量。 把被调函数的入口地址(函数名)赋予该函数指针变量，如程序中第11行 pmax=max; 用函数指针变量形式调用函数，如程序第14行 z=(※pmax)(x,y); 调用函数的一般形式为： (※指针变量名) (实参表)使用函数指针变量还应注意以下两点： a. 函数指针变量不能进行算术运算，这是与数组指针变量不同的。数组指针变量加减一个整数可使指针移动指向后面或前面的数组元素，而函数指针的移动是毫无意义的。 b. 函数调用中”(※指针变量名)”的两边的括号不可少，其中的※不应该理解为求值运算，在此处它只是一种表示符号。 指针型函数前面我们介绍过，所谓函数类型是指函数返回值的类型。 在Ｃ语言中允许一个函数的返回值是一个指针(即地址)， 这种返回指针值的函数称为指针型函数。定义指针型函数的一般形式为：12345678910类型说明符 ※函数名(形参表)&#123;…… /※函数体※/&#125;其中函数名之前加了“※”号表明这是一个指针型函数，即返回值是一个指针。类型说明符表示了返回的指针值所指向的数据类型。如：int ※ap(int x,int y)&#123;...... /※函数体※/&#125; 表示ap是一个返回指针值的指针型函数， 它返回的指针指向一个整型变量。下例中定义了一个指针型函数 day_name，它的返回值指向一个字符串。该函数中定义了一个静态指针数组name。name 数组初始化赋值为八个字符串，分别表示各个星期名及出错提示。形参n表示与星期名所对应的整数。在主函数中， 把输入的整数i作为实参， 在printf语句中调用day_name函数并把i值传送给形参 n。day_name函数中的return语句包含一个条件表达式， n 值若大于7或小于1则把name[0] 指针返回主函数输出出错提示字符串“Illegal day”。否则返回主函数输出对应的星期名。主函数中的第7行是个条件语句，其语义是，如输入为负数(i&lt;0)则中止程序运行退出程序。exit是一个库函数，exit(1)表示发生错误后退出程序， exit(0)表示正常退出。 应该特别注意的是函数指针变量和指针型函数这两者在写法和意义上的区别。如int(※p)()和int ※p()是两个完全不同的量。int(※p)()是一个变量说明，说明p 是一个指向函数入口的指针变量，该函数的返回值是整型量，(※p)的两边的括号不能少。int ※p() 则不是变量说明而是函数说明，说明p是一个指针型函数，其返回值是一个指向整型量的指针，※p两边没有括号。作为函数说明， 在括号内最好写入形式参数，这样便于与变量说明区别。 对于指针型函数定义，int ※p()只是函数头部分，一般还应该有函数体部分。 12345678910111213141516171819main()&#123;int i;char ※day_name(int n);printf(&quot;input Day No:/n&quot;);scanf(&quot;%d&quot;,&amp;i);if(i&lt;0) exit(1);printf(&quot;Day No:%2d--&gt;%s/n&quot;,i,day_name(i));&#125;char ※day_name(int n)&#123;static char ※name[]=&#123; &quot;Illegal day&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;,&quot;Sunday&quot;&#125;;return((n&lt;1||n&gt;7) ? name[0] : name[n]);&#125; 本程序是通过指针函数，输入一个1～7之间的整数， 输出对应的星期名。指针数组的说明与使用一个数组的元素值为指针则是指针数组。 指针数组是一组有序的指针的集合。 指针数组的所有元素都必须是具有相同存储类型和指向相同数据类型的指针变量。 指针数组说明的一般形式为： 类型说明符※数组名[数组长度] 其中类型说明符为指针值所指向的变量的类型。例如： int ※pa[3] 表示pa是一个指针数组，它有三个数组元素， 每个元素值都是一个指针，指向整型变量。通常可用一个指针数组来指向一个二维数组。 指针数组中的每个元素被赋予二维数组每一行的首地址， 因此也可理解为指向一个一维数组。 12345678910int a[3][3]=&#123;1,2,3,4,5,6,7,8,9&#125;;int ※pa[3]=&#123;a[0],a[1],a[2]&#125;;int ※p=a[0];main()&#123;int i;for(i=0;i&lt;3;i++)printf(&quot;%d,%d,%d/n&quot;,a[i][2-i],※a[i],※(※(a+i)+i));for(i=0;i&lt;3;i++)printf(&quot;%d,%d,%d/n&quot;,※pa[i],p[i],※(p+i));&#125; 本例程序中，pa是一个指针数组，三个元素分别指向二维数组a的各行。然后用循环语句输出指定的数组元素。其中※a[i]表示i行0列元素值；※(※(a+i)+i)表示i行i列的元素值；※pa[i]表示i行0列元素值；由于p与a[0]相同，故p[i]表示0行i列的值；※(p+i)表示0行i列的值。读者可仔细领会元素值的各种不同的表示方法。 应该注意指针数组和二维数组指针变量的区别。 这两者虽然都可用来表示二维数组，但是其表示方法和意义是不同的。 二维数组指针变量是单个的变量，其一般形式中”(※指针变量名)”两边的括号不可少。而指针数组类型表示的是多个指针( 一组有序指针)在一般形式中”※指针数组名”两边不能有括号。例如： int (※p)[3];表示一个指向二维数组的指针变量。该二维数组的列数为3或分解为一维数组的长度为3。 int ※p[3] 表示p是一个指针数组，有三个下标变量p[0]，p[1]，p[2]均为指针变量。 指针数组也常用来表示一组字符串， 这时指针数组的每个元素被赋予一个字符串的首地址。 指向字符串的指针数组的初始化更为简单。例如在例6.20中即采用指针数组来表示一组字符串。 其初始化赋值为： 12345678char ※name[]=&#123;&quot;Illagal day&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;,&quot;Sunday&quot;&#125;; 完成这个初始化赋值之后，name[0]即指向字符串”Illegal day”，name[1]指?quot;Monday”……。 指针数组也可以用作函数参数。在本例主函数中，定义了一个指针数组name，并对name 作了初始化赋值。其每个元素都指向一个字符串。然后又以name 作为实参调用指针型函数day name，在调用时把数组名 name 赋予形参变量name，输入的整数i作为第二个实参赋予形参n。在day name函数中定义了两个指针变量pp1和pp2，pp1被赋予name[0]的值(即※name)，pp2被赋予name[n]的值即※(name+ n)。由条件表达式决定返回pp1或pp2指针给主函数中的指针变量ps。最后输出i和ps的值。 指针数组作指针型函数的参数12345678910111213141516171819202122232425main()&#123;static char ※name[]=&#123; &quot;Illegal day&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;,&quot;Sunday&quot;&#125;;char ※ps;int i;char ※day name(char ※name[],int n);printf(&quot;input Day No:/n&quot;);scanf(&quot;%d&quot;,&amp;i);if(i&lt;0) exit(1);ps=day name(name,i);printf(&quot;Day No:%2d--&gt;%s/n&quot;,i,ps);&#125;char ※day name(char ※name[],int n)&#123;char ※pp1,※pp2;pp1=※name;pp2=※(name+n);return((n&lt;1||n&gt;7)? pp1:pp2);&#125; 下例要求输入5个国名并按字母顺序排列后输出。在以前的例子中采用了普通的排序方法， 逐个比较之后交换字符串的位置。交换字符串的物理位置是通过字符串复制函数完成的。 反复的交换将使程序执行的速度很慢，同时由于各字符串(国名) 的长度不同，又增加了存储管理的负担。 用指针数组能很好地解决这些问题。把所有的字符串存放在一个数组中， 把这些字符数组的首地址放在一个指针数组中，当需要交换两个字符串时， 只须交换指针数组相应两元素的内容(地址)即可，而不必交换字符串本身。程序中定义了两个函数，一个名为sort完成排序， 其形参为指针数组name，即为待排序的各字符串数组的指针。形参n为字符串的个数。另一个函数名为print，用于排序后字符串的输出，其形参与sort的形参相同。主函数main中，定义了指针数组name 并作了初始化赋值。然后分别调用sort函数和print函数完成排序和输出。值得说明的是在sort函数中，对两个字符串比较，采用了strcmp 函数，strcmp函数允许参与比较的串以指针方式出现。name[k]和name[ j]均为指针，因此是合法的。字符串比较后需要交换时， 只交换指针数组元素的值，而不交换具体的字符串， 这样将大大减少时间的开销，提高了运行效率。 现编程如下： 123456789101112131415161718192021222324252627main()&#123;void sort(char ※name[],int n);void print(char ※name[],int n);static char ※name[]=&#123; &quot;CHINA&quot;,&quot;AMERICA&quot;,&quot;AUSTRALIA&quot;,&quot;FRANCE&quot;,&quot;GERMAN&quot;&#125;;int n=5;sort(name,n);print(name,n);&#125;void sort(char ※name[],int n)&#123;char ※pt;int i,j,k;for(i=0;i&lt;n-1;i++)&#123;k=i;for(j=i+1;j&lt;n;j++)if(strcmp(name[k],name[j])&gt;0) k=j;if(k!=i)&#123;pt=name[i];name[i]=name[k];name[k]=pt;&#125;&#125;&#125;void print(char ※name[],int n)&#123;int i;for (i=0;i&lt;n;i++) printf(&quot;%s/n&quot;,name[i]);&#125; ｍａｉｎ函数的参数 前面介绍的main函数都是不带参数的。因此main 后的括号都是空括号。实际上，main函数可以带参数，这个参数可以认为是 main函数的形式参数。Ｃ语言规定main函数的参数只能有两个， 习惯上这两个参数写为argc和argv。因此，main函数的函数头可写为： main (argc,argv)Ｃ语言还规定argc(第一个形参)必须是整型变量,argv( 第二个形参)必须是指向字符串的指针数组。 加上形参说明后，main函数的函数头应写为：(argc,argv)123int argv;char ※argv[];或写成：main (int argc,char ※argv[]) 由于main函数不能被其它函数调用， 因此不可能在程序内部取得实际值。那么，在何处把实参值赋予main函数的形参呢? 实际上,main函数的参数值是从操作系统命令行上获得的。当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数即可把这些实参传送到main的形参中去。 DOS提示符下命令行的一般形式为： C:/&gt;可执行文件名 参数 参数……; 但是应该特别注意的是，main 的两个形参和命令行中的参数在位置上不是一一对应的。因为,main的形参只有二个，而命令行中的参数个数原则上未加限制。argc参数表示了命令行中参数的个数(注意：文件名本身也算一个参数)，argc的值是在输入命令行时由系统按实际参数的个数自动赋予的。例如有命令行为： C:/&gt;E6 24 BASIC dbase FORTRAN由于文件名E6 24本身也算一个参数，所以共有4个参数，因此argc取得的值为4。argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处理)的首地址。 指针数组的长度即为参数个数。数组元素初值由系统自动赋予。其表示如图6.8所示：argc,char ※argv)&#123;123while(argc--&gt;1)printf(&quot;%s/n&quot;,※++argv);&#125; 本例是显示命令行中输入的参数如果上例的可执行文件名为e24.exe，存放在A驱动器的盘内。因此输入的命令行为： C:/&gt;a:e24 BASIC dBASE FORTRAN 则运行结果为：BASICdBASEFORTRAN 该行共有4个参数，执行main时，argc的初值即为4。argv的4个元素分为4个字符串的首地址。执行while语句，每循环一次 argv值减1，当argv等于1时停止循环，共循环三次， 因此共可输出三个参数。在printf函数中，由于打印项※++argv是先加1再打印， 故第一次打印的是argv[1]所指的字符串BASIC。第二、 三次循环分别打印后二个字符串。而参数e24是文件名，不必输出。 下例的命令行中有两个参数，第二个参数20即为输入的n值。在程序中※++argv的值为字符串“20”，然后用函数”atoi”把它换为整型作为while语句中的循环控制变量，输出20个偶数。12345main(int argc,char※argv[])&#123;int a=0,n;n=atoi(※++argv);while(n--) printf(&quot;%d &quot;,a++※2);&#125; 本程序是从0开始输出n个偶数。指向指针的指针变量如果一个指针变量存放的又是另一个指针变量的地址， 则称这个指针变量为指向指针的指针变量。 在前面已经介绍过，通过指针访问变量称为间接访问， 简称间访。由于指针变量直接指向变量，所以称为单级间访。 而如果通过指向指针的指针变量来访问变量则构成了二级或多级间访。在Ｃ语言程序中，对间访的级数并未明确限制， 但是间访级数太多时不容易理解解，也容易出错，因此，一般很少超过二级间访。 指向指针的指针变量说明的一般形式为： 类型说明符※※ 指针变量名；例如： int ※※ pp; 表示pp是一个指针变量，它指向另一个指针变量， 而这个指针变量指向一个整型量。下面举一个例子来说明这种关系。123456int x,※p,※※pp;x=10;p=&amp;x;pp=&amp;p;printf(&quot;x=%d/n&quot;,※※pp);&#125; 上例程序中p 是一个指针变量，指向整型量x；pp也是一个指针变量， 它指向指针变量p。通过pp变量访问x的写法是※※pp。程序最后输出x的值为10。通过上例，读者可以学习指向指针的指针变量的说明和使用方法。 下述程序中首先定义说明了指针数组ps并作了初始化赋值。 又说明了pps是一个指向指针的指针变量。在5次循环中， pps 分别取得了ps[0]，ps[1]，ps[2]，ps[3]，ps[4]的地址值(如图6.10所示)。再通过这些地址即可找到该字符串。123456789static char ※ps[]=&#123; &quot;BASIC&quot;,&quot;DBASE&quot;,&quot;C&quot;,&quot;FORTRAN&quot;,&quot;PASCAL&quot;&#125;;char ※※pps;int i;for(i=0;i&lt;5;i++)&#123;pps=ps+i;printf(&quot;%s/n&quot;,※pps);&#125;&#125; 本程序是用指向指针的指针变量编程，输出多个字符串。 本章小结 指针是Ｃ语言中一个重要的组成部分，使用指针编程有以下优点：(1)提高程序的编译效率和执行速度。(2)通过指针可使用主调函数和被调函数之间共享变量或数据结构，便于实现双向数据通讯。(3)可以实现动态的存储分配。(4)便于表示各种数据结构，编写高质量的程序。 指针的运算(1)取地址运算符&amp;：求变量的地址(2)取内容运算符※：表示指针所指的变量(3)赋值运算·把变量地址赋予指针变量·同类型指针变量相互赋值·把数组，字符串的首地址赋予指针变量·把函数入口地址赋予指针变量(4)加减运算对指向数组，字符串的指针变量可以进行加减运算，如p+n,p-n,p++,p–等。对指向同一数组的两个指针变量可以相减。对指向其它类型的指针变量作加减运算是无意义的。(5)关系运算指向同一数组的两个指针变量之间可以进行大于、小于、 等于比较运算。指针可与0比较，p==0表示p为空指针。 与指针有关的各种说明和意义见下表。 123456int ※p; p为指向整型量的指针变量int ※p[n]; p为指针数组，由n个指向整型量的指针元素组成。int (※p)[n]; p为指向整型二维数组的指针变量，二维数组的列数为nint ※p() p为返回指针值的函数，该指针指向整型量int (※p)() p为指向函数的指针，该函数返回整型量int ※※p p为一个指向另一指针的指针变量，该指针指向一个整型量。 有关指针的说明很多是由指针，数组，函数说明组合而成的。但并不是可以任意组合，例如数组不能由函数组成，即数组元素不能是一个函数；函数也不能返回一个数组或返回另一个函数。例如int a5；就是错误的。 关于括号在解释组合说明符时， 标识符右边的方括号和圆括号优先于标识符左边的“※”号，而方括号和圆括号以相同的优先级从左到右结合。但可以用圆括号改变约定的结合顺序。 阅读组合说明符的规则是“从里向外”。从标识符开始，先看它右边有无方括号或园括号，如有则先作出解释，再看左边有无※号。 如果在任何时候遇到了闭括号，则在继续之前必须用相同的规则处理括号内的内容。例如：int※(※(※a)())[10]↑ ↑↑↑↑↑↑7 6 4 2 1 3 5上面给出了由内向外的阅读顺序，下面来解释它：(1)标识符a被说明为；(2)一个指针变量，它指向；(3)一个函数，它返回；(4)一个指针，该指针指向；(5)一个有10个元素的数组，其类型为；(6)指针型，它指向；(7)int型数据。因此a是一个函数指针变量，该函数返回的一个指针值又指向一个指针数组，该指针数组的元素指向整型量。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划详解]]></title>
    <url>%2F2018%2F06%2F01%2Fsecond%2F</url>
    <content type="text"><![CDATA[动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。首先，我们看一下这道题（此题目来源于北大POJ）： 数字三角形(POJ1163) 在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99输入格式：5 //表示三角形的行数接下来输入三角形行数73 88 1 02 7 4 44 5 2 6 5要求输出最大和接下来，我们来分析一下解题思路：首先，肯定得用二维数组来存放数字三角形然后我们用D( r, j) 来表示第r行第 j 个数字(r,j从1开始算)我们用MaxSum(r, j)表示从D(r,j)到底边的各条路径中，最佳路径的数字之和。因此，此题的最终问题就变成了求 MaxSum(1,1)当我们看到这个题目的时候，首先想到的就是可以用简单的递归来解题：D(r, j)出发，下一步只能走D(r+1,j)或者D(r+1, j+1)。故对于N行的三角形，我们可以写出如下的递归式：1234if ( r == N) MaxSum(r,j) = D(r,j)else MaxSum( r, j) = Max&#123; MaxSum(r＋1,j), MaxSum(r+1,j+1) &#125; + D(r,j) 根据上面这个简单的递归式，我们就可以很轻松地写出完整的递归代码： 1234567891011121314151617181920#include &lt;algorithm&gt; #define MAX 101using namespace std; int D[MAX][MAX];int n;int MaxSum(int i, int j)&#123; if(i==n) return D[i][j]; int x = MaxSum(i+1,j); int y = MaxSum(i+1,j+1); return max(x,y)+D[i][j];&#125; int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin &gt;&gt; D[i][j]; cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl;&#125; 对于如上这段递归的代码，当我提交到POJ时，会显示代码运行超时了，为什么会超时呢？ 答案很简单，因为我们重复计算了.picture就拿第三行数字1来说，当我们计算从第2行的数字3开始的MaxSum时会计算出从1开始的MaxSum，当我们计算从第二行的数字8开始的MaxSum的时候又会计算一次从1开始的MaxSum，也就是说有重复计算。这样就浪费了大量的时间。也就是说如果采用递规的方法，深度遍历每条路径，存在大量重复计算。则时间复杂度为 2的n次方,对于 n = 100 行，肯定超时。接下来，我们就要考虑如何进行改进，我们自然而然就可以想到如果每算出一个MaxSum(r,j)就保存起来，下次用到其值的时候直接取用，则可免去重复计算。那么可以用n方的时间复杂度完成计算。因为三角形的数字总数是 n(n+1)/2根据这个思路，我们就可以将上面的代码进行改进，使之成为记忆递归型的动态规划程序： 12345678910111213141516171819202122232425262728#include &lt;algorithm&gt; using namespace std; #define MAX 101 int D[MAX][MAX]; int n;int maxSum[MAX][MAX]; int MaxSum(int i, int j)&#123;if( maxSum[i][j] != -1 ) return maxSum[i][j];if(i==n) maxSum[i][j] = D[i][j]; else&#123; int x = MaxSum(i+1,j); int y = MaxSum(i+1,j+1); maxSum[i][j] = max(x,y)+ D[i][j]; &#125; return maxSum[i][j]; &#125; int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) &#123; cin &gt;&gt; D[i][j]; maxSum[i][j] = -1; &#125; cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl; &#125; 虽然在短时间内就AC了。但是，我们并不能满足于这样的代码，因为递归总是需要使用大量堆栈上的空间，很容易造成栈溢出，我们现在就要考虑如何把递归转换为递推，让我们一步一步来完成这个过程。我们首先需要计算的是最后一行，因此可以把最后一行直接写出， 73 88 1 02 7 4 4表格最下一行为（5X5）：4 5 2 6 5 现在开始分析倒数第二行的每一个数，现分析数字2，2可以和最后一行4相加，也可以和最后一行的5相加，但是很显然和5相加要更大一点，结果为7，我们此时就可以将7保存起来，然后分析数字7，7可以和最后一行的5相加，也可以和最后一行的2相加，很显然和5相加更大，结果为12，因此我们将12保存起来。以此类推。 73 88 1 02 7 4 4表格（5X5）后两行为：7 12 10 104 5 2 6 5然后按同样的道理分析倒数第三行和倒数第四行，最后分析第一行，我们可以依次得到如下结果：20 13 107 12 10 104 5 2 6 5之后变成：3023 2120 13 107 12 10 104 5 2 6 5上面的推导过程相信大家不难理解，理解之后我们就可以写出如下的递推型动态规划程序： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std; #define MAX 101 int D[MAX][MAX]; int n;int maxSum[MAX][MAX]; int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin &gt;&gt; D[i][j]; for( int i = 1;i &lt;= n; ++ i ) maxSum[n][i] = D[n][i]; for( int i = n-1; i&gt;= 1; --i ) for( int j = 1; j &lt;= i; ++j ) maxSum[i][j] = max(maxSum[i+1][j],maxSum[i+1][j+1]) + D[i][j]; cout &lt;&lt; maxSum[1][1] &lt;&lt; endl;&#125; 我们的代码仅仅是这样就够了吗？当然不是，我们仍然可以继续优化，而这个优化当然是对于空间进行优化，其实完全没必要用二维maxSum数组存储每一个MaxSum(r,j),只要从底层一行行向上递推，那么只要一维数组maxSum[100]即可,即只要存储一行的MaxSum值就可以。 接下里的步骤就按上图的过程一步一步推导就可以了。进一步考虑，我们甚至可以连maxSum数组都可以不要，直接用D的第n行直接替代maxSum即可。但是这里需要强调的是：虽然节省空间，但是时间复杂度还是不变的。 依照上面的方式，我们可以写出如下代码： 12345678910111213141516171819#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define MAX 101 int D[MAX][MAX];int n; int * maxSum; int main()&#123; int i,j; cin &gt;n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin &gt;D[i][j]; maxSum = D[n]; //maxSum指向第n行 for( int i = n-1; i&gt;= 1; --i ) for( int j = 1; j &lt;= i; ++j ) maxSum[j] = max(maxSum[j],maxSum[j+1]) + D[i][j]; cout &lt;&lt; maxSum[1] &lt;&lt; endl;&#125; 接下来，我们就进行一下总结： 递归到动规的一般转化方法 递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。 动规解题的一般思路1. 将原问题分解为子问题 把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。 2.确定状态 在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。 3.确定一些初始状态（边界状态）的值 以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。` 4. 确定状态转移方程 定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。 数字三角形的状态转移方程：可查看 能用动规解决的问题的特点 1) 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。 2) 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2018%2F05%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog.You can talk or help my ideas to more places where can help other people.my email is in about tag,you can talk with me by it. My knowledge are here1234567my present knowledge&lt;c/c++&gt; &lt;algorithm&gt;&lt;java se&gt; &lt;java ee&gt; &lt;Java Server Pages&gt;&lt;html/js/css&gt; &lt;3ds max&gt;&lt;database&gt;&lt;app build&gt; I will spend more time to make my knowledge adequate.]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
</search>
